# PREFACE

<span id="page-30-0"></span>In recent years, the cost required to develop a software product has increased significantly while the target hardware costs have decreased. Now a larger portion of money is expended in developing, using, and maintaining software. The trend in computing costs is the complete dominance of software over hardware costs. Because of this, it is necessary that formal disciplines be established to increase the probability that software is characterized by a high degree of correctness, maintainability, and portability. In addition, these disciplines must promote practices that aid in the consistent and orderly development of a software system within schedule and budgetary constraints. To be effective, these disciplines must adopt standards which channel individual software efforts toward a common goal.

The push for standards in the software development field has been met with various degrees of success. The Microprocessor Operating Systems Interfaces (MOSI) effort has experienced only limited success. As popular as the UNIX operating system has grown, the attempt to develop a standard interface definition to allow portable application development has only recently begun to produce the results needed in this area. Unfortunately, very little effort has been expended to provide standards addressing the needs of the real-time community. Several organizations have addressed this need during recent years.

The Real Time Executive Interface Definition (RTEID) was developed by Motorola with technical input from Software Components Group [\[Mot88\]](#page-1083-0). RTEID was adopted by the VMEbus International Trade Association (VITA) as a baseline draft for their proposed standard multiprocessor, real-time executive interface, Open Real-Time Kernel Interface Definition (ORKID) [\[VIT90\]](#page-1084-0). These two groups worked together with the IEEE P1003.4 committee to ensure that the functionality of their proposed standards is adopted as the real-time extensions to POSIX.

This proposed standard defines an interface for the development of real-time software to ease the writing of real-time application programs that are directly portable across multiple real-time executive implementations. This interface includes both the source code interfaces and runtime behavior as seen by a real-time application. It does not include the details of how a kernel implements these functions. The standard's goal is to serve as a complete definition of external interfaces so that application code that conforms to these interfaces will execute properly in all real-time executive environments. With the use of a standards compliant executive, routines that acquire memory blocks, create and manage message queues, establish and use semaphores, and send and receive signals need not be redeveloped for a different real-time environment as long as the new environment is compliant with the standard. Software developers need only concentrate on the hardware dependencies of the real-time system. Furthermore, most hardware dependencies for real-time applications can be localized to the device drivers.

A compliant executive provides simple and flexible real-time multiprocessing. It easily lends itself to both tightly-coupled and loosely-coupled configurations (depending on the system hardware configuration). Objects such as tasks, queues, events, signals, semaphores, and memory blocks can be designated as global objects and accessed by any task regardless of which processor the object and the accessing task reside.

The acceptance of a standard for real-time executives will produce the same advantages enjoyed from the push for UNIX standardization by AT&T's System V Interface Definition and IEEE's POSIX efforts. A compliant multiprocessing executive will allow close coupling between UNIX systems and real-time executives to provide the many benefits of the UNIX development environment to be applied to real-time software development. Together they provide the necessary laboratory environment to implement real-time, distributed, embedded systems using a wide variety of computer architectures.

A study was completed in 1988, within the Research, Development, and Engineering Center, U.S. Army Missile Command, which compared the various aspects of the Ada programming language as they related to the application of Ada code in distributed and/or multiple processing systems. Several critical conclusions were derived from the study. These conclusions have a major impact on the way the Army develops application software for embedded applications. These impacts apply to both in-house software development and contractor developed software.

A conclusion of the analysis, which has been previously recognized by other agencies attempting to utilize Ada in a distributed or multiprocessing environment, is that the Ada programming language does not adequately support multiprocessing. Ada does provide a mechanism for multi-tasking, however, this capability exists only for a single processor system. The language also does not have inherent capabilities to access global named variables, flags or program code. These critical features are essential in order for data to be shared between processors. However, these drawbacks do have workarounds which are sometimes awkward and defeat the intent of software maintainability and portability goals.

Another conclusion drawn from the analysis, was that the run time executives being delivered with the Ada compilers were too slow and inefficient to be used in modern missile systems. A run time executive is the core part of the run time system code, or operating system code, that controls task scheduling, input/output management and memory management. Traditionally, whenever efficient executive (also known as kernel) code was required by the application, the user developed in-house software. This software was usually written in assembly language for optimization.

Because of this shortcoming in the Ada programming language, software developers in research and development and contractors for project managed systems, are mandated by technology to purchase and utilize off-the-shelf third party kernel code. The contractor, and eventually the Government, must pay a licensing fee for every copy of the kernel code used in an embedded system.

The main drawback to this development environment is that the Government does not own, nor has the right to modify code contained within the kernel. V&V techniques in this situation are more difficult than if the complete source code were available. Responsibility for system failures due to faulty software is yet another area to be resolved under this environment.

The Guidance and Control Directorate began a software development effort to address these problems. A project to develop an experimental run time kernel was begun that will eliminate the major drawbacks of the Ada programming language mentioned above. The Real Time Executive for Multiprocessor Systems (RTEMS) provides full capabilities for management of tasks, interrupts, time, and multiple processors in addition to those features typical of generic operating systems. The code is open source, so no licensing fees are necessary.

RTEMS has been ported to over three dozen processor families over its long history. Some of

these architectures are obsolete and were removed. The current RTEMS version includes ports to the following processor families:

- Intel (Altera) NIOS II
- ARM
- AArch64
- Freescale (formerly Motorola) MC68xxx
- Freescale (formerly Motorola) MC683xx
- Freescale (formerly Motorola) ColdFire
- Intel i386 and above
- Intel x86\_64
- Xilinx (AMD) Microblaze
- MIPS
- Moxie Processor
- OpenRISC OR1K
- PowerPC
- RISC-V
- SPARC v7 and v8

Since almost all of RTEMS is written in a high level language, ports to additional processor families require minimal effort. The portabilty and abstraction layers provided by RTEMS enable transitioning an application one processor family to another without major application redesign.

RTEMS includes two types of multiprocess support: Symmetric Multiprocessing (SMP) and distributed multiprocessing. SMP is supported on a subset of supported architectures including ARM, AArch64, PowerPC, RISC-V, and SPARC. RTEMS distributed multiprocessor support assumes each node in the distributed system is an independent system with its own CPU, RAM, and copy of RTEMS. A subset of RTEMS APIs support operations on remote nodes in the system. This is capable of handling either homogeneous or heterogeneous systems. The kernel automatically compensates for architectural differences (byte swapping, etc.) between processors.

This document details the Classic API which was originally based on the Real-Time Executive Interface Definition (RTEID) and Open Real-Time Kernel Interface Definition (ORKID). Neither of those efforts reached the status of a published standard but influenced the APIs available from multiple real-time operating systems.

CHAPTER

**TWO**

# <span id="page-34-0"></span>OVERVIEW

# <span id="page-35-1"></span><span id="page-35-0"></span>2.1 Introduction

RTEMS, Real-Time Executive for Multiprocessor Systems, is a real-time executive (kernel) which provides a high performance environment for embedded military applications including the following features:

- multitasking capabilities
- homogeneous and heterogeneous multiprocessor systems
- event-driven, priority-based, preemptive scheduling
- optional rate monotonic scheduling
- intertask communication and synchronization
- priority inheritance
- responsive interrupt management
- dynamic memory allocation
- high level of user configurability

This manual describes the usage of RTEMS for applications written in the C programming language. Those implementation details that are processor dependent are provided in the Applications Supplement documents. A supplement document which addresses specific architectural issues that affect RTEMS is provided for each processor type that is supported.

# <span id="page-36-1"></span><span id="page-36-0"></span>2.2 Real-time Application Systems

Real-time application systems are a special class of computer applications. They have a complex set of characteristics that distinguish them from other software problems. Generally, they must adhere to more rigorous requirements. The correctness of the system depends not only on the results of computations, but also on the time at which the results are produced. The most important and complex characteristic of real-time application systems is that they must receive and respond to a set of external stimuli within rigid and critical time constraints referred to as deadlines. Systems can be buried by an avalanche of interdependent, asynchronous or cyclical event streams.

Deadlines can be further characterized as either hard or soft based upon the value of the results when produced after the deadline has passed. A deadline is hard if the results have no value or if their use will result in a catastrophic event. In contrast, results which are produced after a soft deadline may have some value.

Another distinguishing requirement of real-time application systems is the ability to coordinate or manage a large number of concurrent activities. Since software is a synchronous entity, this presents special problems. One instruction follows another in a repeating synchronous cycle. Even though mechanisms have been developed to allow for the processing of external asynchronous events, the software design efforts required to process and manage these events and tasks are growing more complicated.

The design process is complicated further by spreading this activity over a set of processors instead of a single processor. The challenges associated with designing and building real-time application systems become very complex when multiple processors are involved. New requirements such as interprocessor communication channels and global resources that must be shared between competing processors are introduced. The ramifications of multiple processors complicate each and every characteristic of a real-time system.

# REAL-TIME EXECUTIVE

<span id="page-38-1"></span><span id="page-38-0"></span>Fortunately, real-time operating systems or real-time executives serve as a cornerstone on which to build the application system. A real-time multitasking executive allows an application to be cast into a set of logical, autonomous processes or tasks which become quite manageable. Each task is internally synchronous, but different tasks execute independently, resulting in an asynchronous processing stream. Tasks can be dynamically paused for many reasons resulting in a different task being allowed to execute for a period of time. The executive also provides an interface to other system components such as interrupt handlers and device drivers. System components may request the executive to allocate and coordinate resources, and to wait for and trigger synchronizing conditions. The executive system calls effectively extend the CPU instruction set to support efficient multitasking. By causing tasks to travel through well-defined state transitions, system calls permit an application to demand-switch between tasks in response to real-time events.

By proper grouping of responses to stimuli into separate tasks, a system can now asynchronously switch between independent streams of execution, directly responding to external stimuli as they occur. This allows the system design to meet critical performance specifications which are typically measured by guaranteed response time and transaction throughput. The multiprocessor extensions of RTEMS provide the features necessary to manage the extra requirements introduced by a system distributed across several processors. It removes the physical barriers of processor boundaries from the world of the system designer, enabling more critical aspects of the system to receive the required attention. Such a system, based on an efficient real-time, multiprocessor executive, is a more realistic model of the outside world or environment for which it is designed. As a result, the system will always be more logical, efficient, and reliable.

By using the directives provided by RTEMS, the real-time applications developer is freed from the problem of controlling and synchronizing multiple tasks and processors. In addition, one need not develop, test, debug, and document routines to manage memory, pass messages, or provide mutual exclusion. The developer is then able to concentrate solely on the application. By using standard software components, the time and cost required to develop sophisticated real-time applications is significantly reduced.

# <span id="page-39-1"></span><span id="page-39-0"></span>3.1 RTEMS Application Architecture

One important design goal of RTEMS was to provide a bridge between two critical layers of typical real-time systems. As shown in the following figure, RTEMS serves as a buffer between the project dependent application code and the target hardware. Most hardware dependencies for real-time applications can be localized to the low level device drivers.

![](_page_39_Picture_4.jpeg)

The RTEMS I/O interface manager provides an efficient tool for incorporating these hardware dependencies into the system while simultaneously providing a general mechanism to the application code that accesses them. A well designed real-time system can benefit from this architecture by building a rich library of standard application components which can be used repeatedly in other real-time projects.

# <span id="page-40-0"></span>3.2 RTEMS Internal Architecture

RTEMS can be viewed as a set of layered components that work in harmony to provide a set of services to a real-time application system. The executive interface presented to the application is formed by grouping directives into logical sets called resource managers. Functions utilized by multiple managers such as scheduling, dispatching, and object management are provided in the executive core. The executive core depends on a small set of CPU dependent routines. Together these components provide a powerful run time environment that promotes the development of efficient real-time application systems. The following figure illustrates this organization:

![](_page_40_Picture_4.jpeg)

Subsequent chapters present a detailed description of the capabilities provided by each of the following RTEMS managers:

- initialization
- task
- interrupt
- clock
- timer
- semaphore
- message
- event
- signal
- partition
- region
- dual ported memory
- I/O
- fatal error
- rate monotonic
- user extensions

â€¢ multiprocessing

# <span id="page-42-0"></span>3.3 User Customization and Extensibility

As thirty-two bit microprocessors have decreased in cost, they have become increasingly common in a variety of embedded systems. A wide range of custom and general-purpose processor boards are based on various thirty-two bit processors. RTEMS was designed to make no assumptions concerning the characteristics of individual microprocessor families or of specific support hardware. In addition, RTEMS allows the system developer a high degree of freedom in customizing and extending its features.

RTEMS assumes the existence of a supported microprocessor and sufficient memory for both RTEMS and the real-time application. Board dependent components such as clocks, interrupt controllers, or I/O devices can be easily integrated with RTEMS. The customization and extensibility features allow RTEMS to efficiently support as many environments as possible.

# <span id="page-43-0"></span>3.4 Portability

The issue of portability was the major factor in the creation of RTEMS. Since RTEMS is designed to isolate the hardware dependencies in the specific board support packages, the real-time application should be easily ported to any other processor. The use of RTEMS allows the development of real-time applications which can be completely independent of a particular microprocessor architecture.

# <span id="page-44-0"></span>3.5 Memory Requirements

Since memory is a critical resource in many real-time embedded systems, RTEMS was specifically designed to automatically leave out all services that are not required from the run-time environment. Features such as networking, various fileystems, and many other features are completely optional. This allows the application designer the flexibility to tailor RTEMS to most efficiently meet system requirements while still satisfying even the most stringent memory constraints. As a result, the size of the RTEMS executive is application dependent.

RTEMS requires RAM to manage each instance of an RTEMS object that is created. Thus the more RTEMS objects an application needs, the more memory that must be reserved. See *[Con](#page-584-0)[figuring a System](#page-584-0)* (page 557).

RTEMS utilizes memory for both code and data space. Although RTEMS' data space must be in RAM, its code space can be located in either ROM or RAM.

# <span id="page-45-0"></span>3.6 Audience

This manual was written for experienced real-time software developers. Although some background is provided, it is assumed that the reader is familiar with the concepts of task management as well as intertask communication and synchronization. Since directives, user related data structures, and examples are presented in C, a basic understanding of the C programming language is required to fully understand the material presented. However, because of the similarity of the Ada and C RTEMS implementations, users will find that the use and behavior of the two implementations is very similar. A working knowledge of the target processor is helpful in understanding some of RTEMS' features. A thorough understanding of the executive cannot be obtained without studying the entire manual because many of RTEMS' concepts and features are interrelated. Experienced RTEMS users will find that the manual organization facilitates its use as a reference document.

# <span id="page-46-0"></span>3.7 Conventions

The following conventions are used in this manual:

- Significant words or phrases as well as all directive names are printed in bold type.
- Items in bold capital letters are constants defined by RTEMS. Each language interface provided by RTEMS includes a file containing the standard set of constants, data types, and structure definitions which can be incorporated into the user application.
- A number of type definitions are provided by RTEMS and can be found in rtems.h.
- The characters "0x" preceding a number indicates that the number is in hexadecimal format. Any other numbers are assumed to be in decimal format.

3.7. Conventions 19

# <span id="page-47-0"></span>3.8 Manual Organization

This first chapter has presented the introductory and background material for the RTEMS executive. The remaining chapters of this manual present a detailed description of RTEMS and the environment, including run time behavior, it creates for the user.

A chapter is dedicated to each manager and provides a detailed discussion of each RTEMS manager and the directives which it provides. The presentation format for each directive includes the following sections:

- Calling sequence
- Directive status codes
- Description
- Notes

The following provides an overview of the remainder of this manual:

#### **Chapter 3:**

Key Concepts: presents an introduction to the ideas which are common across multiple RTEMS managers.

## **Chapter 4:**

RTEMS Data Types: describes the fundamental data types shared by the services in the RTEMS Classic API.

## **Chapter 5:**

Scheduling Concepts: details the various RTEMS scheduling algorithms and task state transitions.

#### **Chapter 6:**

Initialization Manager: describes the functionality and directives provided by the Initialization Manager.

## **Chapter 7:**

Task Manager: describes the functionality and directives provided by the Task Manager.

#### **Chapter 8:**

Interrupt Manager: describes the functionality and directives provided by the Interrupt Manager.

#### **Chapter 9:**

Clock Manager: describes the functionality and directives provided by the Clock Manager.

#### **Chapter 10:**

Timer Manager: describes the functionality and directives provided by the Timer Manager.

## **Chapter 11:**

Rate Monotonic Manager: describes the functionality and directives provided by the Rate Monotonic Manager.

#### **Chapter 12:**

Semaphore Manager: describes the functionality and directives provided by the Semaphore Manager.

#### **Chapter 13:**

Barrier Manager: describes the functionality and directives provided by the Barrier Manager.

#### **Chapter 14:**

Message Manager: describes the functionality and directives provided by the Message Manager.

## **Chapter 15:**

Event Manager: describes the functionality and directives provided by the Event Manager.

#### **Chapter 16:**

Signal Manager: describes the functionality and directives provided by the Signal Manager.

## **Chapter 17:**

Partition Manager: describes the functionality and directives provided by the Partition Manager.

#### **Chapter 18:**

Region Manager: describes the functionality and directives provided by the Region Manager.

#### **Chapter 19:**

Dual-Ported Memory Manager: describes the functionality and directives provided by the Dual-Ported Memory Manager.

## **Chapter 20:**

I/O Manager: describes the functionality and directives provided by the I/O Manager.

## **Chapter 21:**

Fatal Error Manager: describes the functionality and directives provided by the Fatal Error Manager.

#### **Chapter 22:**

Board Support Packages: defines the functionality required of user-supplied board support packages.

#### **Chapter 23:**

User Extensions: shows the user how to extend RTEMS to incorporate custom features.

#### **Chapter 24:**

Configuring a System: details the process by which one tailors RTEMS for a particular singleprocessor or multiprocessor application.

#### **Chapter 25:**

Self-Contained Objects: contains information about objects like threads, mutexes and semaphores.

## **Chapter 26:**

Multiprocessing Manager: presents a conceptual overview of the multiprocessing capabilities provided by RTEMS as well as describing the Multiprocessing Communications Interface Layer and Multiprocessing Manager directives.

#### **Chapter 27:**

Symmetric Multiprocessing (SMP): information regarding the SMP features.

#### **Chapter 28:**

PCI Library: information about using the PCI bus in RTEMS.

#### **Chapter 29:**

Stack Bounds Checker: presents the capabilities of the RTEMS task stack checker which can report stack usage as well as detect bounds violations.

#### **Chapter 30:**

CPU Usage Statistics: presents the capabilities of the CPU Usage statistics gathered on a per task basis along with the mechanisms for reporting and resetting the statistics.

#### **Chapter 31:**

Object Services: presents a collection of helper services useful when manipulating RTEMS objects. These include methods to assist in obtaining an object's name in printable form. Additional services are provided to decompose an object Id and determine which API and object class it belongs to.

## **Chapter 32:**

Chains: presents the methods provided to build, iterate and manipulate doubly-linked chains. This manager makes the chain implementation used internally by RTEMS to user space applications.

#### **Chapter 33:**

Red-Black Trees: information about how to use the Red-Black Tree API.

### **Chapter 34:**

Timespec Helpers: presents a set of helper services useful when manipulating POSIX struct timespec instances.

#### **Chapter 35:**

Constant Bandwidth Server Scheduler API.

## **Chapter 36:**

Ada Support: information about Ada programming language support.

#### **Chapter 37:**

Directive Status Codes: provides a definition of each of the directive status codes referenced in this manual.

## **Chapter 38:**

Linker Sets: information about linker set features.

#### **Chapter 39:**

Example Application: provides a template for simple RTEMS applications.

#### **Chapter 40:**

Glossary: defines terms used throughout this manual.

## **Chapter 41:**

References: References.

#### **Chapter 42:**

Index: Index.

CHAPTER

**FOUR**

# <span id="page-50-0"></span>KEY CONCEPTS

# <span id="page-51-1"></span><span id="page-51-0"></span>4.1 Introduction

The facilities provided by RTEMS are built upon a foundation of very powerful concepts. These concepts must be understood before the application developer can efficiently utilize RTEMS. The purpose of this chapter is to familiarize one with these concepts.

# <span id="page-52-2"></span><span id="page-52-0"></span>4.2 Objects

RTEMS provides directives which can be used to dynamically create, delete, and manipulate a set of predefined object types. These types include tasks, message queues, semaphores, memory regions, memory partitions, timers, ports, and rate monotonic periods. The object-oriented nature of RTEMS encourages the creation of modular applications built upon re-usable "building block" routines.

All objects are created on the local node as required by the application and have an RTEMS assigned ID. All objects have a user-assigned name. Although a relationship exists between an object's name and its RTEMS assigned ID, the name and ID are not identical. Object names are completely arbitrary and selected by the user as a meaningful "tag" which may commonly reflect the object's use in the application. Conversely, object IDs are designed to facilitate efficient object manipulation by the executive.

## <span id="page-52-1"></span>4.2.1 Object Names

An object name is an unsigned thirty-two bit entity associated with the object by the user. The data type rtems\_name is used to store object names.

Although not required by RTEMS, object names are often composed of four ASCII characters which help identify that object. For example, a task which causes a light to blink might be called "LITE". The rtems\_build\_name routine is provided to build an object name from four ASCII characters. The following example illustrates this:

```
1 rtems_name my_name;
2 my_name = rtems_build_name( 'L', 'I', 'T', 'E' );
```

However, it is not required that the application use ASCII characters to build object names. For example, if an application requires one-hundred tasks, it would be difficult to assign meaningful ASCII names to each task. A more convenient approach would be to name them the binary values one through one-hundred, respectively.

RTEMS provides a helper routine, rtems\_object\_get\_name, which can be used to obtain the name of any RTEMS object using just its ID. This routine attempts to convert the name into a printable string.

The following example illustrates the use of this method to print an object name:

```
1 #include <rtems.h>
2 #include <rtems/bspIo.h>
3 void print_name(rtems_id id)
4 {
5 char buffer[10]; /* name assumed to be 10 characters or less */
6 char *result;
7 result = rtems_object_get_name( id, sizeof(buffer), buffer );
8 printk( "ID=0x%08x name=%s\n", id, ((result) ? result : "no name") );
9 }
```

4.2. Objects 25

## <span id="page-53-3"></span><span id="page-53-0"></span>4.2.2 Object Ids

An object id is a unique 32-bit unsigned integer value which uniquely identifies an object instance. object ids are passed as arguments to many directives in rtems and rtems translates the id to an internal object pointer. the efficient manipulation of object ids is critical to the performance of some rtems services.

There are multiple directives with names of the form rtems\_@CLASS@\_ident that take a name as argument and return the associated id if the name is found. The following is the set of name to id services: which can look up an object

- rtems\_extension\_ident()
- rtems\_barrier\_ident()
- rtems\_port\_ident()
- rtems\_message\_queue\_ident()
- rtems\_partition\_ident()
- rtems\_region\_ident()
- rtems\_semaphore\_ident()
- rtems\_task\_ident()
- rtems\_timer\_ident()

## <span id="page-53-1"></span>4.2.3 Local and Global Scope

RTEMS supports uniprocessing, distributed multiprocessing, and Symmetric Multiprocessing (SMP) configurations. A uniprocessor system includes only a single processor in a single node. Distributed multiprocessor systems include multiple nodes, each of which is a single processor and is usually referred to as just multiprocessor mode for historical reasons. SMP systems consist of multiple processors cores in a single node.

In distributed multiprocessing configurations, there are multiple nodes in the system and object instances may be visible on just the creating node or to all nodes. If visible only to the creating node, this is referred to as **local scope** and corresponds to the RTEMS\_LOCAL attribute setting which is the default. If RTEMS GLOBAL is specified as part of the object attributes, then the object instance has **global scope** and the object id can be used anywhere in the system to identify that object instance.

In uniprocessing and SMP configurations, there is only one node in the system and object instances are locally scoped to that node. Any attempt to create with the RTEMS\_GLOBAL attribute is an error.

## <span id="page-53-2"></span>4.2.3.1 Object ID Format

The thirty-two bit format for an object ID is composed of four parts: API, object class, node, and index. The data type rtems\_id is used to store object IDs.

![](_page_53_Figure_20.jpeg)

(continued from previous page)

```
5 | | | | |
6 +---------+-------+--------------+-------------------------------+
```

The most significant five bits are the object class. The next three bits indicate the API to which the object class belongs. The next eight bits (16-23) are the number of the node on which this object was created. The node number is always one (1) in a single processor system. The least significant sixteen bits form an identifier within a particular object type. This identifier, called the object index, ranges in value from 1 to the maximum number of objects configured for this object type.

None of the fields in an object id may be zero except for the special case of RTEMS\_SELF to indicate the currently running thread.

## <span id="page-54-0"></span>4.2.4 Object ID Description

The components of an object ID make it possible to quickly locate any object in even the most complicated multiprocessor system. Object ID's are associated with an object by RTEMS when the object is created and the corresponding ID is returned by the appropriate object create directive. The object ID is required as input to all directives involving objects, except those which create an object or obtain the ID of an object.

The object identification directives can be used to dynamically obtain a particular object's ID given its name. This mapping is accomplished by searching the name table associated with this object type. If the name is non-unique, then the ID associated with the first occurrence of the name will be returned to the application. Since object IDs are returned when the object is created, the object identification directives are not necessary in a properly designed single processor application.

In addition, services are provided to portably examine the subcomponents of an RTEMS ID. These services are described in detail later in this manual but are prototyped as follows:

```
1 Objects_APIs rtems_object_id_get_api( rtems_id );
2 uint32_t rtems_object_id_get_class( rtems_id );
3 uint32_t rtems_object_id_get_node( rtems_id );
4 uint16_t rtems_object_id_get_index( rtems_id );
```

An object control block is a data structure defined by RTEMS which contains the information necessary to manage a particular object type. For efficiency reasons, the format of each object type's control block is different. However, many of the fields are similar in function. The number of each type of control block is application dependent and determined by the values specified in the user's Configuration Table. An object control block is allocated at object create time and freed when the object is deleted. With the exception of user extension routines, object control blocks are not directly manipulated by user applications.

4.2. Objects 27

# <span id="page-55-1"></span><span id="page-55-0"></span>4.3 Communication and Synchronization

In real-time multitasking applications, the ability for cooperating execution threads to communicate and synchronize with each other is imperative. A real-time executive should provide an application with the following capabilities:

- Data transfer between cooperating tasks
- Data transfer between tasks and ISRs
- Synchronization of cooperating tasks
- Synchronization of tasks and ISRs

Most RTEMS managers can be used to provide some form of communication and/or synchronization. However, managers dedicated specifically to communication and synchronization provide well established mechanisms which directly map to the application's varying needs. This level of flexibility allows the application designer to match the features of a particular manager with the complexity of communication and synchronization required. The following managers were specifically designed for communication and synchronization:

- Semaphore
- Message Queue
- Event
- Signal

The semaphore manager supports mutual exclusion involving the synchronization of access to one or more shared user resources. Binary semaphores may utilize the optional priority inheritance algorithm to avoid the problem of priority inversion. The message manager supports both communication and synchronization, while the event manager primarily provides a high performance synchronization mechanism. The signal manager supports only asynchronous communication and is typically used for exception handling.

# <span id="page-56-4"></span><span id="page-56-0"></span>4.4 Locking Protocols

RTEMS supports the four locking protocols

- *[Immediate Ceiling Priority Protocol \(ICPP\)](#page-56-2)* (page 29),
- *[Priority Inheritance Protocol](#page-56-3)* (page 29),
- *[Multiprocessor Resource Sharing Protocol \(MrsP\)](#page-57-0)* (page 30), and
- *[O\(m\) Independence-Preserving Protocol \(OMIP\)](#page-57-1)* (page 30)

for synchronization objects providing mutual-exclusion (mutex). The OMIP is only available in SMP configurations and replaces the priority inheritance protocol in this case. One aim of the locking protocols is to avoid priority inversion.

Since RTEMS 5.1, priority updates due to the locking protocols take place immediately and are propagated recursively. The mutex owner and wait for mutex relationships define a directed acyclic graph (DAG). The run-time of the mutex obtain, release and timeout operations depend on the complexity of this resource dependency graph.

## <span id="page-56-1"></span>4.4.1 Priority Inversion

Priority inversion is a form of indefinite postponement which is common in multitasking, preemptive executives with shared resources. Priority inversion occurs when a high priority tasks requests access to shared resource which is currently allocated to a low priority task. The high priority task must block until the low priority task releases the resource. This problem is exacerbated when the low priority task is prevented from executing by one or more medium priority tasks. Because the low priority task is not executing, it cannot complete its interaction with the resource and release that resource. The high priority task is effectively prevented from executing by lower priority tasks.

## <span id="page-56-2"></span>4.4.2 Immediate Ceiling Priority Protocol (ICPP)

Each mutex using the Immediate Ceiling Priority Protocol (ICPP) has a ceiling priority. The priority of the mutex owner is immediately raised to the ceiling priority of the mutex. In case the thread owning the mutex releases the mutex, then the normal priority of the thread is restored. This locking protocol is beneficial for schedulability analysis, see also [\[BW01\]](#page-1082-1).

This protocol avoids the possibility of changing the priority of the mutex owner multiple times since the ceiling priority must be set to the one of highest priority thread which will ever attempt to acquire that mutex. This requires an overall knowledge of the application as a whole. The need to identify the highest priority thread which will attempt to obtain a particular mutex can be a difficult task in a large, complicated system. Although the priority ceiling protocol is more efficient than the priority inheritance protocol with respect to the maximum number of thread priority changes which may occur while a thread owns a particular mutex, the priority inheritance protocol is more forgiving in that it does not require this apriori information.

## <span id="page-56-3"></span>4.4.3 Priority Inheritance Protocol

The priority of the mutex owner is raised to the highest priority of all threads that currently wait for ownership of this mutex [\[SRL90\]](#page-1083-1). Since RTEMS 5.1, priority updates due to the priority inheritance protocol take place immediately and are propagated recursively. This means the priority inheritance is transitive since RTEMS 5.1. If a task A owning a priority inheritance mutex blocks on another priority inheritance mutex, then the owner of this mutex inherits the priority of the task A.

## <span id="page-57-2"></span><span id="page-57-0"></span>4.4.4 Multiprocessor Resource Sharing Protocol (MrsP)

The Multiprocessor Resource Sharing Protocol (MrsP) is a generalization of the priority ceiling protocol to clustered scheduling [\[BW13\]](#page-1082-2). One of the design goals of MrsP is to enable an effective schedulability analysis using the sporadic task model. Each mutex using the MrsP has a ceiling priority for each scheduler instance. The priority of the mutex owner is immediately raised to the ceiling priority of the mutex defined for its home scheduler instance. In case the thread owning the mutex releases the mutex, then the normal priority of the thread is restored. Threads that wait for mutex ownership are not blocked with respect to the scheduler and instead perform a busy wait. The MrsP uses temporary thread migrations to foreign scheduler instances in case of a preemption of the mutex owner. This locking protocol is available since RTEMS 4.11. It was re-implemented in RTEMS 5.1 to overcome some shortcomings of the original implementation [\[CBHM15\]](#page-1082-3).

## <span id="page-57-1"></span>4.4.5 O(m) Independence-Preserving Protocol (OMIP)

The () Independence-Preserving Protocol (OMIP) is a generalization of the priority inheritance protocol to clustered scheduling which avoids the non-preemptive sections present with *[priority boosting](#page-1071-0)* [\[Bra13\]](#page-1082-4). The denotes the number of processors in the system. Similar to the uniprocessor priority inheritance protocol, the OMIP mutexes do not need any external configuration data, e.g. a ceiling priority. This makes them a good choice for general purpose libraries that need internal locking. The complex part of the implementation is contained in the thread queues and shared with the MrsP support. This locking protocol is available since RTEMS 5.1.

# <span id="page-58-1"></span><span id="page-58-0"></span>4.5 Thread Queues

In case more than one *[thread](#page-1077-0)* may wait on a synchronization object, e.g. a semaphore or a message queue, then the waiting threads are added to a data structure called the thread queue. Thread queues are named task wait queues in the Classic API. There are two thread queuing disciplines available which define the order of the threads on a particular thread queue. Threads can wait in FIFO or priority order.

In uniprocessor configurations, the priority queuing discipline just orders the threads according to their current priority and in FIFO order in case of equal priorities. However, in SMP configurations, the situation is a bit more difficult due to the support for clustered scheduling. It makes no sense to compare the priority values of two different scheduler instances. Thus, it is impossible to simply use one plain priority queue for threads of different clusters. Two levels of queues can be used as one way to solve the problem. The top-level queue provides FIFO ordering and contains priority queues. Each priority queue is associated with a scheduler instance and contains only threads of this scheduler instance. Threads are enqueued in the priority queues corresponding to their scheduler instances. To dequeue a thread, the highest priority thread of the first priority queue is selected. Once this is done, the first priority queue is appended to the top-level FIFO queue. This guarantees fairness with respect to the scheduler instances.

Such a two-level queue needs a considerable amount of memory if fast enqueue and dequeue operations are desired. Providing this storage per thread queue would waste a lot of memory in typical applications. Instead, each thread has a queue attached which resides in a dedicated memory space independent of other memory used for the thread (this approach was borrowed from FreeBSD). In case a thread needs to block, there are two options

- the object already has a queue, then the thread enqueues itself to this already present queue and the queue of the thread is added to a list of free queues for this object, or
- otherwise, the queue of the thread is given to the object and the thread enqueues itself to this queue.

In case the thread is dequeued, there are two options

- the thread is the last thread in the queue, then it removes this queue from the object and reclaims it for its own purpose, or
- otherwise, the thread removes one queue from the free list of the object and reclaims it for its own purpose.

Since there are usually more objects than threads, this actually reduces the memory demands. In addition the objects only contain a pointer to the queue structure. This helps to hide implementation details. Inter-cluster priority queues are available since RTEMS 5.1.

A doubly-linked list (chain) is used to implement the FIFO queues yielding a (1) worst-case time complexity for enqueue and dequeue operations.

A red-black tree is used to implement the priority queues yielding a (()) worst-case time complexity for enqueue and dequeue operations with being the count of threads already on the queue.

# <span id="page-59-1"></span><span id="page-59-0"></span>4.6 Time

The development of responsive real-time applications requires an understanding of how RTEMS maintains and supports time-related operations. The basic unit of time in RTEMS is known as a clock tick or simply tick. The tick interval is defined by the application configuration option *[CONFIGURE\\_MICROSECONDS\\_PER\\_TICK](#page-612-0)* (page 585). The tick interval defines the basic resolution of all interval and calendar time operations. Obviously, the directives which use intervals or wall time cannot operate without some external mechanism which provides a periodic clock tick. This clock tick is provided by the clock driver. The tick precision and stability depends on the clock driver and interrupt latency. Most clock drivers provide a timecounter to measure the time with a higher resolution than the tick.

By tracking time in units of ticks, RTEMS is capable of supporting interval timing functions such as task delays, timeouts, timeslicing, the delayed execution of timer service routines, and the rate monotonic scheduling of tasks. An interval is defined as a number of ticks relative to the current time. For example, when a task delays for an interval of ten ticks, it is implied that the task will not execute until ten clock ticks have occurred. All intervals are specified using data type rtems\_interval.

A characteristic of interval timing is that the actual interval period may be a fraction of a tick less than the interval requested. This occurs because the time at which the delay timer is set up occurs at some time between two clock ticks. Therefore, the first countdown tick occurs in less than the complete time interval for a tick. This can be a problem if the tick resolution is large.

The rate monotonic scheduling algorithm is a hard real-time scheduling methodology. This methodology provides rules which allows one to guarantee that a set of independent periodic tasks will always meet their deadlines even under transient overload conditions. The rate monotonic manager provides directives built upon the Clock Manager's interval timer support routines.

Interval timing is not sufficient for the many applications which require that time be kept in wall time or true calendar form. Consequently, RTEMS maintains the current date and time. This allows selected time operations to be scheduled at an actual calendar date and time. For example, a task could request to delay until midnight on New Year's Eve before lowering the ball at Times Square. The data type rtems\_time\_of\_day is used to specify calendar time in RTEMS services. See *[Time and Date Data Structures](#page-265-2)* (page 238).

# <span id="page-60-1"></span><span id="page-60-0"></span>4.7 Timer and Timeouts

Timer and timeout services are a standard component of an operating system. The use cases fall roughly into two categories:

- Timeouts used to detect if some operations need more time than expected. Since the unexpected happens hopefully rarely, timeout timers are usually removed before they expire. The critical operations are insert and removal. For example, they are important for the performance of a network stack.
- Timers used to carry out some work in the future. They usually expire and need a high resolution. An example use case is a time driven scheduler, e.g. rate-monotonic or EDF.

In RTEMS versions prior to 5.1 the timer and timeout support was implemented by means of delta chains. This implementation was unfit for SMP systems due to several reasons. The new implementation present since RTEMS 5.1 uses a red-black tree with the expiration time as the key. This leads to (()) worst-case insert and removal operations for active timer or timeouts. Each processor provides its own timer and timeout service point so that it scales well with the processor count of the system. For each operation it is sufficient to acquire and release a dedicated SMP lock only once. The drawback is that a 64-bit integer type is required internally for the intervals to avoid a potential overflow of the key values.

An alternative to the red-black tree based implementation would be the use of a timer wheel based algorithm [\[VL87\]](#page-1084-1) which is used in Linux and FreeBSD [\[VC95\]](#page-1083-2) for example. A timer wheel based algorithm offers (1) worst-case time complexity for insert and removal operations. The drawback is that the run-time of the clock tick procedure is unpredictable due to the use of a hash table or cascading.

The red-black tree approach was selected for RTEMS, since it offers a more predictable run-time behaviour. However, this sacrifices the constant insert and removal operations offered by the timer wheel algorithms. See also [\[GN06\]](#page-1083-3). The implementation can re-use the red-black tree support already used in other areas, e.g. for the thread priority queues. Less code is a good thing for size, testing and verification.

# <span id="page-61-1"></span><span id="page-61-0"></span>4.8 Memory Management

RTEMS memory management facilities can be grouped into two classes: dynamic memory allocation and address translation. Dynamic memory allocation is required by applications whose memory requirements vary through the application's course of execution. Address translation is needed by applications which share memory with another CPU or an intelligent Input/Output processor. The following RTEMS managers provide facilities to manage memory:

- Region
- Partition
- Dual Ported Memory

RTEMS memory management features allow an application to create simple memory pools of fixed size buffers and/or more complex memory pools of variable size segments. The partition manager provides directives to manage and maintain pools of fixed size entities such as resource control blocks. Alternatively, the region manager provides a more general purpose memory allocation scheme that supports variable size blocks of memory which are dynamically obtained and freed by the application. The dual-ported memory manager provides executive support for address translation between internal and external dual-ported RAM address space.

CHAPTER

**FIVE**

# <span id="page-62-0"></span>RTEMS DATA TYPES

# <span id="page-63-0"></span>5.1 Introduction

This chapter contains a complete list of the RTEMS primitive data types in alphabetical order. This is intended to be an overview and the user is encouraged to look at the appropriate chapters in the manual for more information about the usage of the various data types.

# <span id="page-64-5"></span><span id="page-64-0"></span>5.2 List of Data Types

The following is a complete list of the RTEMS primitive data types in alphabetical order:

# <span id="page-64-1"></span>5.2.1 BSP\_output\_char\_function\_type

Polled character output functions shall have this type.

## <span id="page-64-2"></span>5.2.2 BSP\_polling\_getchar\_function\_type

Polled character input functions shall have this type.

## <span id="page-64-3"></span>5.2.3 Timer\_Classes

The timer class indicates how the timer was most recently fired.

## ENUMERATORS:

#### **TIMER\_DORMANT**

This timer class indicates that the timer was never in use.

#### **TIMER\_INTERVAL**

This timer class indicates that the timer is currently in use as an interval timer which will fire in the context of the clock tick *[ISR](#page-1067-0)*.

## **TIMER\_INTERVAL\_ON\_TASK**

This timer class indicates that the timer is currently in use as an interval timer which will fire in the context of the Timer Server task.

#### **TIMER\_TIME\_OF\_DAY**

This timer class indicates that the timer is currently in use as an time of day timer which will fire in the context of the clock tick *[ISR](#page-1067-0)*.

#### **TIMER\_TIME\_OF\_DAY\_ON\_TASK**

This timer class indicates that the timer is currently in use as an time of day timer which will fire in the context of the Timer Server task.

## <span id="page-64-4"></span>5.2.4 rtems\_api\_configuration\_table

This structure contains a summary of the Classic API configuration.

#### MEMBERS:

#### **maximum\_tasks**

This member contains the maximum number of Classic API Tasks configured for this application. See *[CONFIGURE\\_MAXIMUM\\_TASKS](#page-650-0)* (page 623).

#### **notepads\_enabled**

This member is true, if the Classic API Notepads are enabled, otherwise it is false.

#### **maximum\_timers**

This member contains the maximum number of Classic API Timers configured for this application. See *[CONFIGURE\\_MAXIMUM\\_TIMERS](#page-651-0)* (page 624).

#### **maximum\_semaphores**

This member contains the maximum number of Classic API Semaphores configured for this application. See *[CONFIGURE\\_MAXIMUM\\_SEMAPHORES](#page-649-0)* (page 622).

#### <span id="page-65-3"></span>**maximum\_message\_queues**

This member contains the maximum number of Classic API Message Queues configured for this application. See *[CONFIGURE\\_MAXIMUM\\_MESSAGE\\_QUEUES](#page-644-0)* (page 617).

#### **maximum\_partitions**

This member contains the maximum number of Classic API Partitions configured for this application. See *[CONFIGURE\\_MAXIMUM\\_PARTITIONS](#page-645-0)* (page 618).

#### **maximum\_regions**

This member contains the maximum number of Classic API Regions configured for this application. See *[CONFIGURE\\_MAXIMUM\\_REGIONS](#page-648-0)* (page 621).

#### **maximum\_ports**

This member contains the maximum number of Classic API Dual-Ported Memories configured for this application. See *[CONFIGURE\\_MAXIMUM\\_PORTS](#page-647-0)* (page 620).

#### **maximum\_periods**

This member contains the maximum number of Classic API Rate Monotonic Periods configured for this application. See *[CONFIGURE\\_MAXIMUM\\_PERIODS](#page-646-0)* (page 619).

## **maximum\_barriers**

This member contains the maximum number of Classic API Barriers configured for this application. See *[CONFIGURE\\_MAXIMUM\\_BARRIERS](#page-643-0)* (page 616).

### **number\_of\_initialization\_tasks**

This member contains the number of Classic API Initialization Tasks configured for this application. See *[CONFIGURE\\_RTEMS\\_INIT\\_TASKS\\_TABLE](#page-663-0)* (page 636).

## **User\_initialization\_tasks\_table**

This member contains the pointer to Classic API Initialization Tasks Table of this application. See *[CONFIGURE\\_RTEMS\\_INIT\\_TASKS\\_TABLE](#page-663-0)* (page 636).

#### DESCRIPTION:

Use *[rtems\\_configuration\\_get\\_rtems\\_api\\_configuration\(\)](#page-807-0)* (page 780) to get the configuration table.

## <span id="page-65-0"></span>5.2.5 rtems\_asr

This type defines the return type of routines which are used to process asynchronous signals.

## NOTES:

This type can be used to document asynchronous signal routines in the source code.

## <span id="page-65-1"></span>5.2.6 rtems\_asr\_entry

This type defines the prototype of routines which are used to process asynchronous signals.

## <span id="page-65-2"></span>5.2.7 rtems\_assert\_context

This structure provides the context in which an assertion failed.

#### <span id="page-66-5"></span>MEMBERS:

### **file**

This member provides the file name of the source code file containing the failed assertion statement.

## **line**

This member provides the line number in the source code file containing the failed assertion statement.

## **function**

This member provides the function name containing the failed assertion statement.

## **failed\_expression**

This member provides the expression of the failed assertion statement.

## <span id="page-66-0"></span>5.2.8 rtems\_attribute

This type represents Classic API attributes.

## NOTES:

Attributes are primarily used when creating objects.

## <span id="page-66-1"></span>5.2.9 rtems\_device\_driver

This type shall be used in device driver entry declarations and definitions.

#### NOTES:

Device driver entries return an rtems\_status\_code status code. This type definition helps to document device driver entries in the source code.

## <span id="page-66-2"></span>5.2.10 rtems\_device\_driver\_entry

Device driver entries shall have this type.

## <span id="page-66-3"></span>5.2.11 rtems\_device\_major\_number

This integer type represents the major number of devices.

#### NOTES:

The major number of a device is determined by *[rtems\\_io\\_register\\_driver\(\)](#page-503-0)* (page 476) and the application configuration (see *[CONFIGURE\\_MAXIMUM\\_DRIVERS](#page-640-0)* (page 613)) .

## <span id="page-66-4"></span>5.2.12 rtems\_device\_minor\_number

This integer type represents the minor number of devices.

## NOTES:

The minor number of devices is managed by the device driver.

## <span id="page-67-5"></span><span id="page-67-0"></span>5.2.13 rtems\_driver\_address\_table

This structure contains the device driver entries.

#### MEMBERS:

## **initialization\_entry**

This member is the device driver initialization entry. This entry is called by *[rtems\\_io\\_initialize\(\)](#page-506-0)* (page 479).

#### **open\_entry**

This member is the device driver open entry. This entry is called by *[rtems\\_io\\_open\(\)](#page-508-0)* (page 481).

#### **close\_entry**

This member is the device driver close entry. This entry is called by *[rtems\\_io\\_close\(\)](#page-509-0)* (page 482).

#### **read\_entry**

This member is the device driver read entry. This entry is called by *[rtems\\_io\\_read\(\)](#page-510-0)* (page 483).

## **write\_entry**

This member is the device driver write entry. This entry is called by *[rtems\\_io\\_write\(\)](#page-511-0)* (page 484).

#### **control\_entry**

This member is the device driver control entry. This entry is called by *[rtems\\_io\\_control\(\)](#page-512-0)* (page 485).

## DESCRIPTION:

This structure is used to register a device driver via *[rtems\\_io\\_register\\_driver\(\)](#page-503-0)* (page 476).

## <span id="page-67-1"></span>5.2.14 rtems\_event\_set

This integer type represents a bit field which can hold exactly 32 individual events.

## <span id="page-67-2"></span>5.2.15 rtems\_exception\_frame

This structure represents an architecture-dependent exception frame.

## <span id="page-67-3"></span>5.2.16 rtems\_extensions\_table

The extensions table contains a set of extensions which may be registered in the system through the *[CONFIGURE\\_INITIAL\\_EXTENSIONS](#page-602-0)* (page 575) application configuration option or the *[rtems\\_extension\\_create\(\)](#page-579-0)* (page 552) directive.

## <span id="page-67-4"></span>5.2.17 rtems\_fatal\_code

This integer type represents system termination codes.

### <span id="page-68-3"></span>DESCRIPTION:

This integer type is large enough to store a 32-bit integer or a pointer.

#### NOTES:

The interpretation of a system termination code depends on the system termination source, see *[rtems\\_fatal\\_source](#page-68-1)* (page 41).

## <span id="page-68-0"></span>5.2.18 rtems\_fatal\_extension

Fatal extensions are invoked when the system should terminate.

#### PARAMETERS:

#### **source**

This parameter is the system termination source. The source indicates the component which caused the system termination request, see *[rtems\\_fatal\\_source](#page-68-1)* (page 41). The system termination code may provide additional information related to the system termination request.

## **always\_set\_to\_false**

This parameter is a value equal to false.

#### **code**

This parameter is the system termination code. This value must be interpreted with respect to the source.

#### NOTES:

The fatal extensions are invoked in *[extension forward order](#page-1065-0)* and with maskable interrupts disabled.

The fatal extension should be extremely careful with respect to the RTEMS directives it calls. Depending on the system termination source, the system may be in an undefined and corrupt state.

It is recommended to register fatal extensions through *[initial extension sets](#page-1067-1)*, see *[CONFIG-](#page-602-0)[URE\\_INITIAL\\_EXTENSIONS](#page-602-0)* (page 575).

## <span id="page-68-1"></span>5.2.19 rtems\_fatal\_source

This enumeration represents system termination sources.

## NOTES:

The system termination code may provide additional information depending on the system termination source, see *[rtems\\_fatal\\_code](#page-67-4)* (page 40).

## <span id="page-68-2"></span>5.2.20 rtems\_id

This type represents RTEMS object identifiers.

## <span id="page-69-2"></span><span id="page-69-0"></span>5.2.21 rtems\_initialization\_tasks\_table

This structure defines the properties of the Classic API user initialization task.

#### MEMBERS:

#### **name**

This member defines the task name.

#### **stack\_size**

This member defines the task stack size in bytes.

## **initial\_priority**

This member defines the initial task priority.

#### **attribute\_set**

This member defines the attribute set of the task.

#### **entry\_point**

This member defines the entry point of the task.

#### **mode\_set**

This member defines the initial modes of the task.

#### **argument**

This member defines the entry point argument of the task.

## <span id="page-69-1"></span>5.2.22 rtems\_interrupt\_attributes

This structure provides the attributes of an interrupt vector.

#### MEMBERS:

## **is\_maskable**

This member is true, if the interrupt vector is maskable by *[rtems\\_interrupt\\_local\\_disable\(\)](#page-195-0)* (page 168), otherwise it is false. Interrupt vectors which are not maskable by *[rtems\\_interrupt\\_local\\_disable\(\)](#page-195-0)* (page 168) should be used with care since they cannot use most operating system services.

#### **can\_enable**

This member is true, if the interrupt vector can be enabled by *[rtems\\_interrupt\\_vector\\_enable\(\)](#page-221-0)* (page 194), otherwise it is false. When an interrupt vector can be enabled, this means that the enabled state can always be changed from disabled to enabled. For an interrupt vector which can be enabled it follows that it may be enabled.

#### **maybe\_enable**

This member is true, if the interrupt vector may be enabled by *[rtems\\_interrupt\\_vector\\_enable\(\)](#page-221-0)* (page 194), otherwise it is false. When an interrupt vector may be enabled, this means that the enabled state may be changed from disabled to enabled. The requested enabled state change should be checked by *[rtems\\_interrupt\\_vector\\_is\\_enabled\(\)](#page-220-0)* (page 193). Some interrupt vectors may be optionally available and cannot be enabled on a particular *[target](#page-1076-0)*.

## **can\_disable**

This member is true, if the interrupt vector can be disabled by *[rtems\\_interrupt\\_vector\\_disable\(\)](#page-222-0)* (page 195), otherwise it is false. When an interrupt vector can be disabled, this means that the enabled state can be changed from enabled to disabled. For an interrupt vector which can be disabled it follows that it may be disabled.

## **maybe\_disable**

This member is true, if the interrupt vector may be disabled by *[rtems\\_interrupt\\_vector\\_disable\(\)](#page-222-0)* (page 195), otherwise it is false. When an interrupt vector may be disabled, this means that the enabled state may be changed from enabled to disabled. The requested enabled state change should be checked by *[rtems\\_interrupt\\_vector\\_is\\_enabled\(\)](#page-220-0)* (page 193). Some interrupt vectors may be always enabled and cannot be disabled on a particular *[target](#page-1076-0)*.

#### **can\_raise**

This member is true, if the interrupt vector can be raised by *[rtems\\_interrupt\\_raise\(\)](#page-225-0)* (page 198), otherwise it is false.

#### **can\_raise\_on**

This member is true, if the interrupt vector can be raised on a processor by *[rtems\\_interrupt\\_raise\\_on\(\)](#page-226-0)* (page 199), otherwise it is false.

#### **can\_clear**

This member is true, if the interrupt vector can be cleared by *[rtems\\_interrupt\\_clear\(\)](#page-227-0)* (page 200), otherwise it is false.

## **cleared\_by\_acknowledge**

This member is true, if the pending status of the interrupt associated with the interrupt vector is cleared by an interrupt acknowledge from the processor, otherwise it is false.

## **can\_get\_affinity**

This member is true, if the affinity set of the interrupt vector can be obtained by *[rtems\\_interrupt\\_get\\_affinity\(\)](#page-231-0)* (page 204), otherwise it is false.

#### **can\_set\_affinity**

This member is true, if the affinity set of the interrupt vector can be set by *[rtems\\_interrupt\\_set\\_affinity\(\)](#page-232-0)* (page 205), otherwise it is false.

#### **can\_be\_triggered\_by\_message**

This member is true, if the interrupt associated with the interrupt vector can be triggered by a message. Interrupts may be also triggered by signals, *[rtems\\_interrupt\\_raise\(\)](#page-225-0)* (page 198), or *[rtems\\_interrupt\\_raise\\_on\(\)](#page-226-0)* (page 199). Examples for message triggered interrupts are the PCIe MSI/MSI-X and the ARM GICv3 Locality-specific Peripheral Interrupts (LPI).

#### **trigger\_signal**

This member describes the trigger signal of the interrupt associated with the interrupt vector. Interrupts are normally triggered by signals which indicate an interrupt request from a peripheral. Interrupts may be also triggered by messages, *[rtems\\_interrupt\\_raise\(\)](#page-225-0)* (page 198), or *[rtems\\_interrupt\\_raise\\_on\(\)](#page-226-0)* (page 199).

#### **can\_get\_priority**

This member is true, if the priority of the interrupt vector can be obtained by *[rtems\\_interrupt\\_get\\_priority\(\)](#page-228-0)* (page 201), otherwise it is false.

### **can\_set\_priority**

This member is true, if the priority of the interrupt vector can be set by *[rtems\\_interrupt\\_set\\_priority\(\)](#page-229-0)* (page 202), otherwise it is false.

#### **maximum\_priority**

This member represents the maximum priority value of the interrupt vector. By convention, the minimum priority value is zero. Lower priority values shall be associated with a higher importance. The higher the priority value, the less important is the service of the associated <span id="page-71-4"></span>interrupt vector. Where nested interrupts are supported, interrupts with a lower priority value may preempt other interrupts having a higher priority value.

#### DESCRIPTION:

The *[rtems\\_interrupt\\_get\\_attributes\(\)](#page-234-0)* (page 207) directive may be used to obtain the attributes of an interrupt vector.

## <span id="page-71-0"></span>5.2.23 rtems\_interrupt\_entry

This structure represents an interrupt entry.

#### MEMBERS:

Members of the type shall not be accessed directly by the application.

#### NOTES:

This structure shall be treated as an opaque data type from the *[API](#page-1060-1)* point of view. Members shall not be accessed directly. An entry may be initialized by *[RTEMS\\_INTERRUPT\\_ENTRY\\_INITIALIZER\(\)](#page-212-0)* (page 185) or *[rtems\\_interrupt\\_entry\\_initialize\(\)](#page-213-0)* (page 186). It may be installed for an interrupt vector with *[rtems\\_interrupt\\_entry\\_install\(\)](#page-214-0)* (page 187) and removed from an interrupt vector by *[rtems\\_interrupt\\_entry\\_remove\(\)](#page-216-0)* (page 189).

## <span id="page-71-1"></span>5.2.24 rtems\_interrupt\_handler

Interrupt handler routines shall have this type.

## <span id="page-71-2"></span>5.2.25 rtems\_interrupt\_level

This integer type represents interrupt levels.

## <span id="page-71-3"></span>5.2.26 rtems\_interrupt\_lock

This structure represents an ISR lock.

## NOTES:

Lock objects are only needed in some RTEMS build configurations, for example where the SMP support is enabled. The RTEMS\_INTERRUPT\_LOCK\_NEEDS\_OBJECT constant can be used to determine whether a lock object is needed or not. This may help to reduce the memory demands of an application. All lock operations do not use the lock object parameter if lock objects are not needed.

```
1 #include <rtems.h>
2
3 #if RTEMS_INTERRUPT_LOCK_NEEDS_OBJECT
4 rtems_interrupt_lock lock = RTEMS_INTERRUPT_LOCK_INITIALIZER( "name" );
5 #endif
6
7 struct s {
8 #if RTEMS_INTERRUPT_LOCK_NEEDS_OBJECT
```

(continues on next page)

(continued from previous page)

```
9 rtems_interrupt_lock lock;
10 #endif
11 int foobar;
12 };
```

## <span id="page-72-0"></span>5.2.27 rtems\_interrupt\_lock\_context

This structure provides an ISR lock context for acquire and release pairs.

## <span id="page-72-1"></span>5.2.28 rtems\_interrupt\_per\_handler\_routine

Visitor routines invoked by *[rtems\\_interrupt\\_handler\\_iterate\(\)](#page-235-0)* (page 208) shall have this type.

## <span id="page-72-2"></span>5.2.29 rtems\_interrupt\_server\_action

This structure represents an interrupt server action.

## MEMBERS:

Members of the type shall not be accessed directly by the application.

#### NOTES:

This structure shall be treated as an opaque data type from the *[API](#page-1060-1)* point of view. Members shall not be accessed directly.

## <span id="page-72-3"></span>5.2.30 rtems\_interrupt\_server\_config

This structure defines an interrupt server configuration.

#### MEMBERS:

Members of the type shall not be accessed directly by the application.

#### NOTES:

See also *[rtems\\_interrupt\\_server\\_create\(\)](#page-239-0)* (page 212).

## <span id="page-72-4"></span>5.2.31 rtems\_interrupt\_server\_control

This structure represents an interrupt server.

## MEMBERS:

Members of the type shall not be accessed directly by the application.

## NOTES:

This structure shall be treated as an opaque data type from the *[API](#page-1060-1)* point of view. Members shall not be accessed directly. The structure is initialized by *[rtems\\_interrupt\\_server\\_create\(\)](#page-239-0)* (page 212) and maintained by the interrupt server support.

## <span id="page-73-3"></span><span id="page-73-0"></span>5.2.32 rtems\_interrupt\_server\_entry

This structure represents an interrupt server entry.

## MEMBERS:

Members of the type shall not be accessed directly by the application.

## NOTES:

This structure shall be treated as an opaque data type from the *[API](#page-1060-1)* point of view. Members shall not be accessed directly. An entry is initialized by *[rtems\\_interrupt\\_server\\_entry\\_initialize\(\)](#page-251-0)* (page 224) and destroyed by *[rtems\\_interrupt\\_server\\_entry\\_destroy\(\)](#page-254-0)* (page 227). Interrupt server actions can be prepended to the entry by *[rtems\\_interrupt\\_server\\_action\\_prepend\(\)](#page-252-0)* (page 225). The entry is submitted to be serviced by *[rtems\\_interrupt\\_server\\_entry\\_submit\(\)](#page-255-0)* (page 228).

## <span id="page-73-1"></span>5.2.33 rtems\_interrupt\_server\_request

This structure represents an interrupt server request.

#### MEMBERS:

Members of the type shall not be accessed directly by the application.

## NOTES:

This structure shall be treated as an opaque data type from the *[API](#page-1060-1)* point of view. Members shall not be accessed directly. A request is initialized by *[rtems\\_interrupt\\_server\\_request\\_initialize\(\)](#page-257-0)* (page 230) and destroyed by *[rtems\\_interrupt\\_server\\_request\\_destroy\(\)](#page-259-0)* (page 232). The interrupt vector of the request can be set by *[rtems\\_interrupt\\_server\\_request\\_set\\_vector\(\)](#page-258-0)* (page 231). The request is submitted to be serviced by *[rtems\\_interrupt\\_server\\_request\\_submit\(\)](#page-260-0)* (page 233).

## <span id="page-73-2"></span>5.2.34 rtems\_interrupt\_signal\_variant

This enumeration provides interrupt trigger signal variants.

#### ENUMERATORS:

#### **RTEMS\_INTERRUPT\_UNSPECIFIED\_SIGNAL**

This interrupt signal variant indicates that the interrupt trigger signal is unspecified.

#### **RTEMS\_INTERRUPT\_NO\_SIGNAL**

This interrupt signal variant indicates that the interrupt cannot be triggered by a signal.

#### **RTEMS\_INTERRUPT\_SIGNAL\_LEVEL\_LOW**

This interrupt signal variant indicates that the interrupt is triggered by a low level signal.

#### **RTEMS\_INTERRUPT\_SIGNAL\_LEVEL\_HIGH**

This interrupt signal variant indicates that the interrupt is triggered by a high level signal.

#### **RTEMS\_INTERRUPT\_SIGNAL\_EDGE\_FALLING**

This interrupt signal variant indicates that the interrupt is triggered by a falling edge signal.

## **RTEMS\_INTERRUPT\_SIGNAL\_EDGE\_RAISING**

This interrupt signal variant indicates that the interrupt is triggered by a raising edge signal.

## <span id="page-74-5"></span><span id="page-74-0"></span>5.2.35 rtems\_interval

This type represents clock tick intervals.

## <span id="page-74-1"></span>5.2.36 rtems\_isr

This type defines the return type of interrupt service routines.

#### DESCRIPTION:

This type can be used to document interrupt service routines in the source code.

# <span id="page-74-2"></span>5.2.37 rtems\_isr\_entry

Interrupt service routines installed by *[rtems\\_interrupt\\_catch\(\)](#page-189-0)* (page 162) shall have this type.

## <span id="page-74-3"></span>5.2.38 rtems\_message\_queue\_config

This structure defines the configuration of a message queue constructed by *[rtems\\_message\\_queue\\_construct\(\)](#page-404-0)* (page 377).

#### MEMBERS:

#### **name**

This member defines the name of the message queue.

## **maximum\_pending\_messages**

This member defines the maximum number of pending messages supported by the message queue.

#### **maximum\_message\_size**

This member defines the maximum message size supported by the message queue.

#### **storage\_area**

This member shall point to the message buffer storage area begin. The message buffer storage area for the message queue shall be an array of the type defined by *[RTEMS\\_MESSAGE\\_QUEUE\\_BUFFER\(\)](#page-420-0)* (page 393) with a maximum message size equal to the maximum message size of this configuration.

#### **storage\_size**

This member defines size of the message buffer storage area in bytes.

#### **storage\_free**

This member defines the optional handler to free the message buffer storage area. It is called when the message queue is deleted. It is called from task context under protection of the object allocator lock. It is allowed to call free() in this handler. If handler is [NULL,](https://en.cppreference.com/w/c/types/NULL) then no action will be performed.

## **attributes**

This member defines the attributes of the message queue.

## <span id="page-74-4"></span>5.2.39 rtems\_mode

This type represents a Classic API task mode set.

<span id="page-75-11"></span><span id="page-75-0"></span>5.2.40 rtems\_mp\_packet\_classes

This enumeration defines the MPCI packet classes.

<span id="page-75-1"></span>5.2.41 rtems\_mpci\_entry

MPCI handler routines shall have this return type.

<span id="page-75-2"></span>5.2.42 rtems\_mpci\_get\_packet\_entry

MPCI get packet routines shall have this type.

<span id="page-75-3"></span>5.2.43 rtems\_mpci\_initialization\_entry

MPCI initialization routines shall have this type.

<span id="page-75-4"></span>5.2.44 rtems\_mpci\_receive\_packet\_entry

MPCI receive packet routines shall have this type.

<span id="page-75-5"></span>5.2.45 rtems\_mpci\_return\_packet\_entry

MPCI return packet routines shall have this type.

<span id="page-75-6"></span>5.2.46 rtems\_mpci\_send\_packet\_entry

MPCI send packet routines shall have this type.

<span id="page-75-7"></span>5.2.47 rtems\_mpci\_table

This type represents the user-provided MPCI control.

<span id="page-75-8"></span>5.2.48 rtems\_multiprocessing\_table

This type represents the user-provided MPCI configuration.

<span id="page-75-9"></span>5.2.49 rtems\_name

This type represents Classic API object names.

## DESCRIPTION:

It is an unsigned 32-bit integer which can be treated as a numeric value or initialized using *[rtems\\_build\\_name\(\)](#page-931-0)* (page 904) to encode four ASCII characters. A value of zero may have a special meaning in some directives.

<span id="page-75-10"></span>5.2.50 rtems\_object\_api\_class\_information

This structure is used to return information to the application about the objects configured for a specific API/Class combination.

#### <span id="page-76-4"></span>MEMBERS:

#### **minimum\_id**

This member contains the minimum valid object identifier for this class.

## **maximum\_id**

This member contains the maximum valid object identifier for this class.

## **maximum**

This member contains the maximum number of active objects configured for this class.

#### **auto\_extend**

This member is true, if this class is configured for automatic object extension, otherwise it is false.

#### **unallocated**

This member contains the number of currently inactive objects of this class.

## <span id="page-76-0"></span>5.2.51 rtems\_option

This type represents a Classic API directive option set.

## <span id="page-76-1"></span>5.2.52 rtems\_packet\_prefix

This type represents the prefix found at the beginning of each MPCI packet sent between nodes.

## <span id="page-76-2"></span>5.2.53 rtems\_rate\_monotonic\_period\_states

This enumeration defines the states in which a period may be.

#### ENUMERATORS:

### **RATE\_MONOTONIC\_INACTIVE**

This status indicates the period is off the watchdog chain, and has never been initialized.

## **RATE\_MONOTONIC\_ACTIVE**

This status indicates the period is on the watchdog chain, and running. The owner may be executing or blocked waiting on another object.

#### **RATE\_MONOTONIC\_EXPIRED**

This status indicates the period is off the watchdog chain, and has expired. The owner may still execute and has taken too much time to complete this iteration of the period.

## <span id="page-76-3"></span>5.2.54 rtems\_rate\_monotonic\_period\_statistics

This structure provides the statistics of a period.

#### MEMBERS:

## **count**

This member contains the number of periods executed.

## **missed\_count**

This member contains the number of periods missed.

#### **min\_cpu\_time**

This member contains the least amount of processor time used in a period.

#### <span id="page-77-2"></span>**max\_cpu\_time**

This member contains the highest amount of processor time used in a period.

#### **total\_cpu\_time**

This member contains the total amount of processor time used in a period.

#### **min\_wall\_time**

This member contains the least amount of *[CLOCK\\_MONOTONIC](#page-1062-0)* time used in a period.

#### **max\_wall\_time**

This member contains the highest amount of *[CLOCK\\_MONOTONIC](#page-1062-0)* time used in a period.

## **total\_wall\_time**

This member contains the total amount of *[CLOCK\\_MONOTONIC](#page-1062-0)* time used in a period.

## <span id="page-77-0"></span>5.2.55 rtems\_rate\_monotonic\_period\_status

This structure provides the detailed status of a period.

#### MEMBERS:

#### **owner**

This member contains the identifier of the owner task of the period.

## **state**

This member contains the state of the period.

## **since\_last\_period**

This member contains the time elapsed since the last successful invocation *[rtems\\_rate\\_monotonic\\_period\(\)](#page-344-0)* (page 317) using *[CLOCK\\_MONOTONIC](#page-1062-0)*. If the period is expired or has not been initiated, then this value has no meaning.

#### **executed\_since\_last\_period**

This member contains the processor time consumed by the owner task since the last successful invocation *[rtems\\_rate\\_monotonic\\_period\(\)](#page-344-0)* (page 317). If the period is expired or has not been initiated, then this value has no meaning.

## **postponed\_jobs\_count**

This member contains the count of jobs which are not released yet.

## <span id="page-77-1"></span>5.2.56 rtems\_regulator\_attributes

This structure defines the configuration of a regulator created by *[rtems\\_regulator\\_create\(\)](#page-861-0)* (page 834).

## MEMBERS:

## **deliverer**

This member contains a pointer to an application function invoked by the Delivery thread to output a message to the destination.

#### **deliverer\_context**

This member contains a pointer to an application defined context which is passed to delivery function.

#### **maximum\_message\_size**

This member contains the maximum size message to process.

#### <span id="page-78-2"></span>**maximum\_messages**

This member contains the maximum number of messages to be able to buffer.

#### **output\_thread\_priority**

This member contains the priority of output thread.

#### **output\_thread\_stack\_size**

This member contains the Stack size of output thread.

## **output\_thread\_period**

This member contains the period (in ticks) of output thread.

## **maximum\_to\_dequeue\_per\_period**

This member contains the maximum number of messages the output thread should dequeue and deliver per period.

#### NOTES:

This type is passed as an argument to *[rtems\\_regulator\\_create\(\)](#page-861-0)* (page 834).

# <span id="page-78-0"></span>5.2.57 rtems\_regulator\_deliverer

This type represents the function signature used to specify a delivery function for the RTEMS Regulator.

## NOTES:

This type is used in the *[rtems\\_regulator\\_attributes](#page-77-1)* (page 50) structure which is passed as an argument to *[rtems\\_regulator\\_create\(\)](#page-861-0)* (page 834).

## <span id="page-78-1"></span>5.2.58 rtems\_regulator\_statistics

This structure defines the statistics maintained by each Regulator instance.

#### MEMBERS:

#### **obtained**

This member contains the number of successfully obtained buffers.

## **released**

This member contains the number of successfully released buffers.

#### **delivered**

This member contains the number of successfully delivered buffers.

#### **period\_statistics**

This member contains the Rate Monotonic Period statistics for the Delivery Thread. It is an instance of the *[rtems\\_rate\\_monotonic\\_period\\_statistics](#page-76-3)* (page 49) structure.

#### NOTES:

This type is passed as an argument to *[rtems\\_regulator\\_get\\_statistics\(\)](#page-869-0)* (page 842).

## <span id="page-79-5"></span><span id="page-79-0"></span>5.2.59 rtems\_signal\_set

This integer type represents a bit field which can hold exactly 32 individual signals.

## <span id="page-79-1"></span>5.2.60 rtems\_stack\_allocate\_hook

A thread stack allocator allocate handler shall have this type.

## <span id="page-79-2"></span>5.2.61 rtems\_stack\_allocate\_init\_hook

A task stack allocator initialization handler shall have this type.

## <span id="page-79-3"></span>5.2.62 rtems\_stack\_free\_hook

A task stack allocator free handler shall have this type.

## <span id="page-79-4"></span>5.2.63 rtems\_status\_code

This enumeration provides status codes for directives of the Classic API.

## ENUMERATORS:

#### **RTEMS\_SUCCESSFUL**

This status code indicates successful completion of a requested operation.

#### **RTEMS\_TASK\_EXITTED**

This status code indicates that a thread exitted.

#### **RTEMS\_MP\_NOT\_CONFIGURED**

This status code indicates that multiprocessing was not configured.

#### **RTEMS\_INVALID\_NAME**

This status code indicates that an object name was invalid.

#### **RTEMS\_INVALID\_ID**

This status code indicates that an object identifier was invalid.

## **RTEMS\_TOO\_MANY**

This status code indicates you have attempted to create too many instances of a particular object class.

#### **RTEMS\_TIMEOUT**

This status code indicates that a blocking directive timed out.

#### **RTEMS\_OBJECT\_WAS\_DELETED**

This status code indicates the object was deleted while the thread was blocked waiting.

#### **RTEMS\_INVALID\_SIZE**

This status code indicates that a specified size was invalid.

## **RTEMS\_INVALID\_ADDRESS**

This status code indicates that a specified address was invalid.

#### **RTEMS\_INVALID\_NUMBER**

This status code indicates that a specified number was invalid.

## **RTEMS\_NOT\_DEFINED**

This status code indicates that the item has not been initialized.

#### <span id="page-80-0"></span>**RTEMS\_RESOURCE\_IN\_USE**

This status code indicates that the object still had resources in use.

## **RTEMS\_UNSATISFIED**

This status code indicates that the request was not satisfied.

#### **RTEMS\_INCORRECT\_STATE**

This status code indicates that an object was in wrong state for the requested operation.

## **RTEMS\_ALREADY\_SUSPENDED**

This status code indicates that the thread was already suspended.

## **RTEMS\_ILLEGAL\_ON\_SELF**

This status code indicates that the operation was illegal on the calling thread.

## **RTEMS\_ILLEGAL\_ON\_REMOTE\_OBJECT**

This status code indicates that the operation was illegal on a remote object.

#### **RTEMS\_CALLED\_FROM\_ISR**

This status code indicates that the operation should not be called from this execution environment.

## **RTEMS\_INVALID\_PRIORITY**

This status code indicates that an invalid thread priority was provided.

## **RTEMS\_INVALID\_CLOCK**

This status code indicates that a specified date or time was invalid.

## **RTEMS\_INVALID\_NODE**

This status code indicates that a specified node identifier was invalid.

#### **RTEMS\_NOT\_CONFIGURED**

This status code indicates that the directive was not configured.

## **RTEMS\_NOT\_OWNER\_OF\_RESOURCE**

This status code indicates that the caller was not the owner of the resource.

#### **RTEMS\_NOT\_IMPLEMENTED**

This status code indicates the directive or requested portion of the directive is not implemented. This is a hint that you have stumbled across an opportunity to submit code to the RTEMS Project.

## **RTEMS\_INTERNAL\_ERROR**

This status code indicates that an internal RTEMS inconsistency was detected.

#### **RTEMS\_NO\_MEMORY**

This status code indicates that the directive attempted to allocate memory but was unable to do so.

#### **RTEMS\_IO\_ERROR**

This status code indicates a device driver IO error.

## **RTEMS\_INTERRUPTED**

This status code is used internally by the implementation to indicate a blocking device driver call has been interrupted and should be reflected to the caller as interrupted.

## **RTEMS\_PROXY\_BLOCKING**

This status code is used internally by the implementation when performing operations on behalf of remote tasks. This is referred to as proxying operations and this status indicates that the operation could not be completed immediately and the proxy is blocking.

## <span id="page-81-4"></span><span id="page-81-0"></span>5.2.64 rtems\_task

This type defines the return type of task entry points.

#### DESCRIPTION:

This type can be used to document task entry points in the source code.

## <span id="page-81-1"></span>5.2.65 rtems\_task\_argument

This integer type represents task argument values.

#### NOTES:

The type is an architecture-specific unsigned integer type which is large enough to represent pointer values and 32-bit unsigned integers.

## <span id="page-81-2"></span>5.2.66 rtems\_task\_begin\_extension

Task begin extensions are invoked when a task begins execution.

## PARAMETERS:

#### **executing**

This parameter is the *[TCB](#page-1077-1)* of the executing thread.

#### NOTES:

The task begin extensions are invoked in *[extension forward order](#page-1065-0)*.

Task begin extensions are invoked with thread dispatching enabled. This allows the use of dynamic memory allocation, creation of POSIX keys, and use of C++ thread-local storage. Blocking synchronization primitives are allowed also.

The task begin extensions are invoked before the global construction.

The task begin extensions may be called as a result of a task restart through *[rtems\\_task\\_restart\(\)](#page-147-0)* (page 120).

## <span id="page-81-3"></span>5.2.67 rtems\_task\_config

This structure defines the configuration of a task constructed by *[rtems\\_task\\_construct\(\)](#page-140-0)* (page 113).

#### MEMBERS:

#### **name**

This member defines the name of the task.

## **initial\_priority**

This member defines the initial priority of the task.

#### **storage\_area**

This member shall point to the task storage area begin. The task storage area will contain the task stack, the thread-local storage, and the floating-point context on architectures with a separate floating-point context.

<span id="page-82-1"></span>The task storage area begin address and size should be aligned by RTEMS\_TASK\_STORAGE\_ALIGNMENT. To avoid memory waste, use RTEMS\_ALIGNED() and RTEMS\_TASK\_STORAGE\_ALIGNMENT to enforce the recommended alignment of a statically allocated task storage area.

#### **storage\_size**

This member defines size of the task storage area in bytes. Use the *[RTEMS\\_TASK\\_STORAGE\\_SIZE\(\)](#page-171-0)* (page 144) macro to determine the recommended task storage area size.

## **maximum\_thread\_local\_storage\_size**

This member defines the maximum thread-local storage size supported by the task storage area. Use RTEMS\_ALIGN\_UP() and RTEMS\_TASK\_STORAGE\_ALIGNMENT to adjust the size to meet the minimum alignment requirement of a thread-local storage area used to construct a task.

If the value is less than the actual thread-local storage size, then the task construction by *[rtems\\_task\\_construct\(\)](#page-140-0)* (page 113) fails.

If the is less than the task storage area size, then the task construction by *[rtems\\_task\\_construct\(\)](#page-140-0)* (page 113) fails.

The actual thread-local storage size is determined when the application executable is linked. The rtems-exeinfo command line tool included in the RTEMS Tools can be used to obtain the thread-local storage size and alignment of an application executable.

The application may configure the maximum thread-local storage size for all threads explicitly through the *[CONFIGURE\\_MAXIMUM\\_THREAD\\_LOCAL\\_STORAGE\\_SIZE](#page-607-0)* (page 580) configuration option.

## **storage\_free**

This member defines the optional handler to free the task storage area. It is called on exactly two mutually exclusive occasions. Firstly, when the task construction aborts due to a failed task create extension, or secondly, when the task is deleted. It is called from task context under protection of the object allocator lock. It is allowed to call free() in this handler. If handler is [NULL,](https://en.cppreference.com/w/c/types/NULL) then no action will be performed.

#### **initial\_modes**

This member defines the initial modes of the task.

#### **attributes**

This member defines the attributes of the task.

## <span id="page-82-0"></span>5.2.68 rtems\_task\_create\_extension

Task create extensions are invoked when a task is created.

## PARAMETERS:

#### **executing**

This parameter is the *[TCB](#page-1077-1)* of the executing thread. When the idle thread is created, the executing thread is equal to [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **created**

This parameter is the *[TCB](#page-1077-1)* of the created thread.

### <span id="page-83-3"></span>RETURN VALUES:

Returns true, if the task create extension was successful, otherwise false.

#### NOTES:

The task create extensions are invoked in *[extension forward order](#page-1065-0)*.

The task create extensions are invoked after a new task has been completely initialized, but before it is started.

While normal tasks are created, the executing thread is the owner of the object allocator mutex. The object allocator mutex allows nesting, so the normal memory allocation routines can be used allocate memory for the created thread.

If the task create extension returns false, then the task create operation stops immediately and the entire task create operation will fail. In this case, all task delete extensions are invoked, see *[rtems\\_task\\_delete\\_extension](#page-83-0)* (page 56).

## <span id="page-83-0"></span>5.2.69 rtems\_task\_delete\_extension

Task delete extensions are invoked when a task is deleted.

#### PARAMETERS:

#### **executing**

This parameter is the *[TCB](#page-1077-1)* of the executing thread. If the idle thread is created and one of the initial task create extension fails, then the executing thread is equal to [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **created**

This parameter is the *[TCB](#page-1077-1)* of the deleted thread. The executing and deleted arguments are never equal.

#### NOTES:

The task delete extensions are invoked in *[extension reverse order](#page-1065-1)*.

The task delete extensions are invoked by task create directives before an attempt to allocate a *[TCB](#page-1077-1)* is made.

If a task create extension failed, then a task delete extension may be invoked without a previous invocation of the corresponding task create extension of the extension set.

## <span id="page-83-1"></span>5.2.70 rtems\_task\_entry

This type defines the *[task entry](#page-1076-1)* point of an RTEMS task.

## <span id="page-83-2"></span>5.2.71 rtems\_task\_exitted\_extension

Task exitted extensions are invoked when a task entry returns.

#### PARAMETERS:

#### **executing**

This parameter is the *[TCB](#page-1077-1)* of the executing thread.

### <span id="page-84-4"></span>NOTES:

The task exitted extensions are invoked in *[extension forward order](#page-1065-0)*.

## <span id="page-84-0"></span>5.2.72 rtems\_task\_priority

This integer type represents task priorities of the Classic API.

## <span id="page-84-1"></span>5.2.73 rtems\_task\_restart\_extension

Task restart extensions are invoked when a task restarts.

#### PARAMETERS:

#### **executing**

This parameter is the *[TCB](#page-1077-1)* of the executing thread.

#### **restarted**

This parameter is the *[TCB](#page-1077-1)* of the executing thread. Yes, the executing thread.

#### NOTES:

The task restart extensions are invoked in *[extension forward order](#page-1065-0)*.

The task restart extensions are invoked in the context of the restarted thread right before the execution context is reloaded. The thread stack reflects the previous execution context.

Thread restart and delete requests issued by restart extensions lead to recursion.

## <span id="page-84-2"></span>5.2.74 rtems\_task\_start\_extension

Task start extensions are invoked when a task was made ready for the first time.

## PARAMETERS:

#### **executing**

This parameter is the *[TCB](#page-1077-1)* of the executing thread.

#### **started**

This parameter is the *[TCB](#page-1077-1)* of the started thread.

# NOTES:

The task start extensions are invoked in *[extension forward order](#page-1065-0)*.

In SMP configurations, the thread may already run on another processor before the task start extensions are actually invoked. Task switch and task begin extensions may run before or in parallel with the thread start extension in SMP configurations, see *[rtems\\_task\\_switch\\_extension](#page-84-3)* (page 57) and *[rtems\\_task\\_begin\\_extension](#page-81-2)* (page 54).

## <span id="page-84-3"></span>5.2.75 rtems\_task\_switch\_extension

Task switch extensions are invoked when a thread switch from an executing thread to a heir thread takes place.

#### <span id="page-85-1"></span>PARAMETERS:

#### **executing**

This parameter is the *[TCB](#page-1077-1)* of the executing thread. In SMP configurations, this is the previously executing thread also known as the ancestor thread.

## **heir**

This parameter is the *[TCB](#page-1077-1)* of the heir thread. In SMP configurations, this is the executing thread.

## NOTES:

The task switch extensions are invoked in *[extension forward order](#page-1065-0)*.

The invocation conditions of the task switch extensions depend on whether RTEMS was built with SMP support enabled or disabled. A user must pay attention to the differences to correctly implement a task switch extension.

Where the system was built with SMP support disabled, the task switch extensions are invoked before the context switch from the currently executing thread to the heir thread. The executing is a pointer to the *[TCB](#page-1077-1)* of the currently executing thread. The heir is a pointer to the TCB of the heir thread. The context switch initiated through the multitasking start is not covered by the task switch extensions.

Where the system was built with SMP support enabled, the task switch extensions are invoked after the context switch to the heir thread. The executing is a pointer to the TCB of the previously executing thread. Despite the name, this is not the currently executing thread. The heir is a pointer to the TCB of the newly executing thread. This is the currently executing thread. The context switches initiated through the multitasking start are covered by the task switch extensions. The reason for the differences to uniprocessor configurations is that the context switch may update the heir thread of the processor. The task switch extensions are invoked with maskable interrupts disabled and with ownership of a processor-specific SMP lock. Task switch extensions may run in parallel on multiple processors. It is recommended to use threadlocal or processor-specific data structures for task switch extensions. A global SMP lock should be avoided for performance reasons, see *[rtems\\_interrupt\\_lock\\_initialize\(\)](#page-199-0)* (page 172).

## <span id="page-85-0"></span>5.2.76 rtems\_task\_terminate\_extension

Task terminate extensions are invoked when a task terminates.

## PARAMETERS:

#### **executing**

This parameter is the *[TCB](#page-1077-1)* of the executing thread. This is the terminating thread.

## NOTES:

The task terminate extensions are invoked in *[extension reverse order](#page-1065-1)*.

The task terminate extensions are invoked in the context of the terminating thread right before the thread dispatch to the heir thread should take place. The thread stack reflects the previous execution context. The POSIX cleanup and key destructors execute in this context.

Thread restart and delete requests issued by terminate extensions lead to recursion.

## <span id="page-86-4"></span><span id="page-86-0"></span>5.2.77 rtems\_task\_visitor

Visitor routines invoked by *[rtems\\_task\\_iterate\(\)](#page-170-0)* (page 143) shall have this type.

## <span id="page-86-1"></span>5.2.78 rtems\_tcb

This structure represents the *[TCB](#page-1077-1)*.

## <span id="page-86-2"></span>5.2.79 rtems\_time\_of\_day

This type represents Classic API calendar times.

## MEMBERS:

#### **year**

This member contains the year A.D.

#### **month**

This member contains the month of the year with values from 1 to 12.

## **day**

This member contains the day of the month with values from 1 to 31.

## **hour**

This member contains the hour of the day with values from 0 to 23.

### **minute**

This member contains the minute of the hour with values from 0 to 59.

#### **second**

This member contains the second of the minute with values from 0 to 59.

## **ticks**

This member contains the clock tick of the second with values from 0 to *[rtems\\_clock\\_get\\_ticks\\_per\\_second\(\)](#page-291-0)* (page 264) minus one.

## <span id="page-86-3"></span>5.2.80 rtems\_timer\_information

The structure contains information about a timer.

## MEMBERS:

#### **the\_class**

The timer class member indicates how the timer was most recently fired.

#### **initial**

This member indicates the initial requested interval.

## **start\_time**

This member indicates the time the timer was initially scheduled. The time is in clock ticks since the clock driver initialization or the last clock tick counter overflow.

#### **stop\_time**

This member indicates the time the timer was scheduled to fire. The time is in clock ticks since the clock driver initialization or the last clock tick counter overflow.

## <span id="page-87-3"></span><span id="page-87-0"></span>5.2.81 rtems\_timer\_service\_routine

This type defines the return type of routines which can be fired by directives of the Timer Manager.

#### DESCRIPTION:

This type can be used to document timer service routines in the source code.

## <span id="page-87-1"></span>5.2.82 rtems\_timer\_service\_routine\_entry

This type defines the prototype of routines which can be fired by directives of the Timer Manager.

## <span id="page-87-2"></span>5.2.83 rtems\_vector\_number

This integer type represents interrupt vector numbers.

CHAPTER

**SIX**

# <span id="page-88-0"></span>SCHEDULING CONCEPTS

# <span id="page-89-0"></span>6.1 Introduction

The scheduling concepts relate to the allocation of processing time for tasks.

The concept of scheduling in real-time systems dictates the ability to provide an immediate response to specific external events, particularly the necessity of scheduling tasks to run within a specified time limit after the occurrence of an event. For example, software embedded in life-support systems used to monitor hospital patients must take instant action if a change in the patient's status is detected.

The component of RTEMS responsible for providing this capability is appropriately called the scheduler. The scheduler's sole purpose is to allocate the all important resource of processor time to the various tasks competing for attention. The directives provided by the Scheduler Manager are:

- *[rtems\\_scheduler\\_ident\(\)](#page-99-0)* (page 72) Identifies a scheduler by the object name.
- *[rtems\\_scheduler\\_ident\\_by\\_processor\(\)](#page-100-0)* (page 73) Identifies a scheduler by the processor index.
- *[rtems\\_scheduler\\_ident\\_by\\_processor\\_set\(\)](#page-101-0)* (page 74) Identifies a scheduler by the processor set.
- *[rtems\\_scheduler\\_get\\_maximum\\_priority\(\)](#page-103-0)* (page 76) Gets the maximum task priority of the scheduler.
- *[rtems\\_scheduler\\_map\\_priority\\_to\\_posix\(\)](#page-104-0)* (page 77) Maps a Classic API task priority to the corresponding POSIX thread priority.
- *[rtems\\_scheduler\\_map\\_priority\\_from\\_posix\(\)](#page-105-0)* (page 78) Maps a POSIX thread priority to the corresponding Classic API task priority.
- *[rtems\\_scheduler\\_get\\_processor\(\)](#page-106-0)* (page 79) Returns the index of the current processor.
- *[rtems\\_scheduler\\_get\\_processor\\_maximum\(\)](#page-107-0)* (page 80) Returns the processor maximum supported by the system.
- *[rtems\\_scheduler\\_get\\_processor\\_set\(\)](#page-108-0)* (page 81) Gets the set of processors owned by the scheduler.
- *[rtems\\_scheduler\\_add\\_processor\(\)](#page-109-0)* (page 82) Adds the processor to the set of processors owned by the scheduler.
- *[rtems\\_scheduler\\_remove\\_processor\(\)](#page-110-0)* (page 83) Removes the processor from the set of processors owned by the scheduler.

# <span id="page-90-3"></span><span id="page-90-0"></span>6.2 Background

## <span id="page-90-1"></span>6.2.1 Scheduling Algorithms

RTEMS provides a plugin framework that allows it to support multiple scheduling algorithms. RTEMS includes multiple scheduling algorithms, and the user can select which of these they wish to use in their application at link-time. In addition, the user can implement their own scheduling algorithm and configure RTEMS to use it.

Supporting multiple scheduling algorithms gives the end user the option to select the algorithm which is most appropriate to their use case. Most real-time operating systems schedule tasks using a priority based algorithm, possibly with preemption control. The classic RTEMS scheduling algorithm which was the only algorithm available in RTEMS 4.10 and earlier, is a fixed-priority scheduling algorithm. This scheduling algorithm is suitable for uniprocessor (e.g., non-SMP) systems and is known as the *Deterministic Priority Scheduler*. Unless the user configures another scheduling algorithm, RTEMS will use this on uniprocessor systems.

## <span id="page-90-2"></span>6.2.2 Priority Scheduling

When using priority based scheduling, RTEMS allocates the processor using a priority-based, preemptive algorithm augmented to provide round-robin characteristics within individual priority groups. The goal of this algorithm is to guarantee that the task which is executing on the processor at any point in time is the one with the highest priority among all tasks in the ready state.

When a task is added to the ready chain, it is placed behind all other tasks of the same priority. This rule provides a round-robin within a priority group scheduling characteristic. This means that in a group of equal priority tasks, tasks will execute in the order they become ready or FIFO order. Even though there are ways to manipulate and adjust task priorities, the most important rule to remember is:

![](_page_90_Figure_9.jpeg)

## Ã² **Note**

Priority based scheduling algorithms will always select the highest priority task that is ready to run when allocating the processor to a task.

Priority scheduling is the most commonly used scheduling algorithm. It should be used by applications in which multiple tasks contend for CPU time or other resources, and there is a need to ensure certain tasks are given priority over other tasks.

There are a few common methods of accomplishing the mechanics of this algorithm. These ways involve a list or chain of tasks in the ready state.

- The least efficient method is to randomly place tasks in the ready chain forcing the scheduler to scan the entire chain to determine which task receives the processor.
- A more efficient method is to schedule the task by placing it in the proper place on the ready chain based on the designated scheduling criteria at the time it enters the ready state. Thus, when the processor is free, the first task on the ready chain is allocated the processor.
- Another mechanism is to maintain a list of FIFOs per priority. When a task is readied, it is placed on the rear of the FIFO for its priority. This method is often used with a bitmap

6.2. Background 63

<span id="page-91-4"></span>to assist in locating which FIFOs have ready tasks on them. This data structure has (1) insert, extract and find highest ready run-time complexities.

â€¢ A red-black tree may be used for the ready queue with the priority as the key. This data structure has (()) insert, extract and find highest ready run-time complexities while is the count of tasks in the ready queue.

RTEMS currently includes multiple priority based scheduling algorithms as well as other algorithms that incorporate deadline. Each algorithm is discussed in the following sections.

## <span id="page-91-0"></span>6.2.3 Scheduling Modification Mechanisms

RTEMS provides four mechanisms which allow the user to alter the task scheduling decisions:

- user-selectable task priority level
- task preemption control
- task timeslicing control
- manual round-robin selection

Each of these methods provides a powerful capability to customize sets of tasks to satisfy the unique and particular requirements encountered in custom real-time applications. Although each mechanism operates independently, there is a precedence relationship which governs the effects of scheduling modifications. The evaluation order for scheduling characteristics is always priority, preemption mode, and timeslicing. When reading the descriptions of timeslicing and manual round-robin it is important to keep in mind that preemption (if enabled) of a task by higher priority tasks will occur as required, overriding the other factors presented in the description.

#### <span id="page-91-1"></span>6.2.3.1 Task Priority and Scheduling

The most significant task scheduling modification mechanism is the ability for the user to assign a priority level to each individual task when it is created and to alter a task's priority at run-time, see *[Task Priority](#page-127-2)* (page 100).

#### <span id="page-91-2"></span>6.2.3.2 Preemption

Another way the user can alter the basic scheduling algorithm is by manipulating the preemption mode flag (RTEMS\_PREEMPT\_MASK) of individual tasks. If preemption is disabled for a task (RTEMS\_NO\_PREEMPT), then the task will not relinquish control of the processor until it terminates, blocks, or re-enables preemption. Even tasks which become ready to run and possess higher priority levels will not be allowed to execute. Note that the preemption setting has no effect on the manner in which a task is scheduled. It only applies once a task has control of the processor.

#### <span id="page-91-3"></span>6.2.3.3 Timeslicing

Timeslicing or round-robin scheduling is an additional method which can be used to alter the basic scheduling algorithm. Like preemption, timeslicing is specified on a task by task basis using the timeslicing mode flag (RTEMS\_TIMESLICE\_MASK). If timeslicing is enabled for a task (RTEMS\_TIMESLICE), then RTEMS will limit the amount of time the task can execute before the processor is allocated to another task. Each tick of the real-time clock reduces the currently running task's timeslice. When the execution time equals the timeslice, RTEMS will dispatch another task of the same priority to execute. If there are no other tasks of the same priority <span id="page-92-3"></span>ready to execute, then the current task is allocated an additional timeslice and continues to run. Remember that a higher priority task will preempt the task (unless preemption is disabled) as soon as it is ready to run, even if the task has not used up its entire timeslice.

## <span id="page-92-0"></span>6.2.3.4 Manual Round-Robin

The final mechanism for altering the RTEMS scheduling algorithm is called manual roundrobin. Manual round-robin is invoked by using the rtems\_task\_wake\_after directive with a ticks parameter of RTEMS\_YIELD\_PROCESSOR. This allows a task to give up the processor and be immediately returned to the ready chain at the end of its priority group. If no other tasks of the same priority are ready to run, then the task does not lose control of the processor.

## <span id="page-92-1"></span>6.2.4 Dispatching Tasks

The dispatcher is the RTEMS component responsible for allocating the processor to a ready task. In order to allocate the processor to one task, it must be deallocated or retrieved from the task currently using it. This involves a concept called a context switch. To perform a context switch, the dispatcher saves the context of the current task and restores the context of the task which has been allocated to the processor. Saving and restoring a task's context is the storing/loading of all the essential information about a task to enable it to continue execution without any effects of the interruption. For example, the contents of a task's register set must be the same when it is given the processor as they were when it was taken away. All of the information that must be saved or restored for a context switch is located either in the TCB or on the task's stacks.

Tasks that utilize a numeric coprocessor and are created with the RTEMS\_FLOATING\_POINT attribute require additional operations during a context switch. These additional operations are necessary to save and restore the floating point context of RTEMS\_FLOATING\_POINT tasks. To avoid unnecessary save and restore operations, the state of the numeric coprocessor is only saved when a RTEMS\_FLOATING\_POINT task is dispatched and that task was not the last task to utilize the coprocessor.

## <span id="page-92-2"></span>6.2.5 Task State Transitions

Tasks in an RTEMS system must always be in one of the five allowable task states. These states are: executing, ready, blocked, dormant, and non-existent.

A task occupies the non-existent state before a rtems\_task\_create has been issued on its behalf. A task enters the non-existent state from any other state in the system when it is deleted with the rtems\_task\_delete directive. While a task occupies this state it does not have a TCB or a task ID assigned to it; therefore, no other tasks in the system may reference this task.

When a task is created via the rtems\_task\_create directive, it enters the dormant state. This state is not entered through any other means. Although the task exists in the system, it cannot actively compete for system resources. It will remain in the dormant state until it is started via the rtems\_task\_start directive, at which time it enters the ready state. The task is now permitted to be scheduled for the processor and to compete for other system resources.

A task occupies the blocked state whenever it is unable to be scheduled to run. A running task may block itself or be blocked by other tasks in the system. The running task blocks itself through voluntary operations that cause the task to wait. The only way a task can block a task other than itself is with the rtems\_task\_suspend directive. A task enters the blocked state due to any of the following conditions:

6.2. Background 65

![](_page_93_Picture_2.jpeg)

- A task issues a rtems\_task\_suspend directive which blocks either itself or another task in the system.
- The running task issues a rtems\_barrier\_wait directive.
- The running task issues a rtems\_message\_queue\_receive directive with the wait option, and the message queue is empty.
- The running task issues a rtems\_event\_receive directive with the wait option, and the currently pending events do not satisfy the request.
- The running task issues a rtems\_semaphore\_obtain directive with the wait option and the requested semaphore is unavailable.
- The running task issues a rtems\_task\_wake\_after directive which blocks the task for the given count of ticks. If the count of ticks specified is zero, the task yields the processor and remains in the ready state.
- The running task issues a rtems\_task\_wake\_when directive which blocks the task until the requested date and time arrives.
- The running task issues a rtems\_rate\_monotonic\_period directive and must wait for the specified rate monotonic period to conclude.
- The running task issues a rtems\_region\_get\_segment directive with the wait option and there is not an available segment large enough to satisfy the task's request.

A blocked task may also be suspended. Therefore, both the suspension and the blocking condition must be removed before the task becomes ready to run again.

A task occupies the ready state when it is able to be scheduled to run, but currently does not

have control of the processor. Tasks of the same or higher priority will yield the processor by either becoming blocked, completing their timeslice, or being deleted. All tasks with the same priority will execute in FIFO order. A task enters the ready state due to any of the following conditions:

- A running task issues a rtems\_task\_resume directive for a task that is suspended and the task is not blocked waiting on any resource.
- A running task issues a rtems\_message\_queue\_send, rtems\_message\_queue\_broadcast, or a rtems\_message\_queue\_urgent directive which posts a message to the queue on which the blocked task is waiting.
- A running task issues an rtems\_event\_send directive which sends an event condition to a task that is blocked waiting on that event condition.
- A running task issues a rtems\_semaphore\_release directive which releases the semaphore on which the blocked task is waiting.
- The requested count of ticks has elapsed for a task which was blocked by a call to the rtems\_task\_wake\_after directive.
- A timeout period expires for a task which blocked by a call to the rtems\_task\_wake\_when directive.
- A running task issues a rtems\_region\_return\_segment directive which releases a segment to the region on which the blocked task is waiting and a resulting segment is large enough to satisfy the task's request.
- A rate monotonic period expires for a task which blocked by a call to the rtems\_rate\_monotonic\_period directive.
- A timeout interval expires for a task which was blocked waiting on a message, event, semaphore, or segment with a timeout specified.
- A running task issues a directive which deletes a message queue, a semaphore, or a region on which the blocked task is waiting.
- A running task issues a rtems\_task\_restart directive for the blocked task.
- The running task, with its preemption mode enabled, may be made ready by issuing any of the directives that may unblock a task with a higher priority. This directive may be issued from the running task itself or from an ISR. A ready task occupies the executing state when it has control of the CPU. A task enters the executing state due to any of the following conditions:
- The task is the highest priority ready task in the system.
- The running task blocks and the task is next in the scheduling queue. The task may be of equal priority as in round-robin scheduling or the task may possess the highest priority of the remaining ready tasks.
- The running task may reenable its preemption mode and a task exists in the ready queue that has a higher priority than the running task.
- The running task lowers its own priority and another task is of higher priority as a result.
- The running task raises the priority of a task above its own and the running task is in preemption mode.

6.2. Background 67

# <span id="page-95-4"></span><span id="page-95-0"></span>6.3 Uniprocessor Schedulers

All uniprocessor schedulers included in RTEMS are priority based. The processor is allocated to the highest priority task allowed to run.

## <span id="page-95-1"></span>6.3.1 Deterministic Priority Scheduler

This is the scheduler implementation which has always been in RTEMS. After the 4.10 release series, it was factored into a pluggable scheduler selection. It schedules tasks using a priority based algorithm which takes into account preemption. It is implemented using an array of FIFOs with a FIFO per priority. It maintains a bitmap which is used to track which priorities have ready tasks.

This algorithm is deterministic (e.g., predictable and fixed) in execution time. This comes at the cost of using slightly over three (3) kilobytes of RAM on a system configured to support 256 priority levels.

This scheduler is only aware of a single core.

## <span id="page-95-2"></span>6.3.2 Simple Priority Scheduler

This scheduler implementation has the same behaviour as the Deterministic Priority Scheduler but uses only one linked list to manage all ready tasks. When a task is readied, a linear search of that linked list is performed to determine where to insert the newly readied task.

This algorithm uses much less RAM than the Deterministic Priority Scheduler but is *O(n)* where *n* is the number of ready tasks. In a small system with a small number of tasks, this will not be a performance issue. Reducing RAM consumption is often critical in small systems that are incapable of supporting a large number of tasks.

This scheduler is only aware of a single core.

## <span id="page-95-3"></span>6.3.3 Earliest Deadline First Scheduler

This is an alternative scheduler in RTEMS for single-core applications. The primary EDF advantage is high total CPU utilization (theoretically up to 100%). It assumes that tasks have priorities equal to deadlines.

This EDF is initially preemptive, however, individual tasks may be declared not-preemptive. Deadlines are declared using only Rate Monotonic manager whose goal is to handle periodic behavior. Period is always equal to the deadline. All ready tasks reside in a single ready queue implemented using a red-black tree.

This implementation of EDF schedules two different types of task priority types while each task may switch between the two types within its execution. If a task does have a deadline declared using the Rate Monotonic manager, the task is deadline-driven and its priority is equal to deadline. On the contrary, if a task does not have any deadline or the deadline is cancelled using the Rate Monotonic manager, the task is considered a background task with priority equal to that assigned upon initialization in the same manner as for priority scheduler. Each background task is of lower importance than each deadline-driven one and is scheduled when no deadline-driven task and no higher priority background task is ready to run.

Every deadline-driven scheduling algorithm requires means for tasks to claim a deadline. The Rate Monotonic Manager is responsible for handling periodic execution. In RTEMS periods are equal to deadlines, thus if a task announces a period, it has to be finished until the end of this <span id="page-96-1"></span>period. The call of rtems\_rate\_monotonic\_period passes the scheduler the length of an oncoming deadline. Moreover, the rtems\_rate\_monotonic\_cancel and rtems\_rate\_monotonic\_delete calls clear the deadlines assigned to the task.

## <span id="page-96-0"></span>6.3.4 Constant Bandwidth Server Scheduling (CBS)

This is an alternative scheduler in RTEMS for single-core applications. The CBS is a budget aware extension of EDF scheduler. The main goal of this scheduler is to ensure temporal isolation of tasks meaning that a task's execution in terms of meeting deadlines must not be influenced by other tasks as if they were run on multiple independent processors.

Each task can be assigned a server (current implementation supports only one task per server). The server is characterized by period (deadline) and computation time (budget). The ratio budget/period yields bandwidth, which is the fraction of CPU to be reserved by the scheduler for each subsequent period.

The CBS is equipped with a set of rules applied to tasks attached to servers ensuring that deadline miss because of another task cannot occur. In case a task breaks one of the rules, its priority is pulled to background until the end of its period and then restored again. The rules are:

- Task cannot exceed its registered budget,
- Task cannot be unblocked when a ratio between remaining budget and remaining deadline is higher than declared bandwidth.

The CBS provides an extensive API. Unlike EDF, the rtems\_rate\_monotonic\_period does not declare a deadline because it is carried out using CBS API. This call only announces next period.

# <span id="page-97-0"></span>6.4 SMP Schedulers

All SMP schedulers included in RTEMS are priority based. The processors managed by a scheduler instance are allocated to the highest priority tasks allowed to run.

## <span id="page-97-1"></span>6.4.1 Earliest Deadline First SMP Scheduler

This is a job-level fixed-priority scheduler using the Earliest Deadline First (EDF) method. By convention, the maximum priority level is (\_, 2 <sup>62</sup>âˆ’1) for background tasks. Tasks without an active deadline are background tasks. In case deadlines are not used, then the EDF scheduler behaves exactly like a fixed-priority scheduler. The tasks with an active deadline have a higher priority than the background tasks. This scheduler supports task processor affinities of one-to-one and one-to-all, e.g., a task can execute on exactly one processor or all processors managed by the scheduler instance. The processor affinity set of a task must contain all online processors to select the one-to-all affinity. This is to avoid pathological cases if processors are added/removed to/from the scheduler instance at run-time. In case the processor affinity set contains not all online processors, then a one-to-one affinity will be used selecting the processor with the largest index within the set of processors currently owned by the scheduler instance. This scheduler algorithm supports *[thread pinning](#page-897-1)* (page 870). The ready queues use a red-black tree with the task priority as the key.

This scheduler algorithm is the default scheduler in SMP configurations if more than one processor is configured (*[CONFIGURE\\_MAXIMUM\\_PROCESSORS](#page-606-0)* (page 579)).

## <span id="page-97-2"></span>6.4.2 Deterministic Priority SMP Scheduler

A fixed-priority scheduler which uses a table of chains with one chain per priority level for the ready tasks. The maximum priority level is configurable. By default, the maximum priority level is 255 (256 priority levels), see *[CONFIGURE\\_MAXIMUM\\_PRIORITY](#page-742-0)* (page 715).

## <span id="page-97-3"></span>6.4.3 Simple Priority SMP Scheduler

A fixed-priority scheduler which uses a sorted chain for the ready tasks. By convention, the maximum priority level is 255. The implementation limit is actually 2 <sup>63</sup> âˆ’ 1.

## <span id="page-97-4"></span>6.4.4 Arbitrary Processor Affinity Priority SMP Scheduler

A fixed-priority scheduler which uses a table of chains with one chain per priority level for the ready tasks. The maximum priority level is configurable. By default, the maximum priority level is 255 (256 priority levels), see *[CONFIGURE\\_MAXIMUM\\_PRIORITY](#page-742-0)* (page 715). This scheduler supports arbitrary task processor affinities. The worst-case run-time complexity of some scheduler operations exceeds () while is the count of ready tasks.

# <span id="page-98-0"></span>6.5 Directives

This section details the directives of the Scheduler Manager. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

6.5. Directives 71

## <span id="page-99-1"></span><span id="page-99-0"></span>6.5.1 rtems\_scheduler\_ident()

Identifies a scheduler by the object name.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_scheduler_ident( rtems_name name, rtems_id *id );
```

#### PARAMETERS:

#### **name**

This parameter is the scheduler name to look up.

#### **id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the identifier of the scheduler will be stored in this object.

#### DESCRIPTION:

This directive obtains a scheduler identifier associated with the scheduler name specified in name.

#### RETURN VALUES:

### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_NAME**

There was no scheduler associated with the name.

#### **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### NOTES:

The scheduler name is determined by the scheduler configuration.

The scheduler identifier is used with other scheduler related directives to access the scheduler.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-100-1"></span><span id="page-100-0"></span>6.5.2 rtems\_scheduler\_ident\_by\_processor()

Identifies a scheduler by the processor index.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_scheduler_ident_by_processor(
2 uint32_t cpu_index,
3 rtems_id *id
4 );
```

#### PARAMETERS:

#### **cpu\_index**

This parameter is the processor index to identify the scheduler.

#### **id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the identifier of the scheduler will be stored in this object.

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_NAME**

The processor index was invalid.

## **RTEMS\_INCORRECT\_STATE**

The processor index was valid, however, the corresponding processor was not owned by a scheduler.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

6.5. Directives 73

## <span id="page-101-1"></span><span id="page-101-0"></span>6.5.3 rtems\_scheduler\_ident\_by\_processor\_set()

Identifies a scheduler by the processor set.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_scheduler_ident_by_processor_set(
2 size_t cpusetsize,
3 const cpu_set_t *cpuset,
4 rtems_id *id
5 );
```

#### PARAMETERS:

#### **cpusetsize**

This parameter is the size of the processor set referenced by cpuset in bytes. The size shall be positive.

#### **cpuset**

This parameter is the pointer to a cpu\_set\_t. The referenced processor set will be used to identify the scheduler.

#### **id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the identifier of the scheduler will be stored in this object.

#### DESCRIPTION:

The scheduler is selected according to the highest numbered online processor in the specified processor set.

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

# **RTEMS\_INVALID\_ADDRESS**

The cpuset parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_SIZE**

The processor set size was invalid.

## **RTEMS\_INVALID\_NAME**

The processor set contained no online processor.

#### **RTEMS\_INCORRECT\_STATE**

The processor set was valid, however, the highest numbered online processor in the processor set was not owned by a scheduler.

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

6.5. Directives 75

## <span id="page-103-1"></span><span id="page-103-0"></span>6.5.4 rtems\_scheduler\_get\_maximum\_priority()

Gets the maximum task priority of the scheduler.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_scheduler_get_maximum_priority(
2 rtems_id scheduler_id,
3 rtems_task_priority *priority
4 );
```

#### PARAMETERS:

#### **scheduler\_id**

This parameter is the scheduler identifier.

#### **priority**

This parameter is the pointer to an *[rtems\\_task\\_priority](#page-84-0)* (page 57) object. When the directive the maximum priority of the scheduler will be stored in this object.

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no scheduler associated with the identifier specified by scheduler\_id.

#### **RTEMS\_INVALID\_ADDRESS**

The priority parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-104-1"></span><span id="page-104-0"></span>6.5.5 rtems\_scheduler\_map\_priority\_to\_posix()

Maps a Classic API task priority to the corresponding POSIX thread priority.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_scheduler_map_priority_to_posix(
2 rtems_id scheduler_id,
3 rtems_task_priority priority,
4 int *posix_priority
5 );
```

#### PARAMETERS:

#### **scheduler\_id**

This parameter is the scheduler identifier.

#### **priority**

This parameter is the Classic API task priority to map.

#### **posix\_priority**

This parameter is the pointer to an int object. When the directive call is successful, the POSIX thread priority value corresponding to the specified Classic API task priority value will be stored in this object.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ADDRESS**

The posix\_priority parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

## **RTEMS\_INVALID\_ID**

There was no scheduler associated with the identifier specified by scheduler\_id.

#### **RTEMS\_INVALID\_PRIORITY**

The Classic API task priority was invalid.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

6.5. Directives 77

## <span id="page-105-1"></span><span id="page-105-0"></span>6.5.6 rtems\_scheduler\_map\_priority\_from\_posix()

Maps a POSIX thread priority to the corresponding Classic API task priority.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_scheduler_map_priority_from_posix(
2 rtems_id scheduler_id,
3 int posix_priority,
4 rtems_task_priority *priority
5 );
```

#### PARAMETERS:

#### **scheduler\_id**

This parameter is the scheduler identifier.

#### **posix\_priority**

This parameter is the POSIX thread priority to map.

#### **priority**

This parameter is the pointer to an *[rtems\\_task\\_priority](#page-84-0)* (page 57) object. When the directive call is successful, the Classic API task priority value corresponding to the specified POSIX thread priority value will be stored in this object.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ADDRESS**

The priority parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

## **RTEMS\_INVALID\_ID**

There was no scheduler associated with the identifier specified by scheduler\_id.

#### **RTEMS\_INVALID\_PRIORITY**

The POSIX thread priority was invalid.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-106-1"></span><span id="page-106-0"></span>6.5.7 rtems\_scheduler\_get\_processor()

Returns the index of the current processor.

## CALLING SEQUENCE:

```
1 uint32_t rtems_scheduler_get_processor( void );
```

### DESCRIPTION:

Where the system was built with SMP support disabled, this directive evaluates to a compile time constant of zero.

Where the system was built with SMP support enabled, this directive returns the index of the current processor. The set of processor indices is the range of integers starting with zero up to *[rtems\\_scheduler\\_get\\_processor\\_maximum\(\)](#page-107-0)* (page 80) minus one.

## RETURN VALUES:

Returns the index of the current processor.

## NOTES:

Outside of sections with disabled thread dispatching the current processor index may change after every instruction since the thread may migrate from one processor to another. Sections with disabled interrupts are sections with thread dispatching disabled.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

6.5. Directives 79

## <span id="page-107-1"></span><span id="page-107-0"></span>6.5.8 rtems\_scheduler\_get\_processor\_maximum()

Returns the processor maximum supported by the system.

## CALLING SEQUENCE:

```
1 uint32_t rtems_scheduler_get_processor_maximum( void );
```

### DESCRIPTION:

Where the system was built with SMP support disabled, this directive evaluates to a compile time constant of one.

Where the system was built with SMP support enabled, this directive returns the minimum of the processors (physically or virtually) available at the *[target](#page-1076-0)* and the configured processor maximum (see *[CONFIGURE\\_MAXIMUM\\_PROCESSORS](#page-606-0)* (page 579)). Not all processors in the range from processor index zero to the last processor index (which is the processor maximum minus one) may be configured to be used by a scheduler or may be online (online processors have a scheduler assigned).

#### RETURN VALUES:

Returns the processor maximum supported by the system.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-108-1"></span><span id="page-108-0"></span>6.5.9 rtems\_scheduler\_get\_processor\_set()

Gets the set of processors owned by the scheduler.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_scheduler_get_processor_set(
2 rtems_id scheduler_id,
3 size_t cpusetsize,
4 cpu_set_t *cpuset
5 );
```

#### PARAMETERS:

#### **scheduler\_id**

This parameter is the scheduler identifier.

#### **cpusetsize**

This parameter is the size of the processor set referenced by cpuset in bytes.

#### **cpuset**

This parameter is the pointer to a cpu\_set\_t object. When the directive call is successful, the processor set of the scheduler will be stored in this object. A set bit in the processor set means that the corresponding processor is owned by the scheduler, otherwise the bit is cleared.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ADDRESS**

The cpuset parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

## **RTEMS\_INVALID\_ID**

There was no scheduler associated with the identifier specified by scheduler\_id.

#### **RTEMS\_INVALID\_SIZE**

The provided processor set was too small for the set of processors owned by the scheduler.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

6.5. Directives 81

## <span id="page-109-1"></span><span id="page-109-0"></span>6.5.10 rtems\_scheduler\_add\_processor()

Adds the processor to the set of processors owned by the scheduler.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_scheduler_add_processor(
2 rtems_id scheduler_id,
3 uint32_t cpu_index
4 );
```

#### PARAMETERS:

#### **scheduler\_id**

This parameter is the scheduler identifier.

#### **cpu\_index**

This parameter is the index of the processor to add.

#### DESCRIPTION:

This directive adds the processor specified by the cpu\_index to the scheduler specified by scheduler\_id.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no scheduler associated with the identifier specified by scheduler\_id.

#### **RTEMS\_NOT\_CONFIGURED**

The processor was not configured to be used by the application.

## **RTEMS\_INCORRECT\_STATE**

The processor was configured to be used by the application, however, it was not online.

#### **RTEMS\_RESOURCE\_IN\_USE**

The processor was already assigned to a scheduler.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

## <span id="page-110-1"></span><span id="page-110-0"></span>6.5.11 rtems\_scheduler\_remove\_processor()

Removes the processor from the set of processors owned by the scheduler.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_scheduler_remove_processor(
2 rtems_id scheduler_id,
3 uint32_t cpu_index
4 );
```

### PARAMETERS:

#### **scheduler\_id**

This parameter is the scheduler identifier.

#### **cpu\_index**

This parameter is the index of the processor to remove.

## DESCRIPTION:

This directive removes the processor specified by the cpu\_index from the scheduler specified by scheduler\_id.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ID**

There was no scheduler associated with the identifier specified by scheduler\_id.

#### **RTEMS\_INVALID\_NUMBER**

The processor was not owned by the scheduler.

#### **RTEMS\_RESOURCE\_IN\_USE**

The processor was required by at least one non-idle task that used the scheduler as its *[home](#page-1066-0) [scheduler](#page-1066-0)*.

#### **RTEMS\_RESOURCE\_IN\_USE**

The processor was the last processor owned by the scheduler and there was at least one task that used the scheduler as a *[helping scheduler](#page-1066-1)*.

#### NOTES:

Removing a processor from a scheduler is a complex operation that involves all tasks of the system.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

6.5. Directives 83

CHAPTER

**SEVEN**

# <span id="page-112-0"></span>INITIALIZATION MANAGER

# <span id="page-113-0"></span>7.1 Introduction

The Initialization Manager is responsible for initializing the system.

The system initialization includes the initialization of the Board Support Package, RTEMS, device drivers, the root filesystem, and the application. The *[Fatal Error Manager](#page-544-0)* (page 517) is responsible for the system shutdown. The directives provided by the Initialization Manager are:

â€¢ *[rtems\\_initialize\\_executive\(\)](#page-122-0)* (page 95) - Initializes the system and starts multitasking.

# <span id="page-114-4"></span><span id="page-114-0"></span>7.2 Background

## <span id="page-114-1"></span>7.2.1 Initialization Tasks

Initialization task(s) are the mechanism by which RTEMS transfers initial control to the user's application. Initialization tasks differ from other application tasks in that they are defined in the User Initialization Tasks Table and automatically created and started by RTEMS as part of its initialization sequence. Since the initialization tasks are scheduled using the same algorithm as all other RTEMS tasks, they must be configured at a priority and mode which will ensure that they will complete execution before other application tasks execute. Although there is no upper limit on the number of initialization tasks, an application is required to define at least one.

A typical initialization task will create and start the static set of application tasks. It may also create any other objects used by the application. Initialization tasks which only perform initialization should delete themselves upon completion to free resources for other tasks. Initialization tasks may transform themselves into a "normal" application task. This transformation typically involves changing priority and execution mode. RTEMS does not automatically delete the initialization tasks.

## <span id="page-114-2"></span>7.2.2 The Idle Task

The Idle Task is the lowest priority task in a system and executes only when no other task is ready to execute. The default implementation of this task consists of an infinite loop. RTEMS allows the Idle Task body to be replaced by a CPU specific implementation, a BSP specific implementation or an application specific implementation.

The Idle Task is preemptible and *WILL* be preempted when any other task is made ready to execute. This characteristic is critical to the overall behavior of any application.

## <span id="page-114-3"></span>7.2.3 Initialization Manager Failure

System initialization errors are fatal. See *[Internal Error Codes](#page-548-0)* (page 521).

7.2. Background 87

# <span id="page-115-0"></span>7.3 Operations

## <span id="page-115-1"></span>7.3.1 Initializing RTEMS

The Initialization Manager rtems\_initialize\_executive() directives is called by the boot\_card() routine which is invoked by the Board Support Package once a basic C run-time environment is set up. This consists of

- a valid and accessible text section, read-only data, read-write data and zero-initialized data,
- an initialization stack large enough to initialize the rest of the Board Support Package, RTEMS and the device drivers,
- all registers and components mandated by Application Binary Interface, and
- disabled interrupts.

The rtems\_initialize\_executive() directive uses a system initialization *[linker set](#page-1028-0)* (page 1001) to initialize only those parts of the overall RTEMS feature set that is necessary for a particular application. Each RTEMS feature used the application may optionally register an initialization handler. The system initialization API is available via #included <rtems/sysinit.h>.

A list of all initialization steps follows. Some steps are optional depending on the requested feature set of the application. The initialization steps are execute in the order presented here.

## **RTEMS\_SYSINIT\_RECORD**

Initialization of the event recording is the first initialization step. This allows to record the further system initialization. This step is optional and depends on the *[CONFIG-](#page-683-0)[URE\\_RECORD\\_PER\\_PROCESSOR\\_ITEMS](#page-683-0)* (page 656) configuration option.

#### **RTEMS\_SYSINIT\_BSP\_EARLY**

The Board Support Package may perform an early platform initialization in this step. This step is optional.

#### **RTEMS\_SYSINIT\_MEMORY**

The Board Support Package should initialize everything so that calls to \_Memory\_Get() can be made after this step. This step is optional.

#### **RTEMS\_SYSINIT\_DIRTY\_MEMORY**

The free memory is dirtied in this step. This step is optional and depends on the BSP\_DIRTY\_MEMORY BSP option.

#### **RTEMS\_SYSINIT\_ISR\_STACK**

The stack checker initializes the ISR stacks in this step. This step is optional and depends on the *[CONFIGURE\\_STACK\\_CHECKER\\_ENABLED](#page-614-0)* (page 587) configuration option.

## **RTEMS\_SYSINIT\_PER\_CPU\_DATA**

The per-CPU data is initialized in this step. This step is mandatory.

#### **RTEMS\_SYSINIT\_SBRK**

The Board Support Package may initialize the sbrk() support in this step. This step is optional.

#### **RTEMS\_SYSINIT\_WORKSPACE**

The workspace is initialized in this step. This step is optional and depends on the application configuration.

### **RTEMS\_SYSINIT\_MALLOC**

The C program heap is initialized in this step. This step is optional and depends on the application configuration.

## **RTEMS\_SYSINIT\_BSP\_START**

The Board Support Package should perform a general platform initialization in this step (e.g. interrupt controller initialization). This step is mandatory.

## **RTEMS\_SYSINIT\_CPU\_COUNTER**

Initialization of the CPU counter hardware and support functions. The CPU counter is initialized early to allow its use in the tracing and profiling of the system initialization sequence. This step is optional and depends on the application configuration.

#### **RTEMS\_SYSINIT\_INITIAL\_EXTENSIONS**

Registers the initial extensions. This step is optional and depends on the application configuration.

#### **RTEMS\_SYSINIT\_MP\_EARLY**

In MPCI configurations, an early MPCI initialization is performed in this step. This step is mandatory in MPCI configurations.

## **RTEMS\_SYSINIT\_DATA\_STRUCTURES**

This directive is called when the Board Support Package has completed its basic initialization and allows RTEMS to initialize the application environment based upon the information in the Configuration Table, User Initialization Tasks Table, Device Driver Table, User Extension Table, Multiprocessor Configuration Table, and the Multiprocessor Communications Interface (MPCI) Table.

#### **RTEMS\_SYSINIT\_MP**

In MPCI configurations, a general MPCI initialization is performed in this step. This step is mandatory in MPCI configurations.

## **RTEMS\_SYSINIT\_USER\_EXTENSIONS**

Initialization of the User Extensions object class. This step is optional and depends on the application configuration.

#### **RTEMS\_SYSINIT\_CLASSIC\_TASKS**

Initialization of the Classic Tasks object class. This step is optional and depends on the application configuration.

## **RTEMS\_SYSINIT\_CLASSIC\_TASKS\_MP**

In MPCI configurations, the Classic Tasks MPCI support is initialized in this step. This step is optional and depends on the application configuration.

#### **RTEMS\_SYSINIT\_CLASSIC\_TIMER**

Initialization of the Classic Timer object class. This step is optional and depends on the application configuration.

#### **RTEMS\_SYSINIT\_CLASSIC\_SIGNAL**

Initialization of the Classic Signal support. This step is optional and depends on the application configuration.

## **RTEMS\_SYSINIT\_CLASSIC\_SIGNAL\_MP**

In MPCI configurations, the Classic Signal MPCI support is initialized in this step. This step is optional and depends on the application configuration.

#### **RTEMS\_SYSINIT\_CLASSIC\_EVENT**

Initialization of the Classic Event support. This step is optional and depends on the application

7.3. Operations 89

configuration. This step is only used on MPCI configurations.

#### **RTEMS\_SYSINIT\_CLASSIC\_EVENT\_MP**

In MPCI configurations, the Classic Event MPCI support is initialized in this step. This step is optional and depends on the application configuration.

#### **RTEMS\_SYSINIT\_CLASSIC\_MESSAGE\_QUEUE**

Initialization of the Classic Message Queue object class. This step is optional and depends on the application configuration.

### **RTEMS\_SYSINIT\_CLASSIC\_SEMAPHORE**

Initialization of the Classic Semaphore object class. This step is optional and depends on the application configuration.

#### **RTEMS\_SYSINIT\_CLASSIC\_SEMAPHORE\_MP**

In MPCI configurations, the Classic Semaphore MPCI support is initialized in this step. This step is optional and depends on the application configuration.

#### **RTEMS\_SYSINIT\_CLASSIC\_PARTITION**

Initialization of the Classic Partition object class. This step is optional and depends on the application configuration.

#### **RTEMS\_SYSINIT\_CLASSIC\_PARTITION\_MP**

In MPCI configurations, the Classic Partition MPCI support is initialized in this step. This step is optional and depends on the application configuration.

## **RTEMS\_SYSINIT\_CLASSIC\_REGION**

Initialization of the Classic Region object class. This step is optional and depends on the application configuration.

#### **RTEMS\_SYSINIT\_CLASSIC\_DUAL\_PORTED\_MEMORY**

Initialization of the Classic Dual-Ported Memory object class. This step is optional and depends on the application configuration.

#### **RTEMS\_SYSINIT\_CLASSIC\_RATE\_MONOTONIC**

Initialization of the Classic Rate-Monotonic object class. This step is optional and depends on the application configuration.

#### **RTEMS\_SYSINIT\_CLASSIC\_BARRIER**

Initialization of the Classic Barrier object class. This step is optional and depends on the application configuration.

## **RTEMS\_SYSINIT\_POSIX\_SIGNALS**

Initialization of the POSIX Signals support. This step is optional and depends on the application configuration.

#### **RTEMS\_SYSINIT\_POSIX\_THREADS**

Initialization of the POSIX Threads object class. This step is optional and depends on the application configuration.

## **RTEMS\_SYSINIT\_POSIX\_MESSAGE\_QUEUE**

Initialization of the POSIX Message Queue object class. This step is optional and depends on the application configuration.

#### **RTEMS\_SYSINIT\_POSIX\_SEMAPHORE**

Initialization of the POSIX Semaphore object class. This step is optional and depends on the application configuration.

#### **RTEMS\_SYSINIT\_POSIX\_TIMER**

Initialization of the POSIX Timer object class. This step is optional and depends on the application configuration.

#### **RTEMS\_SYSINIT\_POSIX\_SHM**

Initialization of the POSIX Shared Memory object class. This step is optional and depends on the application configuration.

#### **RTEMS\_SYSINIT\_POSIX\_KEYS**

Initialization of the POSIX Keys object class. This step is optional and depends on the application configuration.

#### **RTEMS\_SYSINIT\_POSIX\_CLEANUP**

Initialization of the POSIX Cleanup support. This step is optional and depends on the application configuration.

#### **RTEMS\_SYSINIT\_IDLE\_THREADS**

Initialization of idle threads. This step is mandatory.

#### **RTEMS\_SYSINIT\_LIBIO**

Initialization of IO library. This step is optional and depends on the application configuration.

## **RTEMS\_SYSINIT\_ROOT\_FILESYSTEM**

Initialization of the root filesystem. This step is optional and depends on the application configuration.

## **RTEMS\_SYSINIT\_DRVMGR**

Driver manager initialization. This step is optional and depends on the application configuration. Only available if the driver manager is enabled.

#### **RTEMS\_SYSINIT\_MP\_SERVER**

In MPCI configurations, the MPCI server is initialized in this step. This step is mandatory in MPCI configurations.

## **RTEMS\_SYSINIT\_BSP\_PRE\_DRIVERS**

Initialization step performed right before device drivers are initialized. This step is mandatory.

#### **RTEMS\_SYSINIT\_DRVMGR\_LEVEL\_1**

Driver manager level 1 initialization. This step is optional and depends on the application configuration. Only available if the driver manager is enabled.

## **RTEMS\_SYSINIT\_DEVICE\_DRIVERS**

This step initializes all statically configured device drivers and performs all RTEMS initialization which requires device drivers to be initialized. This step is mandatory. In a multiprocessor configuration, this service will initialize the Multiprocessor Communications Interface (MPCI) and synchronize with the other nodes in the system.

#### **RTEMS\_SYSINIT\_DRVMGR\_LEVEL\_2**

Driver manager level 2 initialization. This step is optional and depends on the application configuration. Only available if the driver manager is enabled.

## **RTEMS\_SYSINIT\_DRVMGR\_LEVEL\_3**

Driver manager level 3 initialization. This step is optional and depends on the application configuration. Only available if the driver manager is enabled.

#### **RTEMS\_SYSINIT\_DRVMGR\_LEVEL\_4**

Driver manager level 4 initialization. This step is optional and depends on the application configuration. Only available if the driver manager is enabled.

7.3. Operations 91

### <span id="page-119-1"></span>**RTEMS\_SYSINIT\_MP\_FINALIZE**

Finalize MPCI initialization. This step is mandatory on MPCI configurations.

#### **RTEMS\_SYSINIT\_CLASSIC\_USER\_TASKS**

Creates and starts the Classic initialization tasks. This step is optional and depends on the application configuration.

## **RTEMS\_SYSINIT\_POSIX\_USER\_THREADS**

Creates POSIX initialization threads. This step is optional and depends on the application configuration.

## **RTEMS\_SYSINIT\_STD\_FILE\_DESCRIPTORS**

Open the standard input, output and error file descriptors. This step is optional and depends on the application configuration.

The final action of the rtems\_initialize\_executive() directive is to start multitasking and switch to the highest priority ready thread. RTEMS does not return to the initialization context and the initialization stack may be re-used for interrupt processing.

Many of RTEMS actions during initialization are based upon the contents of the Configuration Table. For more information regarding the format and contents of this table, please refer to the chapter *[Configuring a System](#page-584-0)* (page 557).

## <span id="page-119-0"></span>7.3.2 Global Construction

The *[global construction](#page-1065-2)* is carried out by the Classic API initialization task. If no Classic API initialization task exists, then it is carried out by the POSIX API initialization thread. If no initialization task or thread exists, then no global construction is performed. The Classic API task or POSIX API thread which carries out global construction is called the main thread. For configuration options related to initialization tasks, see *[CON-](#page-663-0)[FIGURE\\_RTEMS\\_INIT\\_TASKS\\_TABLE](#page-663-0)* (page 636), *[CONFIGURE\\_POSIX\\_INIT\\_THREAD\\_TABLE](#page-677-0)* (page 650), and *[CONFIGURE\\_IDLE\\_TASK\\_INITIALIZES\\_APPLICATION](#page-737-0)* (page 710).

Global construction runs before the *[task entry](#page-1076-1)* of the main thread. The configuration of the main thread must take the global construction into account. In particular, the main thread stack size, priority, attributes and initial modes must be set accordingly. Thread-local objects and POSIX key values created during global construction are accessible by the main thread. If other initialization tasks are configured, and one of them has a higher priority than the main thread and the main thread is preemptible, this task executes before the global construction. In case the main thread blocks during global construction, then other tasks may run. In SMP configurations, other initialization tasks may run in parallel with global construction. Tasks created during global construction may preempt the main thread or run in parallel in SMP configurations. All RTEMS services allowed in task context are allowed during global construction.

Global constructors are C++ global object constructors or functions with the constructor attribute. For example, the following test program

```
1 #include <stdio.h>
2 #include <assert.h>
3
4 class A {
5 public:
6 A()
7 {
8 puts( "A:A()" );
```

(continues on next page)

(continued from previous page)

```
9 }
10 };
11
12 static A a;
13
14 static thread_local int i;
15
16 static thread_local int j;
17
18 static __attribute__(( __constructor__ )) void b( void )
19 {
20 i = 1;
21 puts( "b()" );
22 }
23
24 static __attribute__(( __constructor__( 1000 ) )) void c( void )
25 {
26 puts( "c()" );
27 }
28
29 int main( void )
30 {
31 assert( i == 1 );
32 assert( j == 0 );
33 return 0;
34 }
```

#### should output:

```
1 c()
2 b()
3 A:A()
```

7.3. Operations 93

# <span id="page-121-0"></span>7.4 Directives

This section details the directives of the Initialization Manager. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

## <span id="page-122-1"></span><span id="page-122-0"></span>7.4.1 rtems\_initialize\_executive()

Initializes the system and starts multitasking.

## CALLING SEQUENCE:

```
1 void rtems_initialize_executive( void );
```

### DESCRIPTION:

Iterates through the system initialization linker set and invokes the registered handlers. The final step is to start multitasking.

#### NOTES:

Errors in the initialization sequence are usually fatal and lead to a system termination.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive should be called by boot\_card() only.
- The directive will not return to the caller.

7.4. Directives 95

CHAPTER

**EIGHT**

# <span id="page-124-0"></span>TASK MANAGER

# <span id="page-125-0"></span>8.1 Introduction

The Task Manager provides a comprehensive set of directives to create, delete, and administer tasks. The directives provided by the Task Manager are:

- *[rtems\\_task\\_create\(\)](#page-136-0)* (page 109) Creates a task.
- *[rtems\\_task\\_construct\(\)](#page-140-0)* (page 113) Constructs a task from the specified task configuration.
- *[rtems\\_task\\_ident\(\)](#page-142-0)* (page 115) Identifies a task by the object name.
- *[rtems\\_task\\_self\(\)](#page-144-0)* (page 117) Gets the task identifier of the calling task.
- *[rtems\\_task\\_start\(\)](#page-145-0)* (page 118) Starts the task.
- *[rtems\\_task\\_restart\(\)](#page-147-0)* (page 120) Restarts the task.
- *[rtems\\_task\\_delete\(\)](#page-149-0)* (page 122) Deletes the task.
- *[rtems\\_task\\_exit\(\)](#page-151-0)* (page 124) Deletes the calling task.
- *[rtems\\_task\\_suspend\(\)](#page-152-0)* (page 125) Suspends the task.
- *[rtems\\_task\\_resume\(\)](#page-153-0)* (page 126) Resumes the task.
- *[rtems\\_task\\_is\\_suspended\(\)](#page-154-0)* (page 127) Checks if the task is suspended.
- *[rtems\\_task\\_set\\_priority\(\)](#page-155-0)* (page 128) Sets the real priority or gets the current priority of the task.
- *[rtems\\_task\\_get\\_priority\(\)](#page-157-0)* (page 130) Gets the current priority of the task with respect to the scheduler.
- *[rtems\\_task\\_mode\(\)](#page-159-0)* (page 132) Gets and optionally sets the mode of the calling task.
- *[rtems\\_task\\_wake\\_after\(\)](#page-161-0)* (page 134) Wakes up after a count of *[clock ticks](#page-1062-1)* have occurred or yields the processor.
- *[rtems\\_task\\_wake\\_when\(\)](#page-162-0)* (page 135) Wakes up when specified.
- *[rtems\\_task\\_get\\_scheduler\(\)](#page-163-0)* (page 136) Gets the home scheduler of the task.
- *[rtems\\_task\\_set\\_scheduler\(\)](#page-164-0)* (page 137) Sets the home scheduler for the task.
- *[rtems\\_task\\_get\\_affinity\(\)](#page-166-0)* (page 139) Gets the processor affinity of the task.
- *[rtems\\_task\\_set\\_affinity\(\)](#page-168-0)* (page 141) Sets the processor affinity of the task.
- *[rtems\\_task\\_iterate\(\)](#page-170-0)* (page 143) Iterates over all tasks and invokes the visitor routine for each task.
- *[RTEMS\\_TASK\\_STORAGE\\_SIZE\(\)](#page-171-0)* (page 144) Gets the recommended task storage area size for the size and task attributes.

# <span id="page-126-4"></span><span id="page-126-0"></span>8.2 Background

## <span id="page-126-1"></span>8.2.1 Task Definition

Many definitions of a task have been proposed in computer literature. Unfortunately, none of these definitions encompasses all facets of the concept in a manner which is operating system independent. Several of the more common definitions are provided to enable each user to select a definition which best matches their own experience and understanding of the task concept:

- a "dispatchable" unit.
- an entity to which the processor is allocated.
- an atomic unit of a real-time, multiprocessor system.
- single threads of execution which concurrently compete for resources.
- a sequence of closely related computations which can execute concurrently with other computational sequences.

From RTEMS' perspective, a task is the smallest thread of execution which can compete on its own for system resources. A task is manifested by the existence of a task control block (TCB).

## <span id="page-126-2"></span>8.2.2 Task Control Block

The Task Control Block (TCB) is an RTEMS defined data structure which contains all the information that is pertinent to the execution of a task. During system initialization, RTEMS reserves a TCB for each task configured. A TCB is allocated upon creation of the task and is returned to the TCB free list upon deletion of the task.

The TCB's elements are modified as a result of system calls made by the application in response to external and internal stimuli. TCBs are the only RTEMS internal data structure that can be accessed by an application via user extension routines. The TCB contains a task's name, ID, current priority, current and starting states, execution mode, TCB user extension pointer, scheduling control structures, as well as data required by a blocked task.

A task's context is stored in the TCB when a task switch occurs. When the task regains control of the processor, its context is restored from the TCB. When a task is restarted, the initial state of the task is restored from the starting context area in the task's TCB.

## <span id="page-126-3"></span>8.2.3 Task Memory

The system uses two separate memory areas to manage a task. One memory area is the *[Task](#page-126-2) [Control Block](#page-126-2)* (page 99). The other memory area is allocated from the stack space or provided by the user and contains

- the task stack,
- the thread-local storage (*[TLS](#page-1077-2)*), and
- an optional architecture-specific floating-point context.

The size of the thread-local storage is determined at link time. A user-provided task stack must take the size of the thread-local storage into account.

On architectures with a dedicated floating-point context, the application configuration assumes that every task is a floating-point task, but whether or not a task is actually floating-point is determined at runtime during task creation (see *[Floating Point Considerations](#page-130-0)* (page 103)). In highly memory constrained systems this potential overestimate of the task stack space can

8.2. Background 99

<span id="page-127-3"></span>be mitigated through the *[CONFIGURE\\_MINIMUM\\_TASK\\_STACK\\_SIZE](#page-613-0)* (page 586) configuration option and aligned task stack sizes for the tasks. A user-provided task stack must take the potential floating-point context into account.

## <span id="page-127-0"></span>8.2.4 Task Name

By default, the task name is defined by the task object name given to rtems\_task\_create(). The task name can be obtained with the [pthread\\_getname\\_np\(\)](http://man7.org/linux/man-pages/man3/pthread_setname_np.3.html) function. Optionally, a new task name may be set with the [pthread\\_setname\\_np\(\)](http://man7.org/linux/man-pages/man3/pthread_setname_np.3.html) function. The maximum size of a task name is defined by the application configuration option *[CONFIGURE\\_MAXIMUM\\_THREAD\\_NAME\\_SIZE](#page-608-0)* (page 581).

## <span id="page-127-1"></span>8.2.5 Task States

A task may exist in one of the following five states:

- *executing* Currently scheduled to the CPU
- *ready* May be scheduled to the CPU
- *blocked* Unable to be scheduled to the CPU
- *dormant* Created task that is not started
- *non-existent* Uncreated or deleted task

An active task may occupy the executing, ready, blocked or dormant state, otherwise the task is considered non-existent. One or more tasks may be active in the system simultaneously. Multiple tasks communicate, synchronize, and compete for system resources with each other via system calls. The multiple tasks appear to execute in parallel, but actually each is dispatched to the CPU for periods of time determined by the RTEMS scheduling algorithm. The scheduling of a task is based on its current state and priority.

## <span id="page-127-2"></span>8.2.6 Task Priority

A task's *[priority](#page-1071-1)* determines its importance in relation to the other tasks executing on the processor set owned by a *[scheduler](#page-1073-0)*. Normally, RTEMS supports 256 levels of priority ranging from 0 to 255. The priority level 0 represents a special priority reserved for the operating system. The data type rtems\_task\_priority is used to store task priorities. The maximum priority level depends on the configured scheduler, see *[CONFIGURE\\_MAXIMUM\\_PRIORITY](#page-742-0)* (page 715), *[Clustered Scheduler Configuration](#page-756-0)* (page 729), and *[Scheduling Concepts](#page-88-0)* (page 61).

Tasks of numerically smaller priority values are more important tasks than tasks of numerically larger priority values. For example, a task at priority level 5 is of higher privilege than a task at priority level 10. There is no limit to the number of tasks assigned to the same priority.

Each task has a priority associated with it at all times. The initial value of this priority is assigned at task creation time. The priority of a task may be changed at any subsequent time.

Priorities are used by the scheduler to determine which ready task will be allowed to execute. In general, the higher the logical priority of a task, the more likely it is to receive processor execution time.

## <span id="page-128-1"></span><span id="page-128-0"></span>8.2.7 Task Mode

A task's execution mode is a combination of the following four components:

- preemption
- ASR processing
- timeslicing
- interrupt level

It is used to modify RTEMS' scheduling process and to alter the execution environment of the task. The data type rtems\_task\_mode is used to manage the task execution mode.

The preemption component allows a task to determine when control of the processor is relinquished. If preemption is disabled (RTEMS\_NO\_PREEMPT), the task will retain control of the processor as long as it is in the executing state - even if a higher priority task is made ready. If preemption is enabled (RTEMS\_PREEMPT) and a higher priority task is made ready, then the processor will be taken away from the current task immediately and given to the higher priority task.

The timeslicing component is used by the RTEMS scheduler to determine how the processor is allocated to tasks of equal priority. If timeslicing is enabled (RTEMS\_TIMESLICE), then RTEMS will limit the amount of time the task can execute before the processor is allocated to another ready task of equal priority. The length of the timeslice is application dependent and specified in the Configuration Table. If timeslicing is disabled (RTEMS\_NO\_TIMESLICE), then the task will be allowed to execute until a task of higher priority is made ready. If RTEMS\_NO\_PREEMPT is selected, then the timeslicing component is ignored by the scheduler.

The asynchronous signal processing component is used to determine when received signals are to be processed by the task. If signal processing is enabled (RTEMS\_ASR), then signals sent to the task will be processed the next time the task executes. If signal processing is disabled (RTEMS\_NO\_ASR), then all signals received by the task will remain posted until signal processing is enabled. This component affects only tasks which have established a routine to process asynchronous signals.

The interrupt level component is used to determine which interrupts will be enabled when the task is executing. RTEMS\_INTERRUPT\_LEVEL(n) specifies that the task will execute at interrupt level n.

| RTEMS_PREEMPT            | enable preemption (default)     |
|--------------------------|---------------------------------|
| RTEMS_NO_PREEMPT         | disable preemption              |
| RTEMS_NO_TIMESLICE       | disable timeslicing (default)   |
| RTEMS_TIMESLICE          | enable timeslicing              |
| RTEMS_ASR                | enable ASR processing (default) |
| RTEMS_NO_ASR             | disable ASR processing          |
| RTEMS_INTERRUPT_LEVEL(0) | enable all interrupts (default) |
| RTEMS_INTERRUPT_LEVEL(n) | execute at interrupt level n    |
|                          |                                 |

The set of default modes may be selected by specifying the RTEMS\_DEFAULT\_MODES constant.

8.2. Background 101

## <span id="page-129-2"></span><span id="page-129-0"></span>8.2.8 Task Life States

Independent of the task state with respect to the scheduler, the task life is determined by several orthogonal states:

- *protected* or *unprotected*
- *deferred life changes* or *no deferred life changes*
- *restarting* or *not restarting*
- *terminating* or *not terminating*
- *detached* or *not detached*

While the task life is *protected*, asynchronous task restart and termination requests are blocked. A task may still restart or terminate itself. All tasks are created with an unprotected task life. The task life protection is used by the system to prevent system resources being affected by asynchronous task restart and termination requests. The task life protection can be enabled (PTHREAD\_CANCEL\_DISABLE) or disabled (PTHREAD\_CANCEL\_ENABLE) for the calling task through the pthread\_setcancelstate() directive.

While *deferred life changes* are enabled, asynchronous task restart and termination requests are delayed until the task performs a life change itself or calls pthread\_testcancel(). Cancellation points are not implemented in RTEMS. Deferred task life changes can be enabled (PTHREAD\_CANCEL\_DEFERRED) or disabled (PTHREAD\_CANCEL\_ASYNCHRONOUS) for the calling task through the pthread\_setcanceltype() directive. Classic API tasks are created with deferred life changes disabled. POSIX threads are created with deferred life changes enabled.

A task is made *restarting* by issuing a task restart request through the *[rtems\\_task\\_restart\(\)](#page-147-0)* (page 120) directive.

A task is made *terminating* by issuing a task termination request through the *[rtems\\_task\\_exit\(\)](#page-151-0)* (page 124), *[rtems\\_task\\_delete\(\)](#page-149-0)* (page 122), pthread\_exit(), and pthread\_cancel() directives.

When a *detached* task terminates, the termination procedure completes without the need for another task to join with the terminated task. Classic API tasks are created as not detached. The detached state of created POSIX threads is determined by the thread attributes. They are created as not detached by default. The calling task is made detached through the pthread\_detach() directive. The *[rtems\\_task\\_exit\(\)](#page-151-0)* (page 124) directive and self deletion though *[rtems\\_task\\_delete\(\)](#page-149-0)* (page 122) directive make the calling task detached. In contrast, the pthread\_exit() directive does not change the detached state of the calling task.

## <span id="page-129-1"></span>8.2.9 Accessing Task Arguments

All RTEMS tasks are invoked with a single argument which is specified when they are started or restarted. The argument is commonly used to communicate startup information to the task. The simplest manner in which to define a task which accesses it argument is:

```
1 rtems_task user_task(
2 rtems_task_argument argument
3 );
```

Application tasks requiring more information may view this single argument as an index into an array of parameter blocks.

## <span id="page-130-2"></span><span id="page-130-0"></span>8.2.10 Floating Point Considerations

Please consult the *RTEMS CPU Architecture Supplement* if this section is relevant on your architecture. On some architectures the floating-point context is contained in the normal task context and this section does not apply.

Creating a task with the RTEMS\_FLOATING\_POINT attribute flag results in additional memory being allocated for the task to store the state of the numeric coprocessor during task switches. This additional memory is **not** allocated for RTEMS\_NO\_FLOATING\_POINT tasks. Saving and restoring the context of a RTEMS\_FLOATING\_POINT task takes longer than that of a RTEMS\_NO\_FLOATING\_POINT task because of the relatively large amount of time required for the numeric coprocessor to save or restore its computational state.

Since RTEMS was designed specifically for embedded military applications which are floating point intensive, the executive is optimized to avoid unnecessarily saving and restoring the state of the numeric coprocessor. In uniprocessor configurations, the state of the numeric coprocessor is only saved when a RTEMS\_FLOATING\_POINT task is dispatched and that task was not the last task to utilize the coprocessor. In a uniprocessor system with only one RTEMS\_FLOATING\_POINT task, the state of the numeric coprocessor will never be saved or restored.

Although the overhead imposed by RTEMS\_FLOATING\_POINT tasks is minimal, some applications may wish to completely avoid the overhead associated with RTEMS\_FLOATING\_POINT tasks and still utilize a numeric coprocessor. By preventing a task from being preempted while performing a sequence of floating point operations, a RTEMS\_NO\_FLOATING\_POINT task can utilize the numeric coprocessor without incurring the overhead of a RTEMS\_FLOATING\_POINT context switch. This approach also avoids the allocation of a floating point context area. However, if this approach is taken by the application designer, **no** tasks should be created as RTEMS\_FLOATING\_POINT tasks. Otherwise, the floating point context will not be correctly maintained because RTEMS assumes that the state of the numeric coprocessor will not be altered by RTEMS\_NO\_FLOATING\_POINT tasks. Some architectures with a dedicated floating-point context raise a processor exception if a task with RTEMS\_NO\_FLOATING\_POINT issues a floating-point instruction, so this approach may not work at all.

If the supported processor type does not have hardware floating capabilities or a standard numeric coprocessor, RTEMS will not provide built-in support for hardware floating point on that processor. In this case, all tasks are considered RTEMS\_NO\_FLOATING\_POINT whether created as RTEMS\_FLOATING\_POINT or RTEMS\_NO\_FLOATING\_POINT tasks. A floating point emulation software library must be utilized for floating point operations.

On some processors, it is possible to disable the floating point unit dynamically. If this capability is supported by the target processor, then RTEMS will utilize this capability to enable the floating point unit only for tasks which are created with the RTEMS\_FLOATING\_POINT attribute. The consequence of a RTEMS\_NO\_FLOATING\_POINT task attempting to access the floating point unit is CPU dependent but will generally result in an exception condition.

## <span id="page-130-1"></span>8.2.11 Building a Task Attribute Set

In general, an attribute set is built by a bitwise OR of the desired components. The set of valid task attribute components is listed below:

| RTEMS_NO_FLOATING_POINT | does not use coprocessor (default) |
|-------------------------|------------------------------------|
| RTEMS_FLOATING_POINT    | uses numeric coprocessor           |
| RTEMS_LOCAL             | local task (default)               |
| RTEMS_GLOBAL            | global task                        |

8.2. Background 103

<span id="page-131-1"></span>Attribute values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each attribute appears exactly once in the component list. A component listed as a default is not required to appear in the component list, although it is a good programming practice to specify default components. If all defaults are desired, then RTEMS\_DEFAULT\_ATTRIBUTES should be used.

This example demonstrates the attribute\_set parameter needed to create a local task which utilizes the numeric coprocessor. The attribute\_set parameter could be RTEMS\_FLOATING\_POINT or RTEMS\_LOCAL | RTEMS\_FLOATING\_POINT. The attribute\_set parameter can be set to RTEMS\_FLOATING\_POINT because RTEMS\_LOCAL is the default for all created tasks. If the task were global and used the numeric coprocessor, then the attribute\_set parameter would be RTEMS\_GLOBAL | RTEMS\_FLOATING\_POINT.

## <span id="page-131-0"></span>8.2.12 Building a Mode and Mask

In general, a mode and its corresponding mask is built by a bitwise OR of the desired components. The set of valid mode constants and each mode's corresponding mask constant is listed below:

| RTEMS_PREEMPT      | is masked by<br>RTEMS_PREEMPT_MASK<br>and enables preemption        |
|--------------------|---------------------------------------------------------------------|
| RTEMS_NO_PREEMPT   | is masked by<br>RTEMS_PREEMPT_MASK<br>and disables preemption       |
| RTEMS_NO_TIMESLICE | is masked by<br>RTEMS_TIMESLICE_MASK<br>and disables timeslicing    |
| RTEMS_TIMESLICE    | RTEMS_TIMESLICE_MASK<br>is masked by<br>and enables timeslicing     |
| RTEMS_ASR          | RTEMS_ASR_MASK<br>is masked by<br>and enables ASR processing        |
| RTEMS_NO_ASR       | RTEMS_ASR_MASK<br>is masked by<br>and disables ASR processing       |
| RTEMS_INTERRUPT_   | is masked by<br>RTEMS_INTERRUPT_MASK<br>and enables all interrupts  |
| LEVEL(0)           |                                                                     |
| RTEMS_INTERRUPT_   | is masked by<br>RTEMS_INTERRUPT_MASK<br>and sets interrupts level n |
| LEVEL(n)           |                                                                     |

Mode values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each mode appears exactly once in the component list. A mode component listed as a default is not required to appear in the mode component list, although it is a good programming practice to specify default components. If all defaults are desired, the mode RTEMS\_DEFAULT\_MODES and the mask RTEMS\_ALL\_MODE\_MASKS should be used.

The following example demonstrates the mode and mask parameters used with the rtems\_task\_mode directive to place a task at interrupt level 3 and make it non-preemptible. The mode should be set to RTEMS\_INTERRUPT\_LEVEL(3) | RTEMS\_NO\_PREEMPT to indicate the desired preemption mode and interrupt level, while the mask parameter should be set to RTEMS\_INTERRUPT\_MASK | RTEMS\_NO\_PREEMPT\_MASK to indicate that the calling task's interrupt level and preemption mode are being altered.

# <span id="page-132-0"></span>8.3 Operations

## <span id="page-132-1"></span>8.3.1 Creating Tasks

The rtems\_task\_create directive creates a task by allocating a task control block, assigning the task a user-specified name, allocating it a stack and floating point context area, setting a userspecified initial priority, setting a user-specified initial mode, and assigning it a task ID. Newly created tasks are initially placed in the dormant state. All RTEMS tasks execute in the most privileged mode of the processor.

# <span id="page-132-2"></span>8.3.2 Obtaining Task IDs

When a task is created, RTEMS generates a unique task ID and assigns it to the created task until it is deleted. The task ID may be obtained by either of two methods. First, as the result of an invocation of the rtems\_task\_create directive, the task ID is stored in a user provided location. Second, the task ID may be obtained later using the rtems\_task\_ident directive. The task ID is used by other directives to manipulate this task.

## <span id="page-132-3"></span>8.3.3 Starting and Restarting Tasks

The rtems\_task\_start directive is used to place a dormant task in the ready state. This enables the task to compete, based on its current priority, for the processor and other system resources. Any actions, such as suspension or change of priority, performed on a task prior to starting it are nullified when the task is started.

With the rtems\_task\_start directive the user specifies the task's starting address and argument. The argument is used to communicate some startup information to the task. As part of this directive, RTEMS initializes the task's stack based upon the task's initial execution mode and start address. The starting argument is passed to the task in accordance with the target processor's calling convention.

The rtems\_task\_restart directive restarts a task at its initial starting address with its original priority and execution mode, but with a possibly different argument. The new argument may be used to distinguish between the original invocation of the task and subsequent invocations. The task's stack and control block are modified to reflect their original creation values. Although references to resources that have been requested are cleared, resources allocated by the task are NOT automatically returned to RTEMS. A task cannot be restarted unless it has previously been started (i.e. dormant tasks cannot be restarted). All restarted tasks are placed in the ready state.

## <span id="page-132-4"></span>8.3.4 Suspending and Resuming Tasks

The rtems\_task\_suspend directive is used to place either the caller or another task into a suspended state. The task remains suspended until a rtems\_task\_resume directive is issued. This implies that a task may be suspended as well as blocked waiting either to acquire a resource or for the expiration of a timer.

The rtems\_task\_resume directive is used to remove another task from the suspended state. If the task is not also blocked, resuming it will place it in the ready state, allowing it to once again compete for the processor and resources. If the task was blocked as well as suspended, this directive clears the suspension and leaves the task in the blocked state.

Suspending a task which is already suspended or resuming a task which is not suspended is considered an error. The rtems\_task\_is\_suspended can be used to determine if a task is currently suspended.

8.3. Operations 105

## <span id="page-133-0"></span>8.3.5 Delaying the Currently Executing Task

The rtems\_task\_wake\_after directive creates a sleep timer which allows a task to go to sleep for a specified count of clock ticks. The task is blocked until the count of clock ticks has elapsed, at which time the task is unblocked. A task calling the rtems\_task\_wake\_after directive with a delay of RTEMS\_YIELD\_PROCESSOR ticks will yield the processor to any other ready task of equal or greater priority and remain ready to execute.

The rtems\_task\_wake\_when directive creates a sleep timer which allows a task to go to sleep until a specified date and time. The calling task is blocked until the specified date and time has occurred, at which time the task is unblocked.

## <span id="page-133-1"></span>8.3.6 Changing Task Priority

The rtems\_task\_set\_priority directive is used to obtain or change the current priority of either the calling task or another task. If the new priority requested is RTEMS\_CURRENT\_PRIORITY or the task's actual priority, then the current priority will be returned and the task's priority will remain unchanged. If the task's priority is altered, then the task will be scheduled according to its new priority.

The rtems\_task\_restart directive resets the priority of a task to its original value.

## <span id="page-133-2"></span>8.3.7 Changing Task Mode

The rtems\_task\_mode directive is used to obtain or change the current execution mode of the calling task. A task's execution mode is used to enable preemption, timeslicing, ASR processing, and to set the task's interrupt level.

The rtems\_task\_restart directive resets the mode of a task to its original value.

## <span id="page-133-3"></span>8.3.8 Task Deletion

RTEMS provides the rtems\_task\_delete directive to allow a task to delete itself or any other task. This directive removes all RTEMS references to the task, frees the task's control block, removes it from resource wait queues, and deallocates its stack as well as the optional floating point context. The task's name and ID become inactive at this time, and any subsequent references to either of them is invalid. In fact, RTEMS may reuse the task ID for another task which is created later in the application. A specialization of rtems\_task\_delete is rtems\_task\_exit which deletes the calling task.

Unexpired delay timers (i.e. those used by rtems\_task\_wake\_after and rtems\_task\_wake\_when) and timeout timers associated with the task are automatically deleted, however, other resources dynamically allocated by the task are NOT automatically returned to RTEMS. Therefore, before a task is deleted, all of its dynamically allocated resources should be deallocated by the user. This may be accomplished by instructing the task to delete itself rather than directly deleting the task. Other tasks may instruct a task to delete itself by sending a "delete self" message, event, or signal, or by restarting the task with special arguments which instruct the task to delete itself.

## <span id="page-133-4"></span>8.3.9 Setting Affinity to a Single Processor

On some embedded applications targeting SMP systems, it may be beneficial to lock individual tasks to specific processors. In this way, one can designate a processor for I/O tasks, another for computation, etc. . . The following illustrates the code sequence necessary to assign a task an affinity for processor with index processor\_index.

```
1 #include <rtems.h>
2 #include <assert.h>
3
4 void pin_to_processor(rtems_id task_id, int processor_index)
5 {
6 rtems_status_code sc;
7 cpu_set_t cpuset;
8 CPU_ZERO(&cpuset);
9 CPU_SET(processor_index, &cpuset);
10 sc = rtems_task_set_affinity(task_id, sizeof(cpuset), &cpuset);
11 assert(sc == RTEMS_SUCCESSFUL);
12 }
```

It is important to note that the cpuset is not validated until the rtems\_task\_set\_affinity call is made. At that point, it is validated against the current system configuration.

## <span id="page-134-0"></span>8.3.10 Transition Advice for Removed Notepads

Task notepads and the associated directives *[TASK\\_GET\\_NOTE - Get task notepad entry](#page-175-0)* (page 148) and *[TASK\\_SET\\_NOTE - Set task notepad entry](#page-176-0)* (page 149) were removed in RTEMS 5.1. These were never thread-safe to access and subject to conflicting use of the notepad index by libraries which were designed independently.

It is recommended that applications be modified to use services which are thread safe and not subject to issues with multiple applications conflicting over the key (e.g. notepad index) selection. For most applications, POSIX Keys should be used. These are available in all RTEMS build configurations. It is also possible that thread-local storage (TLS) is an option for some use cases.

## <span id="page-134-1"></span>8.3.11 Transition Advice for Removed Task Variables

Task notepads and the associated directives *[TASK\\_VARIABLE\\_ADD - Associate per task vari](#page-177-0)[able](#page-177-0)* (page 150), *[TASK\\_VARIABLE\\_GET - Obtain value of a per task variable](#page-178-0)* (page 151) and *[TASK\\_VARIABLE\\_DELETE - Remove per task variable](#page-179-0)* (page 152) were removed in RTEMS 5.1. Task variables must be replaced by POSIX Keys or thread-local storage (TLS). POSIX Keys are available in all configurations and support value destructors. For the TLS support consult the *RTEMS CPU Architecture Supplement*.

8.3. Operations 107

# <span id="page-135-0"></span>8.4 Directives

This section details the directives of the Task Manager. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

## <span id="page-136-1"></span><span id="page-136-0"></span>8.4.1 rtems\_task\_create()

Creates a task.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_task_create(
2 rtems_name name,
3 rtems_task_priority initial_priority,
4 size_t stack_size,
5 rtems_mode initial_modes,
6 rtems_attribute attribute_set,
7 rtems_id *id
8 );
```

#### PARAMETERS:

#### **name**

This parameter is the object name of the task.

## **initial\_priority**

This parameter is the initial task priority.

#### **stack\_size**

This parameter is the task stack size in bytes.

#### **initial\_modes**

This parameter is the initial mode set of the task.

## **attribute\_set**

This parameter is the attribute set of the task.

**id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the identifier of the created task will be stored in this object.

#### DESCRIPTION:

This directive creates a task which resides on the local node. The task has the user-defined object name specified in name. The assigned object identifier is returned in id. This identifier is used to access the task with other task related directives.

The **initial priority** of the task is specified in initial\_priority. The *[home scheduler](#page-1066-0)* of the created task is the home scheduler of the calling task at some time point during the task creation. The initial task priority specified in initial\_priority shall be valid for this scheduler.

The **stack size** of the task is specified in stack\_size. If the requested stack size is less than the configured minimum stack size, then RTEMS will use the configured minimum as the stack size for this task. The configured minimum stack size is defined by the *[CONFIG-](#page-613-0)[URE\\_MINIMUM\\_TASK\\_STACK\\_SIZE](#page-613-0)* (page 586) application configuration option. In addition to being able to specify the task stack size as a integer, there are two constants which may be specified:

â€¢ The RTEMS\_MINIMUM\_STACK\_SIZE constant can be specified to use the **recommended minimum stack size** for the target processor. This value is selected by the RTEMS maintainers conservatively to minimize the risk of blown stacks for most user applications. Using this

8.4. Directives 109

constant when specifying the task stack size, indicates that the stack size will be at least RTEMS\_MINIMUM\_STACK\_SIZE bytes in size. If the user configured minimum stack size is larger than the recommended minimum, then it will be used.

â€¢ The RTEMS\_CONFIGURED\_MINIMUM\_STACK\_SIZE constant can be specified to use the minimum stack size that was configured by the application. If not explicitly configured by the application, the default configured minimum stack size is the target processor dependent value RTEMS\_MINIMUM\_STACK\_SIZE. Since this uses the configured minimum stack size value, you may get a stack size that is smaller or larger than the recommended minimum. This can be used to provide large stacks for all tasks on complex applications or small stacks on applications that are trying to conserve memory.

The **initial mode set** specified in initial\_modes is built through a *bitwise or* of the mode constants described below. Not all combinations of modes are allowed. Some modes are mutually exclusive. If mutually exclusive modes are combined, the behaviour is undefined. Default task modes can be selected by using the RTEMS\_DEFAULT\_MODES constant. The task mode set defines

- the preemption mode of the task: RTEMS\_PREEMPT (default) or RTEMS\_NO\_PREEMPT,
- the timeslicing mode of the task: RTEMS\_TIMESLICE or RTEMS\_NO\_TIMESLICE (default),
- the *[ASR](#page-1060-2)* processing mode of the task: RTEMS\_ASR (default) or RTEMS\_NO\_ASR,
- the interrupt level of the task: RTEMS\_INTERRUPT\_LEVEL() with a default of RTEMS\_INTERRUPT\_LEVEL( 0 ) which is associated with enabled interrupts.

The **initial preemption mode** of the task is enabled or disabled.

- An **enabled preemption** is the default and can be emphasized through the use of the RTEMS\_PREEMPT mode constant.
- A **disabled preemption** is set by the RTEMS\_NO\_PREEMPT mode constant.

The **initial timeslicing mode** of the task is enabled or disabled.

- A **disabled timeslicing** is the default and can be emphasized through the use of the RTEMS\_NO\_TIMESLICE mode constant.
- An **enabled timeslicing** is set by the RTEMS\_TIMESLICE mode constant.

The **initial ASR processing mode** of the task is enabled or disabled.

- An **enabled ASR processing** is the default and can be emphasized through the use of the RTEMS\_ASR mode constant.
- A **disabled ASR processing** is set by the RTEMS\_NO\_ASR mode constant.

The **initial interrupt level mode** of the task is defined by RTEMS\_INTERRUPT\_LEVEL().

- Task execution with **interrupts enabled** the default and can be emphasized through the use of the RTEMS\_INTERRUPT\_LEVEL() mode macro with a value of zero (0) for the parameter. An interrupt level of zero is associated with enabled interrupts on all target processors.
- Task execution at a **non-zero interrupt level** can be specified by the RTEMS\_INTERRUPT\_LEVEL() mode macro with a non-zero value for the parameter. The interrupt level portion of the task mode supports a maximum of 256 interrupt levels. These levels are mapped onto the interrupt levels actually supported by the target processor in a processor dependent fashion.

The **attribute set** specified in attribute\_set is built through a *bitwise or* of the attribute constants described below. Not all combinations of attributes are allowed. Some attributes are mutually exclusive. If mutually exclusive attributes are combined, the behaviour is undefined. Attributes not mentioned below are not evaluated by this directive and have no effect. Default attributes can be selected by using the RTEMS\_DEFAULT\_ATTRIBUTES constant. The attribute set defines

- the scope of the task: RTEMS\_LOCAL (default) or RTEMS\_GLOBAL and
- the floating-point unit use of the task: RTEMS\_FLOATING\_POINT or RTEMS\_NO\_FLOATING\_POINT (default).

The task has a local or global **scope** in a multiprocessing network (this attribute does not refer to SMP systems). The scope is selected by the mutually exclusive RTEMS\_LOCAL and RTEMS\_GLOBAL attributes.

- A **local scope** is the default and can be emphasized through the use of the RTEMS\_LOCAL attribute. A local task can be only used by the node which created it.
- A **global scope** is established if the RTEMS\_GLOBAL attribute is set. Setting the global attribute in a single node system has no effect.the

The **use of the floating-point unit** is selected by the mutually exclusive RTEMS\_FLOATING\_POINT and RTEMS\_NO\_FLOATING\_POINT attributes. On some target processors, the use of the floatingpoint unit can be enabled or disabled for each task. Other target processors may have no hardware floating-point unit or enable the use of the floating-point unit for all tasks. Consult the *RTEMS CPU Architecture Supplement* for the details.

- A **disabled floating-point unit** is the default and can be emphasized through use of the RTEMS\_NO\_FLOATING\_POINT attribute. For performance reasons, it is recommended that tasks not using the floating-point unit should specify this attribute.
- An **enabled floating-point unit** is selected by the RTEMS\_FLOATING\_POINT attribute.

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_NAME**

The name parameter was invalid.

#### **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_PRIORITY**

The initial\_priority was invalid.

## **RTEMS\_TOO\_MANY**

There was no inactive object available to create a task. The number of tasks available to the application is configured through the *[CONFIGURE\\_MAXIMUM\\_TASKS](#page-650-0)* (page 623) application configuration option.

#### **RTEMS\_TOO\_MANY**

In multiprocessing configurations, there was no inactive global object available to create a global task. The number of global objects available to the application is configured through the *[CONFIGURE\\_MP\\_MAXIMUM\\_GLOBAL\\_OBJECTS](#page-765-0)* (page 738) application configuration option.

8.4. Directives 111

#### **RTEMS\_UNSATISFIED**

There was not enough memory to allocate the task storage area. The task storage area contains the task stack, the thread-local storage, and the floating point context.

#### **RTEMS\_UNSATISFIED**

One of the task create extensions failed to create the task.

#### **RTEMS\_UNSATISFIED**

In SMP configurations, the non-preemption mode was not supported.

## **RTEMS\_UNSATISFIED**

In SMP configurations, the interrupt level mode was not supported.

#### NOTES:

The task processor affinity is initialized to the set of online processors.

When created, a task is placed in the dormant state and can only be made ready to execute using the directive *[rtems\\_task\\_start\(\)](#page-145-0)* (page 118).

Application developers should consider the stack usage of the device drivers when calculating the stack size required for tasks which utilize the driver. The task stack size shall account for an target processor dependent interrupt stack frame which may be placed on the stack of the interrupted task while servicing an interrupt. The stack checker may be used to monitor the stack usage, see *[CONFIGURE\\_STACK\\_CHECKER\\_ENABLED](#page-614-0)* (page 587).

For control and maintenance of the task, RTEMS allocates a *[TCB](#page-1077-1)* from the local TCB free pool and initializes it.

The TCB for a global task is allocated on the local node. Task should not be made global unless remote tasks must interact with the task. This is to avoid the system overhead incurred by the creation of a global task. When a global task is created, the task's name and identifier must be transmitted to every node in the system for insertion in the local copy of the global object table.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- When the directive operates on a global object, the directive sends a message to remote nodes. This may preempt the calling task.
- The number of tasks available to the application is configured through the *[CONFIG-](#page-650-0)[URE\\_MAXIMUM\\_TASKS](#page-650-0)* (page 623) application configuration option.
- Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace.
- The number of global objects available to the application is configured through the *[CON-](#page-765-0)[FIGURE\\_MP\\_MAXIMUM\\_GLOBAL\\_OBJECTS](#page-765-0)* (page 738) application configuration option.

## <span id="page-140-1"></span><span id="page-140-0"></span>8.4.2 rtems\_task\_construct()

Constructs a task from the specified task configuration.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_task_construct(
2 const rtems_task_config *config,
3 rtems_id *id
4 );
```

#### PARAMETERS:

#### **config**

This parameter is the pointer to an *[rtems\\_task\\_config](#page-81-3)* (page 54) object. It configures the task.

#### **id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the identifier of the constructed task will be stored in this object.

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The config parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_NAME**

The task name was invalid.

## **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_PRIORITY**

The initial task priority was invalid.

#### **RTEMS\_INVALID\_SIZE**

The thread-local storage size is greater than the maximum thread-local storage size specified in the task configuration. The thread-local storage size is determined by the thread-local variables used by the application and *[CONFIGURE\\_MAXIMUM\\_THREAD\\_LOCAL\\_STORAGE\\_SIZE](#page-607-0)* (page 580).

#### **RTEMS\_INVALID\_SIZE**

The task storage area was too small to provide a task stack of the configured minimum size, see *[CONFIGURE\\_MINIMUM\\_TASK\\_STACK\\_SIZE](#page-613-0)* (page 586). The task storage area contains the task stack, the thread-local storage, and the floating-point context on architectures with a separate floating-point context.

## **RTEMS\_TOO\_MANY**

There was no inactive task object available to construct a task.

#### **RTEMS\_TOO\_MANY**

In multiprocessing configurations, there was no inactive global object available to construct a global task.

8.4. Directives 113

#### **RTEMS\_UNSATISFIED**

One of the task create extensions failed during the task construction.

#### **RTEMS\_UNSATISFIED**

In SMP configurations, the non-preemption mode was not supported.

#### **RTEMS\_UNSATISFIED**

In SMP configurations, the interrupt level mode was not supported.

## NOTES:

In contrast to tasks created by *[rtems\\_task\\_create\(\)](#page-136-0)* (page 109), the tasks constructed by this directive use a user-provided task storage area. The task storage area contains the task stack, the thread-local storage, and the floating-point context on architectures with a separate floatingpoint context.

This directive is intended for applications which do not want to use the RTEMS Workspace and instead statically allocate all operating system resources. It is not recommended to use *[rtems\\_task\\_create\(\)](#page-136-0)* (page 109) and *[rtems\\_task\\_construct\(\)](#page-140-0)* (page 113) together in an application. It is also not recommended to use *[rtems\\_task\\_construct\(\)](#page-140-0)* (page 113) for drivers or general purpose libraries. The reason for these recommendations is that the task configuration needs settings which can be only given with a through knowledge of the application resources.

An application based solely on static allocation can avoid any runtime memory allocators. This can simplify the application architecture as well as any analysis that may be required.

The stack space estimate done by <rtems/confdefs.h> assumes that all tasks are created by *[rtems\\_task\\_create\(\)](#page-136-0)* (page 109). The estimate can be adjusted to take user-provided task storage areas into account through the *[CONFIG-](#page-653-0)[URE\\_MINIMUM\\_TASKS\\_WITH\\_USER\\_PROVIDED\\_STORAGE](#page-653-0)* (page 626) application configuration option.

The *[CONFIGURE\\_MAXIMUM\\_TASKS](#page-650-0)* (page 623) should include tasks constructed by *[rtems\\_task\\_construct\(\)](#page-140-0)* (page 113).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- When the directive operates on a global object, the directive sends a message to remote nodes. This may preempt the calling task.
- The number of tasks available to the application is configured through the *[CONFIG-](#page-650-0)[URE\\_MAXIMUM\\_TASKS](#page-650-0)* (page 623) application configuration option.
- Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace.
- The number of global objects available to the application is configured through the *[CON-](#page-765-0)[FIGURE\\_MP\\_MAXIMUM\\_GLOBAL\\_OBJECTS](#page-765-0)* (page 738) application configuration option.

## <span id="page-142-1"></span><span id="page-142-0"></span>8.4.3 rtems\_task\_ident()

Identifies a task by the object name.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_task_ident(
2 rtems_name name,
3 uint32_t node,
4 rtems_id *id
5 );
```

#### PARAMETERS:

#### **name**

This parameter is the object name to look up.

#### **node**

This parameter is the node or node set to search for a matching object.

**id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the object identifier of an object with the specified name will be stored in this object.

#### DESCRIPTION:

This directive obtains a task identifier associated with the task name specified in name.

A task may obtain its own identifier by specifying RTEMS\_WHO\_AM\_I for the name.

The node to search is specified in node. It shall be

- a valid node number,
- the constant RTEMS\_SEARCH\_ALL\_NODES to search in all nodes,
- the constant RTEMS\_SEARCH\_LOCAL\_NODE to search in the local node only, or
- the constant RTEMS\_SEARCH\_OTHER\_NODES to search in all nodes except the local node.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_NAME**

There was no object with the specified name on the specified nodes.

#### **RTEMS\_INVALID\_NODE**

In multiprocessing configurations, the specified node was invalid.

8.4. Directives 115

#### NOTES:

If the task name is not unique, then the task identifier will match the first task with that name in the search order. However, this task identifier is not guaranteed to correspond to the desired task.

The objects are searched from lowest to the highest index. If node is RTEMS\_SEARCH\_ALL\_NODES, all nodes are searched with the local node being searched first. All other nodes are searched from lowest to the highest node number.

If node is a valid node number which does not represent the local node, then only the tasks exported by the designated node are searched.

This directive does not generate activity on remote nodes. It accesses only the local copy of the global object table.

The task identifier is used with other task related directives to access the task.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-144-1"></span><span id="page-144-0"></span>8.4.4 rtems\_task\_self()

Gets the task identifier of the calling task.

#### CALLING SEQUENCE:

```
1 rtems_id rtems_task_self( void );
```

### DESCRIPTION:

This directive returns the task identifier of the calling task.

## RETURN VALUES:

Returns the task identifier of the calling task.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

8.4. Directives 117

## <span id="page-145-1"></span><span id="page-145-0"></span>8.4.5 rtems\_task\_start()

Starts the task.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_task_start(
2 rtems_id id,
3 rtems_task_entry entry_point,
4 rtems_task_argument argument
5 );
```

#### PARAMETERS:

#### **id**

This parameter is the task identifier. The constant RTEMS\_SELF may be used to specify the calling task.

## **entry\_point**

This parameter is the task entry point.

#### **argument**

This parameter is the task entry point argument.

#### DESCRIPTION:

This directive readies the task, specified by id, for execution based on the priority and execution mode specified when the task was created. The *[task entry](#page-1076-1)* point of the task is given in entry\_point. The task's entry point argument is contained in argument.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ADDRESS**

The entry\_point parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no task associated with the identifier specified by id.

#### **RTEMS\_INCORRECT\_STATE**

The task was not in the dormant state.

#### **RTEMS\_ILLEGAL\_ON\_REMOTE\_OBJECT**

The task resided on a remote node.

#### NOTES:

The type of the entry point argument is an unsigned integer type. However, the integer type has the property that any valid pointer to void can be converted to this type and then converted back to a pointer to void. The result will compare equal to the original pointer. The type can represent at least 32 bits. Some applications use the entry point argument as an index into a parameter table to get task-specific parameters.

Any actions performed on a dormant task such as suspension or change of priority are nullified when the task is initiated via the *[rtems\\_task\\_start\(\)](#page-145-0)* (page 118) directive.

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may unblock a task. This may cause the calling task to be preempted.

8.4. Directives 119

## <span id="page-147-1"></span><span id="page-147-0"></span>8.4.6 rtems\_task\_restart()

Restarts the task.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_task_restart(
2 rtems_id id,
3 rtems_task_argument argument
4 );
```

#### PARAMETERS:

#### **id**

This parameter is the task identifier. The constant RTEMS\_SELF may be used to specify the calling task.

#### **argument**

This parameter is the task entry point argument.

#### DESCRIPTION:

This directive resets the task specified by id to begin execution at its original entry point. The task's priority and execution mode are set to the original creation values. If the task is currently blocked, RTEMS automatically makes the task ready. A task can be restarted from any state, except the dormant state. The task's entry point argument is contained in argument.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no task associated with the identifier specified by id.

## **RTEMS\_INCORRECT\_STATE**

The task never started.

#### **RTEMS\_ILLEGAL\_ON\_REMOTE\_OBJECT**

The task resided on a remote node.

## NOTES:

The type of the entry point argument is an unsigned integer type. However, the integer type has the property that any valid pointer to void can be converted to this type and then converted back to a pointer to void. The result will compare equal to the original pointer. The type can represent at least 32 bits. Some applications use the entry point argument as an index into a parameter table to get task-specific parameters.

A new entry point argument may be used to distinguish between the initial *[rtems\\_task\\_start\(\)](#page-145-0)* (page 118) of the task and any ensuing calls to *[rtems\\_task\\_restart\(\)](#page-147-0)* (page 120) of the task. This can be beneficial in deleting a task. Instead of deleting a task using the *[rtems\\_task\\_delete\(\)](#page-149-0)* (page 122) directive, a task can delete another task by restarting that task, and allowing that task to release resources back to RTEMS and then delete itself.

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may change the priority of a task. This may cause the calling task to be preempted.
- The directive may unblock a task. This may cause the calling task to be preempted.

8.4. Directives 121

## <span id="page-149-1"></span><span id="page-149-0"></span>8.4.7 rtems\_task\_delete()

Deletes the task.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_task_delete( rtems_id id );
```

#### PARAMETERS:

## **id**

This parameter is the task identifier. The constant RTEMS\_SELF may be used to specify the calling task.

#### DESCRIPTION:

This directive deletes the task, either the calling task or another task, as specified by id.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no task associated with the identifier specified by id.

## **RTEMS\_CALLED\_FROM\_ISR**

The directive was called from within interrupt context.

#### **RTEMS\_INCORRECT\_STATE**

The task termination procedure was started, however, waiting for the terminating task would have resulted in a deadlock.

#### **RTEMS\_ILLEGAL\_ON\_REMOTE\_OBJECT**

The task resided on a remote node.

#### NOTES:

The task deletion is done in several steps. Firstly, the task is marked as terminating. While the task life of the terminating task is protected, it executes normally until it disables the task life protection or it deletes itself. A terminating task will eventually stop its normal execution and start its termination procedure. The procedure executes in the context of the terminating task. The task termination procedure involves the destruction of POSIX key values and running the task termination user extensions. Once complete the execution of the task is stopped and taskspecific resources are reclaimed by the system, such as the stack memory, any allocated delay or timeout timers, the *[TCB](#page-1077-1)*, and, if the task is RTEMS\_FLOATING\_POINT, its floating point context area. RTEMS explicitly does not reclaim the following resources: region segments, partition buffers, semaphores, timers, or rate monotonic periods.

A task is responsible for releasing its resources back to RTEMS before deletion. To insure proper deallocation of resources, a task should not be deleted unless it is unable to execute or does not hold any RTEMS resources. If a task holds RTEMS resources, the task should be allowed to deallocate its resources before deletion. A task can be directed to release its resources and delete itself by restarting it with a special argument or by sending it a message, an event, or a signal.

Deletion of the calling task (RTEMS\_SELF) will force RTEMS to select another task to execute.

When a task deletes another task, the calling task waits until the task termination procedure of the task being deleted has completed. The terminating task inherits the *[eligible priorities](#page-1064-0)* of the calling task.

When a global task is deleted, the task identifier must be transmitted to every node in the system for deletion from the local copy of the global object table.

The task must reside on the local node, even if the task was created with the RTEMS\_GLOBAL attribute.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- When the directive operates on a global object, the directive sends a message to remote nodes. This may preempt the calling task.
- The calling task does not have to be the task that created the object. Any local task that knows the object identifier can delete the object.
- Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace.

8.4. Directives 123

<span id="page-151-1"></span><span id="page-151-0"></span>8.4.8 rtems\_task\_exit()

Deletes the calling task.

## CALLING SEQUENCE:

```
1 void rtems_task_exit( void );
```

### DESCRIPTION:

This directive deletes the calling task.

## NOTES:

The directive is an optimized variant of the following code sequences, see also *[rtems\\_task\\_delete\(\)](#page-149-0)* (page 122):

```
1 #include <pthread.h>
2 #include <rtems.h>
3
4 void classic_delete_self( void )
5 {
6 (void) rtems_task_delete( RTEMS_SELF );
7 }
8
9 void posix_delete_self( void )
10 {
11 (void) pthread_detach( pthread_self() );
12 (void) pthread_exit( NULL);
13 }
```

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive will not return to the caller.
- While thread dispatching is disabled, if the directive performs a thread dispatch, then the fatal error with the fatal source *[INTERNAL\\_ERROR\\_CORE](#page-547-0)* (page 520) and the fatal code *[INTERNAL\\_ERROR\\_BAD\\_THREAD\\_DISPATCH\\_DISABLE\\_LEVEL](#page-548-0)* (page 521) will occur.

## <span id="page-152-1"></span><span id="page-152-0"></span>8.4.9 rtems\_task\_suspend()

Suspends the task.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_task_suspend( rtems_id id );
```

#### PARAMETERS:

## **id**

This parameter is the task identifier. The constant RTEMS\_SELF may be used to specify the calling task.

#### DESCRIPTION:

This directive suspends the task specified by id from further execution by placing it in the suspended state. This state is additive to any other blocked state that the task may already be in. The task will not execute again until another task issues the *[rtems\\_task\\_resume\(\)](#page-153-0)* (page 126) directive for this task and any blocked state has been removed. The *[rtems\\_task\\_restart\(\)](#page-147-0)* (page 120) directive will also remove the suspended state.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no task associated with the identifier specified by id.

#### **RTEMS\_ALREADY\_SUSPENDED**

The task was already suspended.

#### **RTEMS\_ILLEGAL\_ON\_REMOTE\_OBJECT**

The task resided on a remote node.

#### NOTES:

The requesting task can suspend itself for example by specifying RTEMS\_SELF as id. In this case, the task will be suspended and a successful return code will be returned when the task is resumed.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply. This will preempt the calling task.

8.4. Directives 125

## <span id="page-153-1"></span><span id="page-153-0"></span>8.4.10 rtems\_task\_resume()

Resumes the task.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_task_resume( rtems_id id );
```

### PARAMETERS:

## **id**

This parameter is the task identifier.

#### DESCRIPTION:

This directive removes the task specified by id from the suspended state. If the task is in the ready state after the suspension is removed, then it will be scheduled to run. If the task is still in a blocked state after the suspension is removed, then it will remain in that blocked state.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

### **RTEMS\_INVALID\_ID**

There was no task associated with the identifier specified by id.

#### **RTEMS\_INCORRECT\_STATE**

The task was not suspended.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may unblock a task. This may cause the calling task to be preempted.
- When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply. This will preempt the calling task.

## <span id="page-154-1"></span><span id="page-154-0"></span>8.4.11 rtems\_task\_is\_suspended()

Checks if the task is suspended.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_task_is_suspended( rtems_id id );
```

#### PARAMETERS:

## **id**

This parameter is the task identifier. The constant RTEMS\_SELF may be used to specify the calling task.

#### DESCRIPTION:

This directive returns a status code indicating whether or not the task specified by id is currently suspended.

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The task was **not** suspended.

### **RTEMS\_INVALID\_ID**

There was no task associated with the identifier specified by id.

## **RTEMS\_ALREADY\_SUSPENDED**

The task was suspended.

#### **RTEMS\_ILLEGAL\_ON\_REMOTE\_OBJECT**

The task resided on a remote node.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

8.4. Directives 127

## <span id="page-155-1"></span><span id="page-155-0"></span>8.4.12 rtems\_task\_set\_priority()

Sets the real priority or gets the current priority of the task.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_task_set_priority(
2 rtems_id id,
3 rtems_task_priority new_priority,
4 rtems_task_priority *old_priority
5 );
```

#### PARAMETERS:

#### **id**

This parameter is the task identifier. The constant RTEMS\_SELF may be used to specify the calling task.

#### **new\_priority**

This parameter is the new real priority or RTEMS\_CURRENT\_PRIORITY to get the current priority.

#### **old\_priority**

This parameter is the pointer to an *[rtems\\_task\\_priority](#page-84-0)* (page 57) object. When the directive call is successful, the current or previous priority of the task with respect to its *[home scheduler](#page-1066-0)* will be stored in this object.

## DESCRIPTION:

This directive manipulates the priority of the task specified by id. When new\_priority is not equal to RTEMS\_CURRENT\_PRIORITY, the specified task's previous priority is returned in old\_priority. When new\_priority is RTEMS\_CURRENT\_PRIORITY, the specified task's current priority is returned in old\_priority.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The old\_priority parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no task associated with the identifier specified by id.

## **RTEMS\_INVALID\_PRIORITY**

The task priority specified in new\_priority was invalid with respect to the *[home scheduler](#page-1066-0)* of the task.

## NOTES:

Valid priorities range from one to a maximum value which depends on the configured scheduler. The lower the priority value the higher is the importance of the task.

If the task is currently holding any binary semaphores which use a locking protocol, then the task's priority cannot be lowered immediately. If the task's priority were lowered immediately, then this could violate properties of the locking protocol and may result in priority inversion. The requested lowering of the task's priority will occur when the task has released all binary semaphores which make the task more important. The task's priority can be increased regardless of the task's use of binary semaphores with locking protocols.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may change the priority of a task. This may cause the calling task to be preempted.
- When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply. This will preempt the calling task.

8.4. Directives 129

## <span id="page-157-1"></span><span id="page-157-0"></span>8.4.13 rtems\_task\_get\_priority()

Gets the current priority of the task with respect to the scheduler.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_task_get_priority(
2 rtems_id task_id,
3 rtems_id scheduler_id,
4 rtems_task_priority *priority
5 );
```

#### PARAMETERS:

#### **task\_id**

This parameter is the task identifier. The constant RTEMS\_SELF may be used to specify the calling task.

#### **scheduler\_id**

This parameter is the scheduler identifier.

#### **priority**

This parameter is the pointer to an *[rtems\\_task\\_priority](#page-84-0)* (page 57) object. When the directive call is successful, the current priority of the task with respect to the specified scheduler will be stored in this object.

## DESCRIPTION:

This directive returns the current priority in priority of the task specified by task\_id with respect to the scheduler specified by scheduler\_id.

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The priority parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no task associated with the identifier specified by task\_id.

#### **RTEMS\_INVALID\_ID**

There was no scheduler associated with the identifier specified by scheduler\_id.

#### **RTEMS\_NOT\_DEFINED**

The task had no priority with respect to the scheduler.

#### **RTEMS\_ILLEGAL\_ON\_REMOTE\_OBJECT**

The task resided on a remote node.

## NOTES:

The current priority reflects temporary priority adjustments due to locking protocols, the ratemonotonic period objects on some schedulers such as EDF, and the POSIX sporadic server.

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

8.4. Directives 131

## <span id="page-159-1"></span><span id="page-159-0"></span>8.4.14 rtems\_task\_mode()

Gets and optionally sets the mode of the calling task.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_task_mode(
2 rtems_mode mode_set,
3 rtems_mode mask,
4 rtems_mode *previous_mode_set
5 );
```

#### PARAMETERS:

#### **mode\_set**

This parameter is the mode set to apply to the calling task. When mask is set to RTEMS\_CURRENT\_MODE, the value of this parameter is ignored. Only modes requested by mask are applied to the calling task.

#### **mask**

This parameter is the mode mask which specifies which modes in mode\_set are applied to the calling task. When the value is RTEMS\_CURRENT\_MODE, the mode of the calling task is not changed.

#### **previous\_mode\_set**

This parameter is the pointer to an rtems\_mode object. When the directive call is successful, the mode of the task before any mode changes done by the directive call will be stored in this object.

## DESCRIPTION:

This directive queries and optionally manipulates the execution mode of the calling task. A task's execution mode enables and disables preemption, timeslicing, asynchronous signal processing, as well as specifying the interrupt level. To modify an execution mode, the mode class(es) to be changed must be specified in the mask parameter and the desired mode(s) must be specified in the mode\_set parameter.

A task can obtain its current execution mode, without modifying it, by calling this directive with a mask value of RTEMS\_CURRENT\_MODE.

The **mode set** specified in mode\_set is built through a *bitwise or* of the mode constants described below. Not all combinations of modes are allowed. Some modes are mutually exclusive. If mutually exclusive modes are combined, the behaviour is undefined. Default task modes can be selected by using the RTEMS\_DEFAULT\_MODES constant. The task mode set defines

- the preemption mode of the task: RTEMS\_PREEMPT (default) or RTEMS\_NO\_PREEMPT,
- the timeslicing mode of the task: RTEMS\_TIMESLICE or RTEMS\_NO\_TIMESLICE (default),
- the *[ASR](#page-1060-2)* processing mode of the task: RTEMS\_ASR (default) or RTEMS\_NO\_ASR,
- the interrupt level of the task: RTEMS\_INTERRUPT\_LEVEL() with a default of RTEMS\_INTERRUPT\_LEVEL( 0 ) which is associated with enabled interrupts.

The **mode mask** specified in mask is built through a *bitwise or* of the mode mask constants described below.

When the RTEMS\_PREEMPT\_MASK is set in mask, the **preemption mode** of the calling task is

- enabled by using the RTEMS\_PREEMPT mode constant in mode\_set and
- disabled by using the RTEMS\_NO\_PREEMPT mode constant in mode\_set.

When the RTEMS\_TIMESLICE\_MASK is set in mask, the **timeslicing mode** of the calling task is

- enabled by using the RTEMS\_TIMESLICE mode constant in mode\_set and
- disabled by using the RTEMS\_NO\_TIMESLICE mode constant in mode\_set.

Enabling timeslicing has no effect if preemption is disabled. For a task to be timesliced, that task must have both preemption and timeslicing enabled.

When the RTEMS\_ASR\_MASK is set in mask, the **ASR processing mode** of the calling task is

- enabled by using the RTEMS\_ASR mode constant in mode\_set and
- disabled by using the RTEMS\_NO\_ASR mode constant in mode\_set.

When the RTEMS\_INTERRUPT\_MASK is set in mask, **interrupts** of the calling task are

- enabled by using the RTEMS\_INTERRUPT\_LEVEL() mode macro with a value of zero (0) in mode\_set and
- disabled up to the specified level by using the RTEMS\_INTERRUPT\_LEVEL() mode macro with a positive value in mode\_set.

An interrupt level of zero is associated with enabled interrupts on all target processors. The interrupt level portion of the task mode supports a maximum of 256 interrupt levels. These levels are mapped onto the interrupt levels actually supported by the target processor in a processor dependent fashion.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_NOT\_IMPLEMENTED**

The RTEMS\_NO\_PREEMPT was set in mode\_set and setting the preemption mode was requested by RTEMS\_PREEMPT\_MASK in mask and the system configuration had no implementation for this mode.

#### **RTEMS\_NOT\_IMPLEMENTED**

The RTEMS\_INTERRUPT\_LEVEL() was set to a positive level in mode\_set and setting the interrupt level was requested by RTEMS\_INTERRUPT\_MASK in mask and the system configuration had no implementation for this mode.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- When the directive enables preemption for the calling task, another task may preempt the calling task.
- While thread dispatching is disabled, if the directive performs a thread dispatch, then the fatal error with the fatal source *[INTERNAL\\_ERROR\\_CORE](#page-547-0)* (page 520) and the fatal code *[INTERNAL\\_ERROR\\_BAD\\_THREAD\\_DISPATCH\\_DISABLE\\_LEVEL](#page-548-0)* (page 521) will occur.

8.4. Directives 133

## <span id="page-161-1"></span><span id="page-161-0"></span>8.4.15 rtems\_task\_wake\_after()

Wakes up after a count of *[clock ticks](#page-1062-1)* have occurred or yields the processor.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_task_wake_after( rtems_interval ticks );
```

#### PARAMETERS:

## **ticks**

This parameter is the count of *[clock ticks](#page-1062-1)* to delay the task or RTEMS\_YIELD\_PROCESSOR to yield the processor.

#### DESCRIPTION:

This directive blocks the calling task for the specified ticks count of clock ticks if the value is not equal to RTEMS\_YIELD\_PROCESSOR. When the requested count of ticks have occurred, the task is made ready. The clock tick directives automatically update the delay period. The calling task may give up the processor and remain in the ready state by specifying a value of RTEMS\_YIELD\_PROCESSOR in ticks.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## NOTES:

Setting the system date and time with the *[rtems\\_clock\\_set\(\)](#page-270-0)* (page 243) directive and similar directives which set *[CLOCK\\_REALTIME](#page-1062-2)* have no effect on a *[rtems\\_task\\_wake\\_after\(\)](#page-161-0)* (page 134) blocked task. The delay until first clock tick will never be a whole clock tick interval since this directive will never execute exactly on a clock tick. Applications requiring use of a clock (*[CLOCK\\_REALTIME](#page-1062-2)* or *[CLOCK\\_MONOTONIC](#page-1062-0)*) instead of clock ticks should make use of [clock\\_nanosleep\(\).](https://pubs.opengroup.org/onlinepubs/9699919799/functions/clock_nanosleep.html)

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive requires a *[Clock Driver](#page-1062-3)*.
- While thread dispatching is disabled, if the directive performs a thread dispatch, then the fatal error with the fatal source *[INTERNAL\\_ERROR\\_CORE](#page-547-0)* (page 520) and the fatal code *[INTERNAL\\_ERROR\\_BAD\\_THREAD\\_DISPATCH\\_DISABLE\\_LEVEL](#page-548-0)* (page 521) will occur.

## <span id="page-162-1"></span><span id="page-162-0"></span>8.4.16 rtems\_task\_wake\_when()

Wakes up when specified.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_task_wake_when( const rtems_time_of_day *time_buffer );
```

#### PARAMETERS:

#### **time\_buffer**

This parameter is the date and time to wake up.

#### DESCRIPTION:

This directive blocks a task until the date and time specified in time\_buffer. At the requested date and time, the calling task will be unblocked and made ready to execute.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_NOT\_DEFINED**

The system date and time was not set.

#### **RTEMS\_INVALID\_ADDRESS**

The time\_buffer parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_CLOCK**

The time of day was invalid.

#### NOTES:

The ticks portion of time\_buffer structure is ignored. The timing granularity of this directive is a second.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive requires a *[Clock Driver](#page-1062-3)*.
- While thread dispatching is disabled, if the directive performs a thread dispatch, then the fatal error with the fatal source *[INTERNAL\\_ERROR\\_CORE](#page-547-0)* (page 520) and the fatal code *[INTERNAL\\_ERROR\\_BAD\\_THREAD\\_DISPATCH\\_DISABLE\\_LEVEL](#page-548-0)* (page 521) will occur.

8.4. Directives 135

## <span id="page-163-1"></span><span id="page-163-0"></span>8.4.17 rtems\_task\_get\_scheduler()

Gets the home scheduler of the task.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_task_get_scheduler(
2 rtems_id task_id,
3 rtems_id *scheduler_id
4 );
```

#### PARAMETERS:

#### **task\_id**

This parameter is the task identifier. The constant RTEMS\_SELF may be used to specify the calling task.

#### **scheduler\_id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the identifier of the *[home scheduler](#page-1066-0)* of the task will be stored in this object.

## DESCRIPTION:

This directive returns the identifier of the *[home scheduler](#page-1066-0)* of the task specified by task\_id in scheduler\_id.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The scheduler\_id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

## **RTEMS\_INVALID\_ID**

There was no task associated with the identifier specified by task\_id.

#### **RTEMS\_ILLEGAL\_ON\_REMOTE\_OBJECT**

The task resided on a remote node.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

## <span id="page-164-1"></span><span id="page-164-0"></span>8.4.18 rtems\_task\_set\_scheduler()

Sets the home scheduler for the task.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_task_set_scheduler(
2 rtems_id task_id,
3 rtems_id scheduler_id,
4 rtems_task_priority priority
5 );
```

#### PARAMETERS:

#### **task\_id**

This parameter is the task identifier. The constant RTEMS\_SELF may be used to specify the calling task.

#### **scheduler\_id**

This parameter is the scheduler identifier of the new *[home scheduler](#page-1066-0)* for the task specified by task\_id.

#### **priority**

This parameter is the new real priority for the task with respect to the scheduler specified by scheduler\_id.

## DESCRIPTION:

This directive sets the *[home scheduler](#page-1066-0)* to the scheduler specified by scheduler\_id for the task specified by task\_id.

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ID**

There was no scheduler associated with the identifier specified by scheduler\_id.

#### **RTEMS\_INVALID\_PRIORITY**

The *[task priority](#page-1077-3)* specified by priority was invalid with respect to the scheduler specified by scheduler\_id.

### **RTEMS\_INVALID\_ID**

There was no task associated with the identifier specified by task\_id.

#### **RTEMS\_RESOURCE\_IN\_USE**

The task specified by task\_id was enqueued on a *[wait queue](#page-1078-0)*.

#### **RTEMS\_RESOURCE\_IN\_USE**

The task specified by task\_id had a *[current priority](#page-1063-0)* which consisted of more than the *[real](#page-1072-0) [priority](#page-1072-0)*.

## **RTEMS\_RESOURCE\_IN\_USE**

The task specified by task\_id had a *[helping scheduler](#page-1066-1)*.

8.4. Directives 137

#### **RTEMS\_RESOURCE\_IN\_USE**

The task specified by task\_id was pinned.

#### **RTEMS\_UNSATISFIED**

The scheduler specified by scheduler\_id owned no processor.

#### **RTEMS\_UNSATISFIED**

The scheduler specified by scheduler\_id did not support the affinity set of the task specified by task\_id.

#### **RTEMS\_ILLEGAL\_ON\_REMOTE\_OBJECT**

The task resided on a remote node.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may change the priority of a task. This may cause the calling task to be preempted.

## <span id="page-166-1"></span><span id="page-166-0"></span>8.4.19 rtems\_task\_get\_affinity()

Gets the processor affinity of the task.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_task_get_affinity(
2 rtems_id id,
3 size_t cpusetsize,
4 cpu_set_t *cpuset
5 );
```

#### PARAMETERS:

#### **id**

This parameter is the task identifier. The constant RTEMS\_SELF may be used to specify the calling task.

#### **cpusetsize**

This parameter is the size of the processor set referenced by cpuset in bytes.

#### **cpuset**

This parameter is the pointer to a cpu\_set\_t object. When the directive call is successful, the processor affinity set of the task will be stored in this object. A set bit in the processor set means that the corresponding processor is in the processor affinity set of the task, otherwise the bit is cleared.

#### DESCRIPTION:

This directive returns the processor affinity of the task in cpuset of the task specified by id.

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ADDRESS**

The cpuset parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no task associated with the identifier specified by id.

#### **RTEMS\_INVALID\_SIZE**

The size specified by cpusetsize of the processor set was too small for the processor affinity set of the task.

#### **RTEMS\_ILLEGAL\_ON\_REMOTE\_OBJECT**

The task resided on a remote node.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.

8.4. Directives 139

- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

## <span id="page-168-1"></span><span id="page-168-0"></span>8.4.20 rtems\_task\_set\_affinity()

Sets the processor affinity of the task.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_task_set_affinity(
2 rtems_id id,
3 size_t cpusetsize,
4 const cpu_set_t *cpuset
5 );
```

#### PARAMETERS:

## **id**

This parameter is the task identifier. The constant RTEMS\_SELF may be used to specify the calling task.

#### **cpusetsize**

This parameter is the size of the processor set referenced by cpuset in bytes.

#### **cpuset**

This parameter is the pointer to a cpu\_set\_t object. The processor set defines the new processor affinity set of the task. A set bit in the processor set means that the corresponding processor shall be in the processor affinity set of the task, otherwise the bit shall be cleared.

## DESCRIPTION:

This directive sets the processor affinity of the task specified by id.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ADDRESS**

The cpuset parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no task associated with the identifier specified by id.

#### **RTEMS\_INVALID\_NUMBER**

The referenced processor set was not a valid new processor affinity set for the task.

## **RTEMS\_ILLEGAL\_ON\_REMOTE\_OBJECT**

The task resided on a remote node.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.

8.4. Directives 141

â€¢ The directive may change the processor affinity of a task. This may cause the calling task to be preempted.

## <span id="page-170-1"></span><span id="page-170-0"></span>8.4.21 rtems\_task\_iterate()

Iterates over all tasks and invokes the visitor routine for each task.

## CALLING SEQUENCE:

```
1 void rtems_task_iterate( rtems_task_visitor visitor, void *arg );
```

#### PARAMETERS:

#### **visitor**

This parameter is the visitor routine invoked for each task.

#### **arg**

This parameter is the argument passed to each visitor routine invocation during the iteration.

#### DESCRIPTION:

This directive iterates over all tasks in the system. This operation covers all tasks of all APIs. The user should be careful in accessing the contents of the *[TCB](#page-1077-1)*. The visitor argument arg is passed to all invocations of visitor in addition to the TCB. The iteration stops immediately in case the visitor routine returns true.

#### NOTES:

The visitor routine is invoked while owning the objects allocator lock. It is allowed to perform blocking operations in the visitor routine, however, care must be taken so that no deadlocks via the object allocator lock can occur.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

8.4. Directives 143

## <span id="page-171-1"></span><span id="page-171-0"></span>8.4.22 RTEMS\_TASK\_STORAGE\_SIZE()

Gets the recommended task storage area size for the size and task attributes.

#### CALLING SEQUENCE:

```
1 size_t RTEMS_TASK_STORAGE_SIZE( size_t size, rtems_attribute attributes );
```

#### PARAMETERS:

#### **size**

This parameter is the size dedicated to the task stack and thread-local storage in bytes.

#### **attributes**

This parameter is the attribute set of the task using the storage area.

#### RETURN VALUES:

Returns the recommended task storage area size calculated from the input parameters.

# <span id="page-172-0"></span>8.5 Deprecated Directives

## <span id="page-173-1"></span><span id="page-173-0"></span>8.5.1 ITERATE\_OVER\_ALL\_THREADS - Iterate Over Tasks

## . **Warning**

This directive is deprecated. Its use is unsafe. Use rtems\_task\_iterate instead.

## **CALLING SEQUENCE:**

```
1 typedef void (*rtems_per_thread_routine)(Thread_Control *the_thread);
2 void rtems_iterate_over_all_threads(
3 rtems_per_thread_routine routine
4 );
```

#### **DIRECTIVE STATUS CODES:**

NONE

#### **DESCRIPTION:**

This directive iterates over all of the existant threads in the system and invokes routine on each of them. The user should be careful in accessing the contents of the\_thread.

This routine is intended for use in diagnostic utilities and is not intented for routine use in an operational system.

#### **NOTES:**

There is **no protection** while this routine is called. The thread control block may be in an inconsistent state or may change due to interrupts or activity on other processors.

# <span id="page-174-0"></span>8.6 Removed Directives

## <span id="page-175-1"></span><span id="page-175-0"></span>8.6.1 TASK\_GET\_NOTE - Get task notepad entry

```
. Warning
This directive was removed in RTEMS 5.1.
```

## **CALLING SEQUENCE:**

```
1 rtems_status_code rtems_task_get_note(
2 rtems_id id,
3 uint32_t notepad,
4 uint32_t *note
5 );
```

#### **DIRECTIVE STATUS CODES:**

| RTEMS_SUCCESSFUL      | note value obtained successfully |
|-----------------------|----------------------------------|
| RTEMS_INVALID_ADDRESS | note<br>parameter is NULL        |
| RTEMS_INVALID_ID      | invalid task id                  |
| RTEMS_INVALID_NUMBER  | invalid notepad location         |

#### **DESCRIPTION:**

This directive returns the note contained in the notepad location of the task specified by id.

#### **NOTES:**

This directive will not cause the running task to be preempted.

If id is set to RTEMS\_SELF, the calling task accesses its own notepad.

The sixteen notepad locations can be accessed using the constants RTEMS\_NOTEPAD\_0 through RTEMS\_NOTEPAD\_15.

Getting a note of a global task which does not reside on the local node will generate a request to the remote node to obtain the notepad entry of the specified task.

## <span id="page-176-1"></span><span id="page-176-0"></span>8.6.2 TASK\_SET\_NOTE - Set task notepad entry

```
. Warning
```

This directive was removed in RTEMS 5.1.

## **CALLING SEQUENCE:**

```
1 rtems_status_code rtems_task_set_note(
2 rtems_id id,
3 uint32_t notepad,
4 uint32_t note
5 );
```

#### **DIRECTIVE STATUS CODES:**

| RTEMS_SUCCESSFUL     | note set successfully    |
|----------------------|--------------------------|
| RTEMS_INVALID_ID     | invalid task id          |
| RTEMS_INVALID_NUMBER | invalid notepad location |

## **DESCRIPTION:**

This directive sets the notepad entry for the task specified by id to the value note.

#### **NOTES:**

If id is set to RTEMS\_SELF, the calling task accesses its own notepad.

This directive will not cause the running task to be preempted.

The sixteen notepad locations can be accessed using the constants RTEMS\_NOTEPAD\_0 through RTEMS\_NOTEPAD\_15.

Setting a note of a global task which does not reside on the local node will generate a request to the remote node to set the notepad entry of the specified task.

## <span id="page-177-1"></span><span id="page-177-0"></span>8.6.3 TASK\_VARIABLE\_ADD - Associate per task variable

```
. Warning
This directive was removed in RTEMS 5.1.
```

## **CALLING SEQUENCE:**

```
1 rtems_status_code rtems_task_variable_add(
2 rtems_id tid,
3 void **task_variable,
4 void (*dtor)(void *)
5 );
```

#### **DIRECTIVE STATUS CODES:**

| RTEMS_SUCCESSFUL               | per task variable added successfully |
|--------------------------------|--------------------------------------|
| RTEMS_INVALID_ADDRESS          | task_variable<br>is NULL             |
| RTEMS_INVALID_ID               | invalid task id                      |
| RTEMS_NO_MEMORY                | invalid task id                      |
| RTEMS_ILLEGAL_ON_REMOTE_OBJECT | not supported on remote tasks        |

#### **DESCRIPTION:**

This directive adds the memory location specified by the ptr argument to the context of the given task. The variable will then be private to the task. The task can access and modify the variable, but the modifications will not appear to other tasks, and other tasks' modifications to that variable will not affect the value seen by the task. This is accomplished by saving and restoring the variable's value each time a task switch occurs to or from the calling task. If the dtor argument is non-NULL it specifies the address of a 'destructor' function which will be called when the task is deleted. The argument passed to the destructor function is the task's value of the variable.

#### **NOTES:**

Task variables increase the context switch time to and from the tasks that own them so it is desirable to minimize the number of task variables. One efficient method is to have a single task variable that is a pointer to a dynamically allocated structure containing the task's private 'global' data. In this case the destructor function could be 'free'.

Per-task variables are disabled in SMP configurations and this service is not available.

## <span id="page-178-1"></span><span id="page-178-0"></span>8.6.4 TASK\_VARIABLE\_GET - Obtain value of a per task variable

```
. Warning
This directive was removed in RTEMS 5.1.
```

## **CALLING SEQUENCE:**

```
1 rtems_status_code rtems_task_variable_get(
2 rtems_id tid,
3 void **task_variable,
4 void **task_variable_value
5 );
```

#### **DIRECTIVE STATUS CODES:**

| RTEMS_SUCCESSFUL               | per task variable obtained successfully |
|--------------------------------|-----------------------------------------|
| RTEMS_INVALID_ADDRESS          | task_variable<br>is NULL                |
| RTEMS_INVALID_ADDRESS          | task_variable_value<br>is NULL          |
| RTEMS_INVALID_ADDRESS          | task_variable<br>is not found           |
| RTEMS_NO_MEMORY                | invalid task id                         |
| RTEMS_ILLEGAL_ON_REMOTE_OBJECT | not supported on remote tasks           |

#### **DESCRIPTION:**

This directive looks up the private value of a task variable for a specified task and stores that value in the location pointed to by the result argument. The specified task is usually not the calling task, which can get its private value by directly accessing the variable.

## **NOTES:**

If you change memory which task\_variable\_value points to, remember to declare that memory as volatile, so that the compiler will optimize it correctly. In this case both the pointer task\_variable\_value and data referenced by task\_variable\_value should be considered volatile.

Per-task variables are disabled in SMP configurations and this service is not available.

## <span id="page-179-1"></span><span id="page-179-0"></span>8.6.5 TASK\_VARIABLE\_DELETE - Remove per task variable

```
. Warning
This directive was removed in RTEMS 5.1.
```

## **CALLING SEQUENCE:**

```
1 rtems_status_code rtems_task_variable_delete(
2 rtems_id id,
3 void **task_variable
4 );
```

#### **DIRECTIVE STATUS CODES:**

| RTEMS_SUCCESSFUL               | per task variable deleted successfully |
|--------------------------------|----------------------------------------|
| RTEMS_INVALID_ID               | invalid task id                        |
| RTEMS_NO_MEMORY                | invalid task id                        |
| RTEMS_INVALID_ADDRESS          | task_variable<br>is NULL               |
| RTEMS_ILLEGAL_ON_REMOTE_OBJECT | not supported on remote tasks          |

#### **DESCRIPTION:**

This directive removes the given location from a task's context.

#### **NOTES:**

Per-task variables are disabled in SMP configurations and this service is not available.

CHAPTER

**NINE**

# <span id="page-180-0"></span>INTERRUPT MANAGER

# <span id="page-181-0"></span>9.1 Introduction

Any real-time executive must provide a mechanism for quick response to externally generated interrupts to satisfy the critical time constraints of the application. The Interrupt Manager provides this mechanism for RTEMS. This manager permits quick interrupt response times by providing the critical ability to alter task execution which allows a task to be preempted upon exit from an ISR. The directives provided by the Interrupt Manager are:

- *[rtems\\_interrupt\\_catch\(\)](#page-189-0)* (page 162) Establishes an interrupt service routine.
- *[rtems\\_interrupt\\_disable\(\)](#page-191-0)* (page 164) Disables the maskable interrupts on the current processor.
- *[rtems\\_interrupt\\_enable\(\)](#page-193-0)* (page 166) Restores the previous interrupt level on the current processor.
- *[rtems\\_interrupt\\_flash\(\)](#page-194-0)* (page 167) Flashes interrupts on the current processor.
- *[rtems\\_interrupt\\_local\\_disable\(\)](#page-195-0)* (page 168) Disables the maskable interrupts on the current processor.
- *[rtems\\_interrupt\\_local\\_enable\(\)](#page-197-0)* (page 170) Restores the previous interrupt level on the current processor.
- *[rtems\\_interrupt\\_is\\_in\\_progress\(\)](#page-198-0)* (page 171) Checks if an ISR is in progress on the current processor.
- *[rtems\\_interrupt\\_lock\\_initialize\(\)](#page-199-0)* (page 172) Initializes the ISR lock.
- *[rtems\\_interrupt\\_lock\\_destroy\(\)](#page-200-0)* (page 173) Destroys the ISR lock.
- *[rtems\\_interrupt\\_lock\\_acquire\(\)](#page-201-0)* (page 174) Acquires the ISR lock.
- *[rtems\\_interrupt\\_lock\\_release\(\)](#page-203-0)* (page 176) Releases the ISR lock.
- *[rtems\\_interrupt\\_lock\\_acquire\\_isr\(\)](#page-204-0)* (page 177) Acquires the ISR lock from within an ISR.
- *[rtems\\_interrupt\\_lock\\_release\\_isr\(\)](#page-205-0)* (page 178) Releases the ISR lock from within an ISR.
- *[rtems\\_interrupt\\_lock\\_interrupt\\_disable\(\)](#page-206-0)* (page 179) Disables maskable interrupts on the current processor.
- *[RTEMS\\_INTERRUPT\\_LOCK\\_DECLARE\(\)](#page-207-0)* (page 180) Declares an ISR lock object.
- *[RTEMS\\_INTERRUPT\\_LOCK\\_DEFINE\(\)](#page-208-0)* (page 181) Defines an ISR lock object.
- *[RTEMS\\_INTERRUPT\\_LOCK\\_INITIALIZER\(\)](#page-209-0)* (page 182) Statically initializes an ISR lock object.
- *[RTEMS\\_INTERRUPT\\_LOCK\\_MEMBER\(\)](#page-210-0)* (page 183) Defines an ISR lock member.
- *[RTEMS\\_INTERRUPT\\_LOCK\\_REFERENCE\(\)](#page-211-0)* (page 184) Defines an ISR lock object reference.
- *[RTEMS\\_INTERRUPT\\_ENTRY\\_INITIALIZER\(\)](#page-212-0)* (page 185) Statically initializes an interrupt entry object.
- *[rtems\\_interrupt\\_entry\\_initialize\(\)](#page-213-0)* (page 186) Initializes the interrupt entry.
- *[rtems\\_interrupt\\_entry\\_install\(\)](#page-214-0)* (page 187) Installs the interrupt entry at the interrupt vector.

- *[rtems\\_interrupt\\_entry\\_remove\(\)](#page-216-0)* (page 189) Removes the interrupt entry from the interrupt vector.
- *[rtems\\_interrupt\\_handler\\_install\(\)](#page-217-0)* (page 190) Installs the interrupt handler routine and argument at the interrupt vector.
- *[rtems\\_interrupt\\_handler\\_remove\(\)](#page-219-0)* (page 192) Removes the interrupt handler routine and argument from the interrupt vector.
- *[rtems\\_interrupt\\_vector\\_is\\_enabled\(\)](#page-220-0)* (page 193) Checks if the interrupt vector is enabled.
- *[rtems\\_interrupt\\_vector\\_enable\(\)](#page-221-0)* (page 194) Enables the interrupt vector.
- *[rtems\\_interrupt\\_vector\\_disable\(\)](#page-222-0)* (page 195) Disables the interrupt vector.
- *[rtems\\_interrupt\\_is\\_pending\(\)](#page-223-0)* (page 196) Checks if the interrupt is pending.
- *[rtems\\_interrupt\\_raise\(\)](#page-225-0)* (page 198) Raises the interrupt vector.
- *[rtems\\_interrupt\\_raise\\_on\(\)](#page-226-0)* (page 199) Raises the interrupt vector on the processor.
- *[rtems\\_interrupt\\_clear\(\)](#page-227-0)* (page 200) Clears the interrupt vector.
- *[rtems\\_interrupt\\_get\\_priority\(\)](#page-228-0)* (page 201) Gets the priority of the interrupt vector.
- *[rtems\\_interrupt\\_set\\_priority\(\)](#page-229-0)* (page 202) Sets the priority of the interrupt vector.
- *[rtems\\_interrupt\\_get\\_affinity\(\)](#page-231-0)* (page 204) Gets the processor affinity set of the interrupt vector.
- *[rtems\\_interrupt\\_set\\_affinity\(\)](#page-232-0)* (page 205) Sets the processor affinity set of the interrupt vector.
- *[rtems\\_interrupt\\_get\\_attributes\(\)](#page-234-0)* (page 207) Gets the attributes of the interrupt vector.
- *[rtems\\_interrupt\\_handler\\_iterate\(\)](#page-235-0)* (page 208) Iterates over all interrupt handler installed at the interrupt vector.
- *[rtems\\_interrupt\\_server\\_initialize\(\)](#page-237-0)* (page 210) Initializes the interrupt server tasks.
- *[rtems\\_interrupt\\_server\\_create\(\)](#page-239-0)* (page 212) Creates an interrupt server.
- *[rtems\\_interrupt\\_server\\_handler\\_install\(\)](#page-240-0)* (page 213) Installs the interrupt handler routine and argument at the interrupt vector on the interrupt server.
- *[rtems\\_interrupt\\_server\\_handler\\_remove\(\)](#page-242-0)* (page 215) Removes the interrupt handler routine and argument from the interrupt vector and the interrupt server.
- *[rtems\\_interrupt\\_server\\_set\\_affinity\(\)](#page-243-0)* (page 216) Sets the processor affinity of the interrupt server.
- *[rtems\\_interrupt\\_server\\_delete\(\)](#page-245-0)* (page 218) Deletes the interrupt server.
- *[rtems\\_interrupt\\_server\\_suspend\(\)](#page-246-0)* (page 219) Suspends the interrupt server.
- *[rtems\\_interrupt\\_server\\_resume\(\)](#page-247-0)* (page 220) Resumes the interrupt server.
- *[rtems\\_interrupt\\_server\\_move\(\)](#page-248-0)* (page 221) Moves the interrupt handlers installed at the interrupt vector and the source interrupt server to the destination interrupt server.
- *[rtems\\_interrupt\\_server\\_handler\\_iterate\(\)](#page-249-0)* (page 222) Iterates over all interrupt handler installed at the interrupt vector and interrupt server.
- *[rtems\\_interrupt\\_server\\_entry\\_initialize\(\)](#page-251-0)* (page 224) Initializes the interrupt server entry.

9.1. Introduction 155

- *[rtems\\_interrupt\\_server\\_action\\_prepend\(\)](#page-252-0)* (page 225) Prepends the interrupt server action to the list of actions of the interrupt server entry.
- *[rtems\\_interrupt\\_server\\_entry\\_destroy\(\)](#page-254-0)* (page 227) Destroys the interrupt server entry.
- *[rtems\\_interrupt\\_server\\_entry\\_submit\(\)](#page-255-0)* (page 228) Submits the interrupt server entry to be serviced by the interrupt server.
- *[rtems\\_interrupt\\_server\\_entry\\_move\(\)](#page-256-0)* (page 229) Moves the interrupt server entry to the interrupt server.
- *[rtems\\_interrupt\\_server\\_request\\_initialize\(\)](#page-257-0)* (page 230) Initializes the interrupt server request.
- *[rtems\\_interrupt\\_server\\_request\\_set\\_vector\(\)](#page-258-0)* (page 231) Sets the interrupt vector in the interrupt server request.
- *[rtems\\_interrupt\\_server\\_request\\_destroy\(\)](#page-259-0)* (page 232) Destroys the interrupt server request.
- *[rtems\\_interrupt\\_server\\_request\\_submit\(\)](#page-260-0)* (page 233) Submits the interrupt server request to be serviced by the interrupt server.

# <span id="page-184-2"></span><span id="page-184-0"></span>9.2 Background

## <span id="page-184-1"></span>9.2.1 Processing an Interrupt

The interrupt manager allows the application to connect a function to a hardware interrupt vector. When an interrupt occurs, the processor will automatically vector to RTEMS. RTEMS saves and restores all registers which are not preserved by the normal C calling convention for the target processor and invokes the user's ISR. The user's ISR is responsible for processing the interrupt, clearing the interrupt if necessary, and device specific manipulation.

The rtems\_interrupt\_catch directive connects a procedure to an interrupt vector. The vector number is managed using the rtems\_vector\_number data type.

The interrupt service routine is assumed to abide by these conventions and have a prototype similar to the following:

```
1 rtems_isr user_isr(
2 rtems_vector_number vector
3 );
```

The vector number argument is provided by RTEMS to allow the application to identify the interrupt source. This could be used to allow a single routine to service interrupts from multiple instances of the same device. For example, a single routine could service interrupts from multiple serial ports and use the vector number to identify which port requires servicing.

To minimize the masking of lower or equal priority level interrupts, the ISR should perform the minimum actions required to service the interrupt. Other non-essential actions should be handled by application tasks. Once the user's ISR has completed, it returns control to the RTEMS interrupt manager which will perform task dispatching and restore the registers saved before the ISR was invoked.

The RTEMS interrupt manager guarantees that proper task scheduling and dispatching are performed at the conclusion of an ISR. A system call made by the ISR may have readied a task of higher priority than the interrupted task. Therefore, when the ISR completes, the postponed dispatch processing must be performed. No dispatch processing is performed as part of directives which have been invoked by an ISR.

Applications must adhere to the following rule if proper task scheduling and dispatching is to be performed:

![](_page_184_Figure_12.jpeg)

The interrupt manager must be used for all ISRs which may be interrupted by the highest priority ISR which invokes an RTEMS directive.

Consider a processor which allows a numerically low interrupt level to interrupt a numerically greater interrupt level. In this example, if an RTEMS directive is used in a level 4 ISR, then all ISRs which execute at levels 0 through 4 must use the interrupt manager.

Interrupts are nested whenever an interrupt occurs during the execution of another ISR. RTEMS supports efficient interrupt nesting by allowing the nested ISRs to terminate without performing any dispatch processing. Only when the outermost ISR terminates will the postponed dispatching occur.

9.2. Background 157

## <span id="page-185-2"></span><span id="page-185-0"></span>9.2.2 RTEMS Interrupt Levels

Many processors support multiple interrupt levels or priorities. The exact number of interrupt levels is processor dependent. RTEMS internally supports 256 interrupt levels which are mapped to the processor's interrupt levels. For specific information on the mapping between RTEMS and the target processor's interrupt levels, refer to the Interrupt Processing chapter of the Applications Supplement document for a specific target processor.

## <span id="page-185-1"></span>9.2.3 Disabling of Interrupts by RTEMS

During the execution of directive calls, critical sections of code may be executed. When these sections are encountered, RTEMS disables all maskable interrupts before the execution of the section and restores them to the previous level upon completion of the section. RTEMS has been optimized to ensure that interrupts are disabled for a minimum length of time. The maximum length of time interrupts are disabled by RTEMS is processor dependent and is detailed in the Timing Specification chapter of the Applications Supplement document for a specific target processor.

Non-maskable interrupts (NMI) cannot be disabled, and ISRs which execute at this level MUST NEVER issue RTEMS system calls. If a directive is invoked, unpredictable results may occur due to the inability of RTEMS to protect its critical sections. However, ISRs that make no system calls may safely execute as non-maskable interrupts.

# <span id="page-186-0"></span>9.3 Operations

## <span id="page-186-1"></span>9.3.1 Establishing an ISR

The rtems\_interrupt\_catch directive establishes an ISR for the system. The address of the ISR and its associated CPU vector number are specified to this directive. This directive installs the RTEMS interrupt wrapper in the processor's Interrupt Vector Table and the address of the user's ISR in the RTEMS' Vector Table. This directive returns the previous contents of the specified vector in the RTEMS' Vector Table.

## <span id="page-186-2"></span>9.3.2 Directives Allowed from an ISR

Using the interrupt manager ensures that RTEMS knows when a directive is being called from an ISR. The ISR may then use system calls to synchronize itself with an application task. The synchronization may involve messages, events or signals being passed by the ISR to the desired task. Directives invoked by an ISR must operate only on objects which reside on the local node. The following is a list of RTEMS system calls that may be made from an ISR:

- Task Management Although it is acceptable to operate on the RTEMS\_SELF task (e.g. the currently executing task), while in an ISR, this will refer to the interrupted task. Most of the time, it is an application implementation error to use RTEMS\_SELF from an ISR.
  - **â€“** rtems\_task\_suspend
  - **â€“** rtems\_task\_resume
- Interrupt Management
  - **â€“** rtems\_interrupt\_enable
  - **â€“** rtems\_interrupt\_disable
  - **â€“** rtems\_interrupt\_flash
  - **â€“** rtems\_interrupt\_lock\_acquire
  - **â€“** rtems\_interrupt\_lock\_release
  - **â€“** rtems\_interrupt\_lock\_acquire\_isr
  - **â€“** rtems\_interrupt\_lock\_release\_isr
  - **â€“** rtems\_interrupt\_is\_in\_progress
  - **â€“** rtems\_interrupt\_catch
- Clock Management
  - **â€“** rtems\_clock\_set
  - **â€“** rtems\_clock\_get\_tod
  - **â€“** rtems\_clock\_get\_tod\_timeval
  - **â€“** rtems\_clock\_get\_seconds\_since\_epoch
  - **â€“** rtems\_clock\_get\_ticks\_per\_second
  - **â€“** rtems\_clock\_get\_ticks\_since\_boot
  - **â€“** rtems\_clock\_get\_uptime
- Timer Management

9.3. Operations 159

- **â€“** rtems\_timer\_cancel
- **â€“** rtems\_timer\_reset
- **â€“** rtems\_timer\_fire\_after
- **â€“** rtems\_timer\_fire\_when
- **â€“** rtems\_timer\_server\_fire\_after
- **â€“** rtems\_timer\_server\_fire\_when
- Event Management
  - **â€“** rtems\_event\_send
  - **â€“** rtems\_event\_system\_send
  - **â€“** rtems\_event\_transient\_send
- Semaphore Management
  - **â€“** rtems\_semaphore\_release
- Message Management
  - **â€“** rtems\_message\_queue\_broadcast
  - **â€“** rtems\_message\_queue\_send
  - **â€“** rtems\_message\_queue\_urgent
- Signal Management
  - **â€“** rtems\_signal\_send
- Dual-Ported Memory Management
  - **â€“** rtems\_port\_external\_to\_internal
  - **â€“** rtems\_port\_internal\_to\_external
- IO Management The following services are safe to call from an ISR if and only if the device driver service invoked is also safe. The IO Manager itself is safe but the invoked driver entry point may or may not be.
  - **â€“** rtems\_io\_initialize
  - **â€“** rtems\_io\_open
  - **â€“** rtems\_io\_close
  - **â€“** rtems\_io\_read
  - **â€“** rtems\_io\_write
  - **â€“** rtems\_io\_control
- Fatal Error Management
  - **â€“** rtems\_fatal
  - **â€“** rtems\_fatal\_error\_occurred
- Multiprocessing
  - **â€“** rtems\_multiprocessing\_announce

# <span id="page-188-0"></span>9.4 Directives

This section details the directives of the Interrupt Manager. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

9.4. Directives 161

## <span id="page-189-1"></span><span id="page-189-0"></span>9.4.1 rtems\_interrupt\_catch()

Establishes an interrupt service routine.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_catch(
2 rtems_isr_entry new_isr_handler,
3 rtems_vector_number vector,
4 rtems_isr_entry *old_isr_handler
5 );
```

#### PARAMETERS:

#### **new\_isr\_handler**

This parameter is the new interrupt service routine.

#### **vector**

This parameter is the interrupt vector number.

#### **old\_isr\_handler**

This parameter is the pointer to an *[rtems\\_isr\\_entry](#page-74-2)* (page 47) object. When the directive call is successful, the previous interrupt service routine established for this interrupt vector will be stored in this object.

#### DESCRIPTION:

This directive establishes an interrupt service routine (ISR) for the interrupt specified by the vector number. The new\_isr\_handler parameter specifies the entry point of the ISR. The entry point of the previous ISR for the specified vector is returned in old\_isr\_handler.

To release an interrupt vector, pass the old handler's address obtained when the vector was first capture.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_NUMBER**

The interrupt vector number was illegal.

#### **RTEMS\_INVALID\_ADDRESS**

The new\_isr\_handler parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

## **RTEMS\_INVALID\_ADDRESS**

The old\_isr\_handler parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.

- The directive will not cause the calling task to be preempted.
- The directive is only available where the *[target architecture](#page-1076-2)* support enabled simple vectored interrupts.

9.4. Directives 163

## <span id="page-191-1"></span><span id="page-191-0"></span>9.4.2 rtems\_interrupt\_disable()

Disables the maskable interrupts on the current processor.

#### CALLING SEQUENCE:

```
1 void rtems_interrupt_disable( rtems_interrupt_level isr_cookie );
```

#### PARAMETERS:

#### **isr\_cookie**

This parameter is a variable of type *[rtems\\_interrupt\\_level](#page-71-2)* (page 44) which will be used to save the previous interrupt level.

#### DESCRIPTION:

This directive disables all maskable interrupts on the current processor and returns the previous interrupt level in isr\_cookie.

#### NOTES:

A later invocation of the *[rtems\\_interrupt\\_enable\(\)](#page-193-0)* (page 166) directive should be used to restore the previous interrupt level.

This directive is implemented as a macro which sets the isr\_cookie parameter.

```
1 #include <rtems.h>
3 void local_critical_section( void )
4 {
5 rtems_interrupt_level level;
6
7 // Please note that the rtems_interrupt_disable() is a macro. The
8 // previous interrupt level (before the maskable interrupts are
9 // disabled) is returned here in the level macro parameter. This
10 // would be wrong:
11 //
12 // rtems_interrupt_disable( &level );
13 rtems_interrupt_disable( level );
14
15 // Here is the critical section: maskable interrupts are disabled
16
17 {
18 rtems_interrupt_level nested_level;
19
20 rtems_interrupt_disable( nested_level );
21
22 // Here is a nested critical section
23
24 rtems_interrupt_enable( nested_level );
25 }
26
```

(continues on next page)

(continued from previous page)

```
27 // Maskable interrupts are still disabled
28
29 rtems_interrupt_enable( level );
30 }
```

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- Where the system was built with SMP support enabled, the directive is not available. Its use will result in compiler warnings and linker errors. The *[rtems\\_interrupt\\_local\\_disable\(\)](#page-195-0)* (page 168) and *[rtems\\_interrupt\\_local\\_enable\(\)](#page-197-0)* (page 170) directives are available in all build configurations.

9.4. Directives 165

## <span id="page-193-1"></span><span id="page-193-0"></span>9.4.3 rtems\_interrupt\_enable()

Restores the previous interrupt level on the current processor.

## CALLING SEQUENCE:

```
1 void rtems_interrupt_enable( rtems_interrupt_level isr_cookie );
```

#### PARAMETERS:

#### **isr\_cookie**

This parameter is the previous interrupt level to restore. The value must be obtained by a previous call to *[rtems\\_interrupt\\_disable\(\)](#page-191-0)* (page 164) or *[rtems\\_interrupt\\_flash\(\)](#page-194-0)* (page 167).

#### DESCRIPTION:

This directive restores the interrupt level specified by isr\_cookie on the current processor.

#### NOTES:

The isr\_cookie parameter value must be obtained by a previous call to *[rtems\\_interrupt\\_disable\(\)](#page-191-0)* (page 164) or *[rtems\\_interrupt\\_flash\(\)](#page-194-0)* (page 167). Using an otherwise obtained value is undefined behaviour.

This directive is unsuitable to enable particular interrupt sources, for example in an interrupt controller.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- While at least one maskable interrupt is pending, when the directive enables maskable interrupts, the pending interrupts are immediately serviced. The interrupt service routines may unblock higher priority tasks which may preempt the calling task.
- Where the system was built with SMP support enabled, the directive is not available. Its use will result in compiler warnings and linker errors. The *[rtems\\_interrupt\\_local\\_disable\(\)](#page-195-0)* (page 168) and *[rtems\\_interrupt\\_local\\_enable\(\)](#page-197-0)* (page 170) directives are available in all build configurations.

## <span id="page-194-1"></span><span id="page-194-0"></span>9.4.4 rtems\_interrupt\_flash()

Flashes interrupts on the current processor.

## CALLING SEQUENCE:

```
1 void rtems_interrupt_flash( rtems_interrupt_level isr_cookie );
```

### PARAMETERS:

#### **isr\_cookie**

This parameter is the previous interrupt level.

#### DESCRIPTION:

This directive is functionally equivalent to a calling *[rtems\\_interrupt\\_enable\(\)](#page-193-0)* (page 166) immediately followed by a *[rtems\\_interrupt\\_disable\(\)](#page-191-0)* (page 164). On some architectures it is possible to provide an optimized implementation for this sequence.

#### NOTES:

The isr\_cookie parameter value must be obtained by a previous call to *[rtems\\_interrupt\\_disable\(\)](#page-191-0)* (page 164) or *[rtems\\_interrupt\\_flash\(\)](#page-194-0)* (page 167). Using an otherwise obtained value is undefined behaviour.

Historically, the interrupt flash directive was heavily used in the operating system implementation. However, this is no longer the case. The interrupt flash directive is provided for backward compatibility reasons.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- Where the system was built with SMP support enabled, the directive is not available. Its use will result in compiler warnings and linker errors. The *[rtems\\_interrupt\\_local\\_disable\(\)](#page-195-0)* (page 168) and *[rtems\\_interrupt\\_local\\_enable\(\)](#page-197-0)* (page 170) directives are available in all build configurations.

9.4. Directives 167

## <span id="page-195-1"></span><span id="page-195-0"></span>9.4.5 rtems\_interrupt\_local\_disable()

Disables the maskable interrupts on the current processor.

#### CALLING SEQUENCE:

```
1 void rtems_interrupt_local_disable( rtems_interrupt_level isr_cookie );
```

#### PARAMETERS:

#### **isr\_cookie**

This parameter is a variable of type *[rtems\\_interrupt\\_level](#page-71-2)* (page 44) which will be used to save the previous interrupt level.

#### DESCRIPTION:

This directive disables all maskable interrupts on the current processor and returns the previous interrupt level in isr\_cookie.

#### NOTES:

A later invocation of the *[rtems\\_interrupt\\_local\\_enable\(\)](#page-197-0)* (page 170) directive should be used to restore the previous interrupt level.

This directive is implemented as a macro which sets the isr\_cookie parameter.

Where the system was built with SMP support enabled, this will not ensure system wide mutual exclusion. Use interrupt locks instead, see *[rtems\\_interrupt\\_lock\\_acquire\(\)](#page-201-0)* (page 174). Interrupt disabled critical sections may be used to access processor-specific data structures or disable thread dispatching.

```
1 #include <rtems.h>
2
3 void local_critical_section( void )
4 {
5 rtems_interrupt_level level;
6
7 // Please note that the rtems_interrupt_local_disable() is a macro.
8 // The previous interrupt level (before the maskable interrupts are
9 // disabled) is returned here in the level macro parameter. This would
10 // be wrong:
11 //
12 // rtems_interrupt_local_disable( &level );
13 rtems_interrupt_local_disable( level );
14
15 // Here is the critical section: maskable interrupts are disabled
16
17 {
18 rtems_interrupt_level nested_level;
19
20 rtems_interrupt_local_disable( nested_level );
21
22 // Here is a nested critical section
```

(continues on next page)

(continued from previous page)

```
23
24 rtems_interrupt_local_enable( nested_level );
25 }
26
27 // Maskable interrupts are still disabled
28
29 rtems_interrupt_local_enable( level );
30 }
```

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

9.4. Directives 169

## <span id="page-197-1"></span><span id="page-197-0"></span>9.4.6 rtems\_interrupt\_local\_enable()

Restores the previous interrupt level on the current processor.

## CALLING SEQUENCE:

```
1 void rtems_interrupt_local_enable( rtems_interrupt_level isr_cookie );
```

#### PARAMETERS:

#### **isr\_cookie**

This parameter is the previous interrupt level to restore. The value must be obtained by a previous call to *[rtems\\_interrupt\\_local\\_disable\(\)](#page-195-0)* (page 168).

#### DESCRIPTION:

This directive restores the interrupt level specified by isr\_cookie on the current processor.

## NOTES:

The isr\_cookie parameter value must be obtained by a previous call to *[rtems\\_interrupt\\_local\\_disable\(\)](#page-195-0)* (page 168). Using an otherwise obtained value is undefined behaviour.

This directive is unsuitable to enable particular interrupt sources, for example in an interrupt controller.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- While at least one maskable interrupt is pending, when the directive enables maskable interrupts, the pending interrupts are immediately serviced. The interrupt service routines may unblock higher priority tasks which may preempt the calling task.

## <span id="page-198-1"></span><span id="page-198-0"></span>9.4.7 rtems\_interrupt\_is\_in\_progress()

Checks if an ISR is in progress on the current processor.

## CALLING SEQUENCE:

```
1 bool rtems_interrupt_is_in_progress( void );
```

### DESCRIPTION:

This directive returns true, if the current processor is currently servicing an interrupt, and false otherwise. A return value of true indicates that the caller is an interrupt service routine, **not** a task. The directives available to an interrupt service routine are restricted.

## RETURN VALUES:

Returns true, if the current processor is currently servicing an interrupt, otherwise false.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

9.4. Directives 171

## <span id="page-199-1"></span><span id="page-199-0"></span>9.4.8 rtems\_interrupt\_lock\_initialize()

Initializes the ISR lock.

#### CALLING SEQUENCE:

```
1 void rtems_interrupt_lock_initialize(
2 rtems_interrupt_lock *lock,
3 const char *name
4 );
```

#### PARAMETERS:

#### **lock**

This parameter is the ISR lock to initialize.

#### **name**

This parameter is the ISR lock name. It shall be a string. The name is only used where the system was built with profiling support enabled.

#### NOTES:

ISR locks may also be statically defined by *[RTEMS\\_INTERRUPT\\_LOCK\\_DEFINE\(\)](#page-208-0)* (page 181) or statically initialized by *[RTEMS\\_INTERRUPT\\_LOCK\\_INITIALIZER\(\)](#page-209-0)* (page 182).

## <span id="page-200-1"></span><span id="page-200-0"></span>9.4.9 rtems\_interrupt\_lock\_destroy()

Destroys the ISR lock.

## CALLING SEQUENCE:

```
1 void rtems_interrupt_lock_destroy( rtems_interrupt_lock *lock );
```

### PARAMETERS:

## **lock**

This parameter is the ISR lock to destroy.

#### NOTES:

The lock must have been dynamically initialized by *[rtems\\_interrupt\\_lock\\_initialize\(\)](#page-199-0)* (page 172), statically defined by *[RTEMS\\_INTERRUPT\\_LOCK\\_DEFINE\(\)](#page-208-0)* (page 181), or statically initialized by *[RTEMS\\_INTERRUPT\\_LOCK\\_INITIALIZER\(\)](#page-209-0)* (page 182).

Concurrent lock use during the destruction or concurrent destruction leads to unpredictable results.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

9.4. Directives 173

## <span id="page-201-1"></span><span id="page-201-0"></span>9.4.10 rtems\_interrupt\_lock\_acquire()

Acquires the ISR lock.

## CALLING SEQUENCE:

```
1 void rtems_interrupt_lock_acquire(
2 rtems_interrupt_lock *lock,
3 rtems_interrupt_lock_context *lock_context
4 );
```

#### PARAMETERS:

#### **lock**

This parameter is the ISR lock to acquire.

#### **lock\_context**

This parameter is the ISR lock context. This lock context shall be used to release the lock by calling *[rtems\\_interrupt\\_lock\\_release\(\)](#page-203-0)* (page 176).

#### DESCRIPTION:

This directive acquires the ISR lock specified by lock using the lock context provided by lock\_context. Maskable interrupts will be disabled on the current processor.

#### NOTES:

A caller-specific lock context shall be provided for each acquire/release pair, for example an automatic variable.

Where the system was built with SMP support enabled, this directive acquires an SMP lock. An attempt to recursively acquire the lock may result in an infinite loop with maskable interrupts disabled.

This directive establishes a non-preemptive critical section with system wide mutual exclusion on the local node in all RTEMS build configurations.

```
1 #include <rtems.h>
2
3 void critical_section( rtems_interrupt_lock *lock )
4 {
5 rtems_interrupt_lock_context lock_context;
6
7 rtems_interrupt_lock_acquire( lock, &lock_context );
8
9 // Here is the critical section. Maskable interrupts are disabled.
10 // Where the system was built with SMP support enabled, this section
11 // is protected by an SMP lock.
12
13 rtems_interrupt_lock_release( lock, &lock_context );
14 }
```

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

9.4. Directives 175

## <span id="page-203-1"></span><span id="page-203-0"></span>9.4.11 rtems\_interrupt\_lock\_release()

Releases the ISR lock.

#### CALLING SEQUENCE:

```
1 void rtems_interrupt_lock_release( rtems_interrupt_lock_context *lock );
```

#### PARAMETERS:

#### **lock**

This parameter is the ISR lock to release.

#### **lock\_context**

This parameter is the ISR lock context. This lock context shall have been used to acquire the lock by calling *[rtems\\_interrupt\\_lock\\_acquire\(\)](#page-201-0)* (page 174).

#### DESCRIPTION:

This directive releases the ISR lock specified by lock using the lock context provided by lock\_context. The previous interrupt level will be restored on the current processor.

#### NOTES:

The lock context shall be the one used to acquire the lock, otherwise the result is unpredictable.

Where the system was built with SMP support enabled, this directive releases an SMP lock.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- While at least one maskable interrupt is pending, when the directive enables maskable interrupts, the pending interrupts are immediately serviced. The interrupt service routines may unblock higher priority tasks which may preempt the calling task.

## <span id="page-204-1"></span><span id="page-204-0"></span>9.4.12 rtems\_interrupt\_lock\_acquire\_isr()

Acquires the ISR lock from within an ISR.

#### CALLING SEQUENCE:

```
1 void rtems_interrupt_lock_acquire_isr(
2 rtems_interrupt_lock *lock,
3 rtems_interrupt_lock_context *lock_context
4 );
```

#### PARAMETERS:

## **lock**

This parameter is the ISR lock to acquire within an ISR.

#### **lock\_context**

This parameter is the ISR lock context. This lock context shall be used to release the lock by calling *[rtems\\_interrupt\\_lock\\_release\\_isr\(\)](#page-205-0)* (page 178).

#### DESCRIPTION:

This directive acquires the ISR lock specified by lock using the lock context provided by lock\_context. The interrupt level will remain unchanged.

#### NOTES:

A caller-specific lock context shall be provided for each acquire/release pair, for example an automatic variable.

Where the system was built with SMP support enabled, this directive acquires an SMP lock. An attempt to recursively acquire the lock may result in an infinite loop.

This directive is intended for device drivers and should be called from the corresponding interrupt service routine.

In case the corresponding interrupt service routine can be interrupted by higher priority interrupts and these interrupts enter the critical section protected by this lock, then the result is unpredictable. This directive may be used under specific circumstances as an optimization. In doubt, use *[rtems\\_interrupt\\_lock\\_acquire\(\)](#page-201-0)* (page 174) and *[rtems\\_interrupt\\_lock\\_release\(\)](#page-203-0)* (page 176).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

9.4. Directives 177

## <span id="page-205-1"></span><span id="page-205-0"></span>9.4.13 rtems\_interrupt\_lock\_release\_isr()

Releases the ISR lock from within an ISR.

## CALLING SEQUENCE:

```
1 void rtems_interrupt_lock_release_isr(
2 rtems_interrupt_lock *lock,
3 rtems_interrupt_lock_context *lock_context
4 );
```

#### PARAMETERS:

## **lock**

This parameter is the ISR lock to release within an ISR.

#### **lock\_context**

This parameter is the ISR lock context. This lock context shall have been used to acquire the lock by calling *[rtems\\_interrupt\\_lock\\_acquire\\_isr\(\)](#page-204-0)* (page 177).

#### DESCRIPTION:

This directive releases the ISR lock specified by lock using the lock context provided by lock\_context. The interrupt level will remain unchanged.

#### NOTES:

The lock context shall be the one used to acquire the lock, otherwise the result is unpredictable.

Where the system was built with SMP support enabled, this directive releases an SMP lock.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-206-1"></span><span id="page-206-0"></span>9.4.14 rtems\_interrupt\_lock\_interrupt\_disable()

Disables maskable interrupts on the current processor.

#### CALLING SEQUENCE:

```
1 void rtems_interrupt_lock_interrupt_disable(
2 rtems_interrupt_lock_context *lock_context
3 );
```

#### PARAMETERS:

#### **lock\_context**

This parameter is the ISR lock context for an acquire and release pair.

#### DESCRIPTION:

This directive disables maskable interrupts on the current processor and stores the previous interrupt level in lock\_context.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

9.4. Directives 179

## <span id="page-207-1"></span><span id="page-207-0"></span>9.4.15 RTEMS\_INTERRUPT\_LOCK\_DECLARE()

Declares an ISR lock object.

#### CALLING SEQUENCE:

```
1 RTEMS_INTERRUPT_LOCK_DECLARE( specifier, designator );
```

#### PARAMETERS:

#### **specifier**

This parameter is the storage-class specifier for the ISR lock to declare, for example extern or static.

#### **designator**

This parameter is the ISR lock object designator.

#### NOTES:

Do not add a ";" after this macro.

## <span id="page-208-1"></span><span id="page-208-0"></span>9.4.16 RTEMS\_INTERRUPT\_LOCK\_DEFINE()

Defines an ISR lock object.

#### CALLING SEQUENCE:

```
1 RTEMS_INTERRUPT_LOCK_DEFINE( specifier, designator, const char *name );
```

#### PARAMETERS:

#### **specifier**

This parameter is the storage-class specifier for the ISR lock to declare, for example extern or static.

#### **designator**

This parameter is the ISR lock object designator.

#### **name**

This parameter is the ISR lock name. It shall be a string. The name is only used where the system was built with profiling support enabled.

#### NOTES:

Do not add a ";" after this macro.

ISR locks may also be dynamically initialized by *[rtems\\_interrupt\\_lock\\_initialize\(\)](#page-199-0)* (page 172) or statically by *[RTEMS\\_INTERRUPT\\_LOCK\\_INITIALIZER\(\)](#page-209-0)* (page 182).

9.4. Directives 181

## <span id="page-209-1"></span><span id="page-209-0"></span>9.4.17 RTEMS\_INTERRUPT\_LOCK\_INITIALIZER()

Statically initializes an ISR lock object.

## CALLING SEQUENCE:

```
1 RTEMS_INTERRUPT_LOCK_INITIALIZER( const char *name );
```

#### PARAMETERS:

#### **name**

This parameter is the ISR lock name. It shall be a string. The name is only used where the system was built with profiling support enabled.

#### NOTES:

ISR locks may also be dynamically initialized by *[rtems\\_interrupt\\_lock\\_initialize\(\)](#page-199-0)* (page 172) or statically defined by *[RTEMS\\_INTERRUPT\\_LOCK\\_DEFINE\(\)](#page-208-0)* (page 181).

## <span id="page-210-1"></span><span id="page-210-0"></span>9.4.18 RTEMS\_INTERRUPT\_LOCK\_MEMBER()

Defines an ISR lock member.

## CALLING SEQUENCE:

```
1 RTEMS_INTERRUPT_LOCK_MEMBER( designator );
```

#### PARAMETERS:

#### **designator**

This parameter is the ISR lock member designator.

#### NOTES:

Do not add a ";" after this macro.

9.4. Directives 183

## <span id="page-211-1"></span><span id="page-211-0"></span>9.4.19 RTEMS\_INTERRUPT\_LOCK\_REFERENCE()

Defines an ISR lock object reference.

## CALLING SEQUENCE:

```
1 RTEMS_INTERRUPT_LOCK_REFERENCE( designator, rtems_interrupt_lock *target );
```

### PARAMETERS:

#### **designator**

This parameter is the ISR lock reference designator.

#### **target**

This parameter is the target object to reference.

#### NOTES:

Do not add a ";" after this macro.

## <span id="page-212-1"></span><span id="page-212-0"></span>9.4.20 RTEMS\_INTERRUPT\_ENTRY\_INITIALIZER()

Statically initializes an interrupt entry object.

#### CALLING SEQUENCE:

```
1 RTEMS_INTERRUPT_ENTRY_INITIALIZER(
2 rtems_interrupt_handler routine,
3 void *arg,
4 const char *info
5 );
```

#### PARAMETERS:

#### **routine**

This parameter is the interrupt handler routine for the entry.

#### **arg**

This parameter is the interrupt handler argument for the entry.

#### **info**

This parameter is the descriptive information for the entry.

## NOTES:

Alternatively, *[rtems\\_interrupt\\_entry\\_initialize\(\)](#page-213-0)* (page 186) may be used to dynamically initialize an interrupt entry.

9.4. Directives 185

## <span id="page-213-1"></span><span id="page-213-0"></span>9.4.21 rtems\_interrupt\_entry\_initialize()

Initializes the interrupt entry.

#### CALLING SEQUENCE:

```
1 void rtems_interrupt_entry_initialize(
2 rtems_interrupt_entry *entry,
3 rtems_interrupt_handler routine,
4 void *arg,
5 const char *info
6 );
```

#### PARAMETERS:

#### **entry**

This parameter is the interrupt entry to initialize.

#### **routine**

This parameter is the interrupt handler routine for the entry.

#### **arg**

This parameter is the interrupt handler argument for the entry.

## **info**

This parameter is the descriptive information for the entry.

#### NOTES:

Alternatively, *[RTEMS\\_INTERRUPT\\_ENTRY\\_INITIALIZER\(\)](#page-212-0)* (page 185) may be used to statically initialize an interrupt entry.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-214-1"></span><span id="page-214-0"></span>9.4.22 rtems\_interrupt\_entry\_install()

Installs the interrupt entry at the interrupt vector.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_entry_install(
2 rtems_vector_number vector,
3 rtems_option options,
4 rtems_interrupt_entry *entry
5 );
```

#### PARAMETERS:

#### **vector**

This parameter is the interrupt vector number.

#### **options**

This parameter is the interrupt entry install option set.

#### **entry**

This parameter is the interrupt entry to install.

## DESCRIPTION:

One of the following mutually exclusive options

- RTEMS\_INTERRUPT\_UNIQUE, and
- RTEMS\_INTERRUPT\_SHARED

shall be set in the options parameter.

The handler routine of the entry specified by entry will be called with the handler argument of the entry when dispatched. The order in which shared interrupt handlers are dispatched for one vector is defined by the installation order. The first installed handler is dispatched first.

If the option RTEMS\_INTERRUPT\_UNIQUE is set, then it will be ensured that the handler will be the only one for the interrupt vector.

If the option RTEMS\_INTERRUPT\_SHARED is set, then multiple handlers may be installed for the interrupt vector.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The entry parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INCORRECT\_STATE**

The service was not initialized.

## **RTEMS\_INVALID\_ADDRESS**

The handler routine of the entry was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no interrupt vector associated with the number specified by vector.

9.4. Directives 187

#### **RTEMS\_CALLED\_FROM\_ISR**

The directive was called from within interrupt context.

#### **RTEMS\_INVALID\_NUMBER**

An option specified by options was not applicable.

#### **RTEMS\_RESOURCE\_IN\_USE**

The RTEMS\_INTERRUPT\_UNIQUE option was set in entry and the interrupt vector was already occupied by a handler.

## **RTEMS\_RESOURCE\_IN\_USE**

The RTEMS\_INTERRUPT\_SHARED option was set in entry and the interrupt vector was already occupied by a unique handler.

#### **RTEMS\_TOO\_MANY**

The handler routine of the entry specified by entry was already installed for the interrupt vector specified by vector with an argument equal to the handler argument of the entry.

#### NOTES:

When the directive call was successful, the ownership of the interrupt entry has been transferred from the caller to the interrupt service. An installed interrupt entry may be removed from the interrupt service by calling *[rtems\\_interrupt\\_entry\\_remove\(\)](#page-216-0)* (page 189).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- The interrupt entry shall have been initialized by *[rtems\\_interrupt\\_entry\\_initialize\(\)](#page-213-0)* (page 186) or *[RTEMS\\_INTERRUPT\\_ENTRY\\_INITIALIZER\(\)](#page-212-0)* (page 185).

## <span id="page-216-1"></span><span id="page-216-0"></span>9.4.23 rtems\_interrupt\_entry\_remove()

Removes the interrupt entry from the interrupt vector.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_entry_remove(
2 rtems_vector_number vector,
3 rtems_interrupt_entry *entry
4 );
```

#### PARAMETERS:

#### **vector**

This parameter is the interrupt vector number.

#### **entry**

This parameter is the interrupt entry to remove.

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INCORRECT\_STATE**

The service was not initialized.

#### **RTEMS\_INVALID\_ADDRESS**

The entry parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

### **RTEMS\_INVALID\_ID**

There was no interrupt vector associated with the number specified by vector.

## **RTEMS\_CALLED\_FROM\_ISR**

The directive was called from within interrupt context.

#### **RTEMS\_UNSATISFIED**

The entry specified by entry was not installed at the interrupt vector specified by vector.

#### NOTES:

When the directive call was successful, the ownership of the interrupt entry has been transferred from the interrupt service to the caller.

# CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- The interrupt entry shall have been installed by *[rtems\\_interrupt\\_entry\\_install\(\)](#page-214-0)* (page 187).

9.4. Directives 189

## <span id="page-217-1"></span><span id="page-217-0"></span>9.4.24 rtems\_interrupt\_handler\_install()

Installs the interrupt handler routine and argument at the interrupt vector.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_handler_install(
2 rtems_vector_number vector,
3 const char *info,
4 rtems_option options,
5 rtems_interrupt_handler routine,
6 void *arg
7 );
```

#### PARAMETERS:

#### **vector**

This parameter is the interrupt vector number.

#### **info**

This parameter is the descriptive information of the interrupt handler to install.

#### **options**

This parameter is the interrupt handler install option set.

#### **routine**

This parameter is the interrupt handler routine to install.

#### **arg**

This parameter is the interrupt handler argument to install.

## DESCRIPTION:

One of the following mutually exclusive options

- RTEMS\_INTERRUPT\_UNIQUE,
- RTEMS\_INTERRUPT\_SHARED, and
- RTEMS\_INTERRUPT\_REPLACE

shall be set in the options parameter.

The handler routine will be called with the argument specified by arg when dispatched. The order in which shared interrupt handlers are dispatched for one vector is defined by the installation order. The first installed handler is dispatched first.

If the option RTEMS\_INTERRUPT\_UNIQUE is set, then it will be ensured that the handler will be the only one for the interrupt vector.

If the option RTEMS\_INTERRUPT\_SHARED is set, then multiple handler may be installed for the interrupt vector.

If the option RTEMS\_INTERRUPT\_REPLACE is set, then the handler specified by routine will replace the first handler with the same argument for the interrupt vector if it exists, otherwise an error status will be returned. A second handler with the same argument for the interrupt vector will remain unchanged. The new handler will inherit the unique or shared options from the replaced handler.

An informative description may be provided in info. It may be used for system debugging and diagnostic tools. The referenced string has to be persistent as long as the handler is installed.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INCORRECT\_STATE**

The service was not initialized.

#### **RTEMS\_INVALID\_ADDRESS**

The routine parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no interrupt vector associated with the number specified by vector.

## **RTEMS\_CALLED\_FROM\_ISR**

The directive was called from within interrupt context.

#### **RTEMS\_NO\_MEMORY**

There was not enough memory available to allocate data structures to install the handler.

#### **RTEMS\_RESOURCE\_IN\_USE**

The RTEMS\_INTERRUPT\_UNIQUE option was set in options and the interrupt vector was already occupied by a handler.

#### **RTEMS\_RESOURCE\_IN\_USE**

The RTEMS\_INTERRUPT\_SHARED option was set in options and the interrupt vector was already occupied by a unique handler.

#### **RTEMS\_TOO\_MANY**

The handler specified by routine was already installed for the interrupt vector specified by vector with an argument equal to the argument specified by arg.

#### **RTEMS\_UNSATISFIED**

The RTEMS\_INTERRUPT\_REPLACE option was set in options and no handler to replace was installed.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

9.4. Directives 191

## <span id="page-219-1"></span><span id="page-219-0"></span>9.4.25 rtems\_interrupt\_handler\_remove()

Removes the interrupt handler routine and argument from the interrupt vector.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_handler_remove(
2 rtems_vector_number vector,
3 rtems_interrupt_handler routine,
4 void *arg
5 );
```

#### PARAMETERS:

#### **vector**

This parameter is the interrupt vector number.

#### **routine**

This parameter is the interrupt handler routine to remove.

#### **arg**

This parameter is the interrupt handler argument to remove.

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INCORRECT\_STATE**

The service was not initialized.

## **RTEMS\_INVALID\_ADDRESS**

The routine parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no interrupt vector associated with the number specified by vector.

#### **RTEMS\_CALLED\_FROM\_ISR**

The directive was called from within interrupt context.

## **RTEMS\_UNSATISFIED**

There was no handler routine and argument pair installed specified by routine and arg.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

## <span id="page-220-1"></span><span id="page-220-0"></span>9.4.26 rtems\_interrupt\_vector\_is\_enabled()

Checks if the interrupt vector is enabled.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_vector_is_enabled(
2 rtems_vector_number vector,
3 bool *enabled
4 );
```

#### PARAMETERS:

#### **vector**

This parameter is the interrupt vector number.

#### **enabled**

This parameter is the pointer to a bool object. When the directive call is successful, the enabled status of the interrupt associated with the interrupt vector specified by vector will be stored in this object. When the interrupt was enabled for the processor executing the directive call at some time point during the call, the object value will be set to true, otherwise to false.

## DESCRIPTION:

The directive checks if the interrupt associated with the interrupt vector specified by vector was enabled for the processor executing the directive call at some time point during the call.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The enabled parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

## **RTEMS\_INVALID\_ID**

There was no interrupt vector associated with the number specified by vector.

## NOTES:

Interrupt vectors may be enabled by *[rtems\\_interrupt\\_vector\\_enable\(\)](#page-221-0)* (page 194) and disabled by *[rtems\\_interrupt\\_vector\\_disable\(\)](#page-222-0)* (page 195).

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

9.4. Directives 193

## <span id="page-221-1"></span><span id="page-221-0"></span>9.4.27 rtems\_interrupt\_vector\_enable()

Enables the interrupt vector.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_vector_enable( rtems_vector_number vector );
```

#### PARAMETERS:

## **vector**

This parameter is the number of the interrupt vector to enable.

#### DESCRIPTION:

The directive enables the interrupt vector specified by vector. This allows that interrupt service requests are issued to the target processors of the interrupt vector. Interrupt service requests for an interrupt vector may be raised by *[rtems\\_interrupt\\_raise\(\)](#page-225-0)* (page 198), *[rtems\\_interrupt\\_raise\\_on\(\)](#page-226-0)* (page 199), external signals, or messages.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ID**

There was no interrupt vector associated with the number specified by vector.

#### **RTEMS\_UNSATISFIED**

The request to enable the interrupt vector has not been satisfied.

## NOTES:

The *[rtems\\_interrupt\\_get\\_attributes\(\)](#page-234-0)* (page 207) directive may be used to check if an interrupt vector can be enabled. Interrupt vectors may be disabled by *[rtems\\_interrupt\\_vector\\_disable\(\)](#page-222-0)* (page 195).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

## <span id="page-222-1"></span><span id="page-222-0"></span>9.4.28 rtems\_interrupt\_vector\_disable()

Disables the interrupt vector.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_vector_disable( rtems_vector_number vector );
```

#### PARAMETERS:

#### **vector**

This parameter is the number of the interrupt vector to disable.

#### DESCRIPTION:

The directive disables the interrupt vector specified by vector. This prevents that an interrupt service request is issued to the target processors of the interrupt vector.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no interrupt vector associated with the number specified by vector.

## **RTEMS\_UNSATISFIED**

The request to disable the interrupt vector has not been satisfied.

## NOTES:

The *[rtems\\_interrupt\\_get\\_attributes\(\)](#page-234-0)* (page 207) directive may be used to check if an interrupt vector can be disabled. Interrupt vectors may be enabled by *[rtems\\_interrupt\\_vector\\_enable\(\)](#page-221-0)* (page 194). There may be targets on which some interrupt vectors cannot be disabled, for example a hardware watchdog interrupt or software generated interrupts.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

9.4. Directives 195

## <span id="page-223-1"></span><span id="page-223-0"></span>9.4.29 rtems\_interrupt\_is\_pending()

Checks if the interrupt is pending.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_is_pending(
2 rtems_vector_number vector,
3 bool *pending
4 );
```

#### PARAMETERS:

#### **vector**

This parameter is the interrupt vector number.

#### **pending**

This parameter is the pointer to a bool object. When the directive call is successful, the pending status of the interrupt associated with the interrupt vector specified by vector will be stored in this object. When the interrupt was pending for the processor executing the directive call at some time point during the call, the object value will be set to true, otherwise to false.

#### DESCRIPTION:

The directive checks if the interrupt associated with the interrupt vector specified by vector was pending for the processor executing the directive call at some time point during the call.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ADDRESS**

The pending parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no interrupt vector associated with the number specified by vector.

#### **RTEMS\_UNSATISFIED**

The request to get the pending status has not been satisfied.

#### NOTES:

Interrupts may be made pending by calling the *[rtems\\_interrupt\\_raise\(\)](#page-225-0)* (page 198) or *[rtems\\_interrupt\\_raise\\_on\(\)](#page-226-0)* (page 199) directives or due to external signals or messages. The pending state may be cleared by *[rtems\\_interrupt\\_clear\(\)](#page-227-0)* (page 200).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.

â€¢ The directive will not cause the calling task to be preempted.

9.4. Directives 197

## <span id="page-225-1"></span><span id="page-225-0"></span>9.4.30 rtems\_interrupt\_raise()

Raises the interrupt vector.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_raise( rtems_vector_number vector );
```

#### PARAMETERS:

#### **vector**

This parameter is the number of the interrupt vector to raise.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no interrupt vector associated with the number specified by vector.

#### **RTEMS\_UNSATISFIED**

The request to raise the interrupt vector has not been satisfied.

#### NOTES:

The *[rtems\\_interrupt\\_get\\_attributes\(\)](#page-234-0)* (page 207) directive may be used to check if an interrupt vector can be raised.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

## <span id="page-226-1"></span><span id="page-226-0"></span>9.4.31 rtems\_interrupt\_raise\_on()

Raises the interrupt vector on the processor.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_raise_on(
2 rtems_vector_number vector,
3 uint32_t cpu_index
4 );
```

#### PARAMETERS:

#### **vector**

This parameter is the number of the interrupt vector to raise.

## **cpu\_index**

This parameter is the index of the target processor of the interrupt vector to raise.

## RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no interrupt vector associated with the number specified by vector.

#### **RTEMS\_NOT\_CONFIGURED**

The processor specified by cpu\_index was not configured to be used by the application.

### **RTEMS\_INCORRECT\_STATE**

The processor specified by cpu\_index was configured to be used by the application, however, it was not online.

#### **RTEMS\_UNSATISFIED**

The request to raise the interrupt vector has not been satisfied.

#### NOTES:

The *[rtems\\_interrupt\\_get\\_attributes\(\)](#page-234-0)* (page 207) directive may be used to check if an interrupt vector can be raised on a processor.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

9.4. Directives 199

## <span id="page-227-1"></span><span id="page-227-0"></span>9.4.32 rtems\_interrupt\_clear()

Clears the interrupt vector.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_clear( rtems_vector_number vector );
```

#### PARAMETERS:

#### **vector**

This parameter is the number of the interrupt vector to clear.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no interrupt vector associated with the number specified by vector.

#### **RTEMS\_UNSATISFIED**

The request to raise the interrupt vector has not been satisfied.

#### NOTES:

The *[rtems\\_interrupt\\_get\\_attributes\(\)](#page-234-0)* (page 207) directive may be used to check if an interrupt vector can be cleared.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

## <span id="page-228-1"></span><span id="page-228-0"></span>9.4.33 rtems\_interrupt\_get\_priority()

Gets the priority of the interrupt vector.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_get_priority(
2 rtems_vector_number vector,
3 uint32_t *priority
4 );
```

#### PARAMETERS:

#### **vector**

This parameter is the interrupt vector number.

## **priority**

This parameter is the pointer to an [uint32\\_t](https://en.cppreference.com/w/c/types/integer) object. When the directive call is successful, the priority of the interrupt vector will be stored in this object.

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ADDRESS**

The priority parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no interrupt vector associated with the number specified by vector.

## **RTEMS\_UNSATISFIED**

There is no priority associated with the interrupt vector.

## NOTES:

The *[rtems\\_interrupt\\_set\\_priority\(\)](#page-229-0)* (page 202) directive may be used to set the priority associated with an interrupt vector.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

9.4. Directives 201

## <span id="page-229-1"></span><span id="page-229-0"></span>9.4.34 rtems\_interrupt\_set\_priority()

Sets the priority of the interrupt vector.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_set_priority(
2 rtems_vector_number vector,
3 uint32_t priority
4 );
```

#### PARAMETERS:

#### **vector**

This parameter is the interrupt vector number.

## **priority**

This parameter is the new priority for the interrupt vector.

#### DESCRIPTION:

This directive sets the priority of the interrupt specified by vector to the priority specified by priority.

For processor-specific interrupts, the priority of the interrupt specific to a processor executing the directive call will be set.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no interrupt vector associated with the number specified by vector.

## **RTEMS\_INVALID\_PRIORITY**

The priority specified by priority was not a valid new priority for the interrupt vector.

## **RTEMS\_UNSATISFIED**

The request to set the priority of the interrupt vector has not been satisfied.

#### NOTES:

The *[rtems\\_interrupt\\_get\\_priority\(\)](#page-228-0)* (page 201) directive may be used to get the priority associated with an interrupt vector.

The interrupt prioritization support depends on the interrupt controller of the *[target](#page-1076-0)*. It is strongly recommended to read the relevant hardware documentation. What happens when the priority of a pending or active interrupt is changed, depends on the interrupt controller. In general, you should set the interrupt priority of an interrupt vector before a handler is installed. On some interrupt controllers, setting the priority to the maximum value (lowest importance) effectively disables the interrupt.

On some architectures, a range of interrupt priority values may be not disabled by the interrupt disable directives such as *[rtems\\_interrupt\\_disable\(\)](#page-191-0)* (page 164) and *[rtems\\_interrupt\\_local\\_disable\(\)](#page-195-0)* (page 168). These interrupts are called non-maskable interrupts. Handlers of non-maskable interrupts shall not use operating system services. In addition, non-maskable interrupts may be not installable through *[rtems\\_interrupt\\_entry\\_install\(\)](#page-214-0)* (page 187) or *[rtems\\_interrupt\\_handler\\_install\(\)](#page-217-0)* (page 190), and may require architecturespecific prologue and epilogue code.

The interrupt priority settings affect the maximum nesting depth while servicing interrupts. The interrupt stack size calculation needs to take this into account, see also *[CONFIG-](#page-603-0)[URE\\_INTERRUPT\\_STACK\\_SIZE](#page-603-0)* (page 576).

For the ARM Generic Interrupt Controller (GIC), an 8-bit priority value is supported. The granularity of the priority levels depends on the interrupt controller configuration. Some low-order bits of a priority value may be read-as-zero (RAZ) and writes are ignored (WI). Where group 0 (FIQ) and group 1 (IRQ) interrupts are used, it is recommended to use the lower half of the supported priority value range for the group 0 interrupts and the upper half for group 1 interrupts. This ensures that group 1 interrupts cannot preempt group 0 interrupts.

For the Armv7-M Nested Vector Interrupt Controller (NVIC), an 8-bit priority value is supported. The granularity of the priority levels depends on the interrupt controller configuration. Some lower bits of a priority value may be read-as-zero (RAZ) and writes are ignored (WI). Interrupts with a priority value less than 128 are not disabled by the RTEMS interrupt disable directives. Handlers of such interrupts shall not use operating system services.

For the RISC-V Platform-Level Interrupt Controller (PLIC), all priority values from 0 up to and including the 0xffffffff are supported since the priority for the PLIC is defined by a write-anyread-legal (WARL) register. Please note that for this directive in contrast to the PLIC, a higher priority value is associated with a lower importance. The maximum priority value (mapped to the value 0 for the PLIC) is reserved to mean "never interrupt" and effectively disables the interrupt.

For the QorIQ Multicore Programmable Interrupt Controller (MPIC), a 4-bit priority value is supported. Please note that for this directive in contrast to the MPIC, a higher priority value is associated with a lower importance. The maximum priority value of 15 (mapped to the value 0 for the MPIC) inhibits signalling of this interrupt.

Consult the *RTEMS CPU Architecture Supplement* and the *[BSP](#page-1061-0)* documentation in the *RTEMS User Manual* for further information.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

9.4. Directives 203

## <span id="page-231-1"></span><span id="page-231-0"></span>9.4.35 rtems\_interrupt\_get\_affinity()

Gets the processor affinity set of the interrupt vector.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_get_affinity(
2 rtems_vector_number vector,
3 size_t affinity_size,
4 cpu_set_t *affinity
5 );
```

#### PARAMETERS:

#### **vector**

This parameter is the interrupt vector number.

#### **affinity\_size**

This parameter is the size of the processor set referenced by affinity in bytes.

#### **affinity**

This parameter is the pointer to a cpu\_set\_t object. When the directive call is successful, the processor affinity set of the interrupt vector will be stored in this object. A set bit in the processor set means that the corresponding processor is in the processor affinity set of the interrupt vector, otherwise the bit is cleared.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ADDRESS**

The affinity parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no interrupt vector associated with the number specified by vector.

#### **RTEMS\_INVALID\_SIZE**

The size specified by affinity\_size of the processor set was too small for the processor affinity set of the interrupt vector.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

## <span id="page-232-1"></span><span id="page-232-0"></span>9.4.36 rtems\_interrupt\_set\_affinity()

Sets the processor affinity set of the interrupt vector.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_set_affinity(
2 rtems_vector_number vector,
3 size_t affinity_size,
4 const cpu_set_t *affinity
5 );
```

#### PARAMETERS:

#### **vector**

This parameter is the interrupt vector number.

#### **affinity\_size**

This parameter is the size of the processor set referenced by affinity in bytes.

#### **affinity**

This parameter is the pointer to a cpu\_set\_t object. The processor set defines the new processor affinity set of the interrupt vector. A set bit in the processor set means that the corresponding processor shall be in the processor affinity set of the interrupt vector, otherwise the bit shall be cleared.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ADDRESS**

The affinity parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no interrupt vector associated with the number specified by vector.

#### **RTEMS\_INVALID\_NUMBER**

The referenced processor set was not a valid new processor affinity set for the interrupt vector.

## **RTEMS\_UNSATISFIED**

The request to set the processor affinity of the interrupt vector has not been satisfied.

## NOTES:

The *[rtems\\_interrupt\\_get\\_attributes\(\)](#page-234-0)* (page 207) directive may be used to check if the processor affinity of an interrupt vector can be set.

Only online processors of the affinity set specified by affinity\_size and affinity are considered by the directive. Other processors of the set are ignored. If the set contains no online processor, then the set is invalid and an error status is returned.

9.4. Directives 205

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

## <span id="page-234-1"></span><span id="page-234-0"></span>9.4.37 rtems\_interrupt\_get\_attributes()

Gets the attributes of the interrupt vector.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_get_attributes(
2 rtems_vector_number vector,
3 rtems_interrupt_attributes *attributes
4 );
```

#### PARAMETERS:

#### **vector**

This parameter is the interrupt vector number.

#### **attributes**

This parameter is the pointer to an *[rtems\\_interrupt\\_attributes](#page-69-1)* (page 42) object. When the directive call is successful, the attributes of the interrupt vector will be stored in this object.

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The attributes parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no interrupt vector associated with the number specified by vector.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

9.4. Directives 207

## <span id="page-235-1"></span><span id="page-235-0"></span>9.4.38 rtems\_interrupt\_handler\_iterate()

Iterates over all interrupt handler installed at the interrupt vector.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_handler_iterate(
2 rtems_vector_number vector,
3 rtems_interrupt_per_handler_routine routine,
4 void *arg
5 );
```

#### PARAMETERS:

#### **vector**

This parameter is the interrupt vector number.

#### **routine**

This parameter is the visitor routine.

#### **arg**

This parameter is the visitor argument.

## DESCRIPTION:

For each installed handler at the interrupt vector the visitor function specified by routine will be called with the argument specified by arg and the handler information, options, routine and argument.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INCORRECT\_STATE**

The service was not initialized.

## **RTEMS\_INVALID\_ADDRESS**

The routine parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no interrupt vector associated with the number specified by vector.

#### **RTEMS\_CALLED\_FROM\_ISR**

The directive was called from within interrupt context.

#### NOTES:

The directive is intended for system information and diagnostics.

Never install or remove an interrupt handler within the visitor function. This may result in a deadlock.

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

9.4. Directives 209

## <span id="page-237-1"></span><span id="page-237-0"></span>9.4.39 rtems\_interrupt\_server\_initialize()

Initializes the interrupt server tasks.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_server_initialize(
2 rtems_task_priority priority,
3 size_t stack_size,
4 rtems_mode modes,
5 rtems_attribute attributes,
6 uint32_t *server_count
7 );
```

#### PARAMETERS:

#### **priority**

This parameter is the initial *[task priority](#page-1077-3)* of the created interrupt servers.

#### **stack\_size**

This parameter is the task stack size of the created interrupt servers.

### **modes**

This parameter is the initial mode set of the created interrupt servers.

#### **attributes**

This parameter is the attribute set of the created interrupt servers.

#### **server\_count**

This parameter is the pointer to an [uint32\\_t](https://en.cppreference.com/w/c/types/integer) object or [NULL.](https://en.cppreference.com/w/c/types/NULL) When the pointer is not equal to [NULL,](https://en.cppreference.com/w/c/types/NULL) the count of successfully created interrupt servers is stored in this object regardless of the return status.

#### DESCRIPTION:

The directive tries to create an interrupt server task for each online processor in the system. The tasks will have the initial priority specified by priority, the stack size specified by stack\_size, the initial mode set specified by modes, and the attribute set specified by attributes. The count of successfully created server tasks will be returned in server\_count if the pointer is not equal to [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INCORRECT\_STATE**

The interrupt servers were already initialized.

The directive uses *[rtems\\_task\\_create\(\)](#page-136-0)* (page 109). If this directive fails, then its error status will be returned.

### NOTES:

Interrupt handlers may be installed on an interrupt server with *[rtems\\_interrupt\\_server\\_handler\\_install\(\)](#page-240-0)* (page 213) and removed with *[rtems\\_interrupt\\_server\\_handler\\_remove\(\)](#page-242-0)* (page 215) using a server index. In case of an interrupt, the request will be forwarded to the interrupt server. The handlers are executed within the interrupt server context. If one handler blocks on something this may delay the processing of other handlers.

Interrupt servers may be deleted by *[rtems\\_interrupt\\_server\\_delete\(\)](#page-245-0)* (page 218).

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

9.4. Directives 211

## <span id="page-239-1"></span><span id="page-239-0"></span>9.4.40 rtems\_interrupt\_server\_create()

Creates an interrupt server.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_server_create(
2 rtems_interrupt_server_control *control,
3 const rtems_interrupt_server_config *config,
4 uint32_t *server_index
5 );
```

#### PARAMETERS:

#### **control**

This parameter is the pointer to an *[rtems\\_interrupt\\_server\\_control](#page-72-4)* (page 45) object. When the directive call was successful, the ownership of the object was transferred from the caller of the directive to the interrupt server management.

#### **config**

This parameter is the interrupt server configuration.

#### **server\_index**

This parameter is the pointer to an [uint32\\_t](https://en.cppreference.com/w/c/types/integer) object. When the directive call was successful, the index of the created interrupt server will be stored in this object.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

The directive uses *[rtems\\_task\\_create\(\)](#page-136-0)* (page 109). If this directive fails, then its error status will be returned.

## NOTES:

See also *[rtems\\_interrupt\\_server\\_initialize\(\)](#page-237-0)* (page 210) and *[rtems\\_interrupt\\_server\\_delete\(\)](#page-245-0)* (page 218).

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

## <span id="page-240-1"></span><span id="page-240-0"></span>9.4.41 rtems\_interrupt\_server\_handler\_install()

Installs the interrupt handler routine and argument at the interrupt vector on the interrupt server.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_server_handler_install(
2 uint32_t server_index,
3 rtems_vector_number vector,
4 const char *info,
5 rtems_option options,
6 rtems_interrupt_handler routine,
7 void *arg
8 );
```

#### PARAMETERS:

#### **server\_index**

This parameter is the interrupt server index. The constant RTEMS\_INTERRUPT\_SERVER\_DEFAULT may be used to specify the default interrupt server.

#### **vector**

This parameter is the interrupt vector number.

#### **info**

This parameter is the descriptive information of the interrupt handler to install.

#### **options**

This parameter is the interrupt handler install option set.

#### **routine**

This parameter is the interrupt handler routine to install.

#### **arg**

This parameter is the interrupt handler argument to install.

#### DESCRIPTION:

The handler routine specified by routine will be executed within the context of the interrupt server task specified by server\_index.

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no interrupt server associated with the index specified by server\_index.

#### **RTEMS\_CALLED\_FROM\_ISR**

The directive was called from within interrupt context.

## **RTEMS\_INVALID\_ADDRESS**

The routine parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

9.4. Directives 213

#### **RTEMS\_INVALID\_ID**

There was no interrupt vector associated with the number specified by vector.

#### **RTEMS\_INVALID\_NUMBER**

An option specified by info was not applicable.

#### **RTEMS\_RESOURCE\_IN\_USE**

The RTEMS\_INTERRUPT\_UNIQUE option was set in info and the interrupt vector was already occupied by a handler.

## **RTEMS\_RESOURCE\_IN\_USE**

The RTEMS\_INTERRUPT\_SHARED option was set in info and the interrupt vector was already occupied by a unique handler.

#### **RTEMS\_TOO\_MANY**

The handler specified by routine was already installed for the interrupt vector specified by vector with an argument equal to the argument specified by arg.

#### **RTEMS\_UNSATISFIED**

The RTEMS\_INTERRUPT\_REPLACE option was set in info and no handler to replace was installed.

#### NOTES:

See also *[rtems\\_interrupt\\_handler\\_install\(\)](#page-217-0)* (page 190).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

## <span id="page-242-1"></span><span id="page-242-0"></span>9.4.42 rtems\_interrupt\_server\_handler\_remove()

Removes the interrupt handler routine and argument from the interrupt vector and the interrupt server.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_server_handler_remove(
2 uint32_t server_index,
3 rtems_vector_number vector,
4 rtems_interrupt_handler routine,
5 void *arg
6 );
```

#### PARAMETERS:

#### **server\_index**

This parameter is the interrupt server index. The constant RTEMS\_INTERRUPT\_SERVER\_DEFAULT may be used to specify the default interrupt server.

#### **vector**

This parameter is the interrupt vector number.

#### **routine**

This parameter is the interrupt handler routine to remove.

#### **arg**

This parameter is the interrupt handler argument to remove.

### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no interrupt server associated with the index specified by server\_index.

#### **RTEMS\_INVALID\_ID**

There was no interrupt vector associated with the number specified by vector.

## **RTEMS\_UNSATISFIED**

There was no handler routine and argument pair installed specified by routine and arg.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- The directive sends a request to another task and waits for a response. This may cause the calling task to be blocked and unblocked.
- The directive shall not be called from within the context of an interrupt server. Calling the directive from within the context of an interrupt server is undefined behaviour.

9.4. Directives 215

## <span id="page-243-1"></span><span id="page-243-0"></span>9.4.43 rtems\_interrupt\_server\_set\_affinity()

Sets the processor affinity of the interrupt server.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_server_set_affinity(
2 uint32_t server_index,
3 size_t affinity_size,
4 const cpu_set_t *affinity,
5 rtems_task_priority priority
6 );
```

#### PARAMETERS:

#### **server\_index**

This parameter is the interrupt server index. The constant RTEMS\_INTERRUPT\_SERVER\_DEFAULT may be used to specify the default interrupt server.

#### **affinity\_size**

This parameter is the size of the processor set referenced by affinity in bytes.

#### **affinity**

This parameter is the pointer to a cpu\_set\_t object. The processor set defines the new processor affinity set of the interrupt server. A set bit in the processor set means that the corresponding processor shall be in the processor affinity set of the task, otherwise the bit shall be cleared.

#### **priority**

This parameter is the new *[real priority](#page-1072-0)* for the interrupt server.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no interrupt server associated with the index specified by server\_index.

The directive uses *[rtems\\_scheduler\\_ident\\_by\\_processor\\_set\(\)](#page-101-0)* (page 74), *[rtems\\_task\\_set\\_scheduler\(\)](#page-164-0)* (page 137), and *[rtems\\_task\\_set\\_affinity\(\)](#page-168-0)* (page 141). If one of these directive fails, then its error status will be returned.

## NOTES:

The scheduler is set determined by the highest numbered processor in the affinity set specified by affinity.

This operation is only reliable in case the interrupt server was suspended via *[rtems\\_interrupt\\_server\\_suspend\(\)](#page-246-0)* (page 219).

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may change the processor affinity of a task. This may cause the calling task to be preempted.
- The directive may change the priority of a task. This may cause the calling task to be preempted.

9.4. Directives 217

## <span id="page-245-1"></span><span id="page-245-0"></span>9.4.44 rtems\_interrupt\_server\_delete()

Deletes the interrupt server.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_server_delete( uint32_t server_index );
```

#### PARAMETERS:

#### **server\_index**

This parameter is the index of the interrupt server to delete.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no interrupt server associated with the server index specified by server\_index.

## NOTES:

The interrupt server deletes itself, so after the return of the directive the interrupt server may be still in the termination process depending on the task priorities of the system.

See also *[rtems\\_interrupt\\_server\\_create\(\)](#page-239-0)* (page 212).

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive shall not be called from within the context of an interrupt server. Calling the directive from within the context of an interrupt server is undefined behaviour.
- The directive sends a request to another task and waits for a response. This may cause the calling task to be blocked and unblocked.

## <span id="page-246-1"></span><span id="page-246-0"></span>9.4.45 rtems\_interrupt\_server\_suspend()

Suspends the interrupt server.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_server_suspend( uint32_t server_index );
```

#### PARAMETERS:

#### **server\_index**

This parameter is the index of the interrupt server to suspend. The constant RTEMS\_INTERRUPT\_SERVER\_DEFAULT may be used to specify the default interrupt server.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no interrupt server associated with the index specified by server\_index.

#### NOTES:

Interrupt server may be resumed by *[rtems\\_interrupt\\_server\\_resume\(\)](#page-247-0)* (page 220).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive shall not be called from within the context of an interrupt server. Calling the directive from within the context of an interrupt server is undefined behaviour.
- The directive sends a request to another task and waits for a response. This may cause the calling task to be blocked and unblocked.

9.4. Directives 219

## <span id="page-247-1"></span><span id="page-247-0"></span>9.4.46 rtems\_interrupt\_server\_resume()

Resumes the interrupt server.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_server_resume( uint32_t server_index );
```

#### PARAMETERS:

#### **server\_index**

This parameter is the index of the interrupt server to resume. The constant RTEMS\_INTERRUPT\_SERVER\_DEFAULT may be used to specify the default interrupt server.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no interrupt server associated with the index specified by server\_index.

#### NOTES:

Interrupt server may be suspended by *[rtems\\_interrupt\\_server\\_suspend\(\)](#page-246-0)* (page 219).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive shall not be called from within the context of an interrupt server. Calling the directive from within the context of an interrupt server is undefined behaviour.
- The directive sends a request to another task and waits for a response. This may cause the calling task to be blocked and unblocked.

## <span id="page-248-1"></span><span id="page-248-0"></span>9.4.47 rtems\_interrupt\_server\_move()

Moves the interrupt handlers installed at the interrupt vector and the source interrupt server to the destination interrupt server.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_server_move(
2 uint32_t source_server_index,
3 rtems_vector_number vector,
4 uint32_t destination_server_index
5 );
```

#### PARAMETERS:

#### **source\_server\_index**

This parameter is the index of the source interrupt server. The constant RTEMS\_INTERRUPT\_SERVER\_DEFAULT may be used to specify the default interrupt server.

#### **vector**

This parameter is the interrupt vector number.

#### **destination\_server\_index**

This parameter is the index of the destination interrupt server. The constant RTEMS\_INTERRUPT\_SERVER\_DEFAULT may be used to specify the default interrupt server.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ID**

There was no interrupt server associated with the index specified by source\_server\_index.

## **RTEMS\_INVALID\_ID**

There was no interrupt server associated with the index specified by destination\_server\_index.

#### **RTEMS\_INVALID\_ID**

There was no interrupt vector associated with the number specified by vector.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive shall not be called from within the context of an interrupt server. Calling the directive from within the context of an interrupt server is undefined behaviour.
- The directive sends a request to another task and waits for a response. This may cause the calling task to be blocked and unblocked.

9.4. Directives 221

## <span id="page-249-1"></span><span id="page-249-0"></span>9.4.48 rtems\_interrupt\_server\_handler\_iterate()

Iterates over all interrupt handler installed at the interrupt vector and interrupt server.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_server_handler_iterate(
2 uint32_t server_index,
3 rtems_vector_number vector,
4 rtems_interrupt_per_handler_routine routine,
5 void *arg
6 );
```

#### PARAMETERS:

#### **server\_index**

This parameter is the index of the interrupt server.

#### **vector**

This parameter is the interrupt vector number.

#### **routine**

This parameter is the visitor routine.

#### **arg**

This parameter is the visitor argument.

## DESCRIPTION:

For each installed handler at the interrupt vector and interrupt server the visitor function specified by vector will be called with the argument specified by routine and the handler information, options, routine and argument.

## RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no interrupt server associated with the index specified by server\_index.

#### **RTEMS\_INVALID\_ID**

There was no interrupt vector associated with the number specified by vector.

#### NOTES:

The directive is intended for system information and diagnostics.

Never install or remove an interrupt handler within the visitor function. This may result in a deadlock.

## CONSTRAINTS:

The following constraints apply to this directive:

â€¢ The directive may be called from within device driver initialization context.

- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

9.4. Directives 223

## <span id="page-251-1"></span><span id="page-251-0"></span>9.4.49 rtems\_interrupt\_server\_entry\_initialize()

Initializes the interrupt server entry.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_server_entry_initialize(
2 uint32_t server_index,
3 rtems_interrupt_server_entry *entry
4 );
```

#### PARAMETERS:

#### **server\_index**

This parameter is the interrupt server index. The constant RTEMS\_INTERRUPT\_SERVER\_DEFAULT may be used to specify the default interrupt server.

#### **entry**

This parameter is the interrupt server entry to initialize.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no interrupt server associated with the index specified by server\_index.

## NOTES:

After initialization, the list of actions of the interrupt server entry is empty. Actions may be prepended by *[rtems\\_interrupt\\_server\\_action\\_prepend\(\)](#page-252-0)* (page 225). Interrupt server entries may be moved to another interrupt vector with *[rtems\\_interrupt\\_server\\_entry\\_move\(\)](#page-256-0)* (page 229). Server entries may be submitted to get serviced by the interrupt server with *[rtems\\_interrupt\\_server\\_entry\\_submit\(\)](#page-255-0)* (page 228). Server entries may be destroyed by *[rtems\\_interrupt\\_server\\_entry\\_destroy\(\)](#page-254-0)* (page 227).

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

## <span id="page-252-1"></span><span id="page-252-0"></span>9.4.50 rtems\_interrupt\_server\_action\_prepend()

Prepends the interrupt server action to the list of actions of the interrupt server entry.

## CALLING SEQUENCE:

```
1 void rtems_interrupt_server_action_prepend(
2 rtems_interrupt_server_entry *entry,
3 rtems_interrupt_server_action *action,
4 rtems_interrupt_handler routine,
5 void *arg
6 );
```

#### PARAMETERS:

#### **entry**

This parameter is the interrupt server entry to prepend the interrupt server action. It shall have been initialized via *[rtems\\_interrupt\\_server\\_entry\\_initialize\(\)](#page-251-0)* (page 224).

#### **action**

This parameter is the interrupt server action to initialize and prepend to the list of actions of the entry.

#### **routine**

This parameter is the interrupt handler routine to set in the action.

#### **arg**

This parameter is the interrupt handler argument to set in the action.

### NOTES:

No error checking is performed by the directive.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.
- The interrupt server entry shall have been initialized by *[rtems\\_interrupt\\_server\\_entry\\_initialize\(\)](#page-251-0)* (page 224) and further optional calls to *[rtems\\_interrupt\\_server\\_action\\_prepend\(\)](#page-252-0)* (page 225).
- The directive shall not be called concurrently with *[rtems\\_interrupt\\_server\\_action\\_prepend\(\)](#page-252-0)* (page 225) with the same interrupt server entry. Calling the directive under this condition is undefined behaviour.
- The directive shall not be called concurrently with *[rtems\\_interrupt\\_server\\_entry\\_move\(\)](#page-256-0)* (page 229) with the same interrupt server entry. Calling the directive under this condition is undefined behaviour.

9.4. Directives 225

- The directive shall not be called concurrently with *[rtems\\_interrupt\\_server\\_entry\\_submit\(\)](#page-255-0)* (page 228) with the same interrupt server entry. Calling the directive under this condition is undefined behaviour.
- The directive shall not be called while the interrupt server entry is pending on or serviced by its current interrupt server. Calling the directive under these conditions is undefined behaviour.

## <span id="page-254-1"></span><span id="page-254-0"></span>9.4.51 rtems\_interrupt\_server\_entry\_destroy()

Destroys the interrupt server entry.

## CALLING SEQUENCE:

```
1 void rtems_interrupt_server_entry_destroy(
2 rtems_interrupt_server_entry *entry
3 );
```

#### PARAMETERS:

#### **entry**

This parameter is the interrupt server entry to destroy.

#### NOTES:

No error checking is performed by the directive.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive shall not be called from within the context of an interrupt server. Calling the directive from within the context of an interrupt server is undefined behaviour.
- The directive sends a request to another task and waits for a response. This may cause the calling task to be blocked and unblocked.
- The interrupt server entry shall have been initialized by *[rtems\\_interrupt\\_server\\_entry\\_initialize\(\)](#page-251-0)* (page 224) and further optional calls to *[rtems\\_interrupt\\_server\\_action\\_prepend\(\)](#page-252-0)* (page 225).

9.4. Directives 227

## <span id="page-255-1"></span><span id="page-255-0"></span>9.4.52 rtems\_interrupt\_server\_entry\_submit()

Submits the interrupt server entry to be serviced by the interrupt server.

#### CALLING SEQUENCE:

```
1 void rtems_interrupt_server_entry_submit(
2 rtems_interrupt_server_entry *entry
3 );
```

#### PARAMETERS:

#### **entry**

This parameter is the interrupt server entry to submit.

#### DESCRIPTION:

The directive appends the entry to the pending entries of the interrupt server. The interrupt server is notified that a new entry is pending. Once the interrupt server is scheduled it services the actions of all pending entries.

#### NOTES:

This directive may be used to do a two-step interrupt processing. The first step is done from within interrupt context by a call to this directive. The second step is then done from within the context of the interrupt server.

No error checking is performed by the directive.

A submitted entry may be destroyed by *[rtems\\_interrupt\\_server\\_entry\\_destroy\(\)](#page-254-0)* (page 227).

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may unblock a task. This may cause the calling task to be preempted.
- The interrupt server entry shall have been initialized by *[rtems\\_interrupt\\_server\\_entry\\_initialize\(\)](#page-251-0)* (page 224) and further optional calls to *[rtems\\_interrupt\\_server\\_action\\_prepend\(\)](#page-252-0)* (page 225).
- The directive shall not be called concurrently with *[rtems\\_interrupt\\_server\\_action\\_prepend\(\)](#page-252-0)* (page 225) with the same interrupt server entry. Calling the directive under this condition is undefined behaviour.
- The directive shall not be called concurrently with *[rtems\\_interrupt\\_server\\_entry\\_move\(\)](#page-256-0)* (page 229) with the same interrupt server entry. Calling the directive under this condition is undefined behaviour.

## <span id="page-256-1"></span><span id="page-256-0"></span>9.4.53 rtems\_interrupt\_server\_entry\_move()

Moves the interrupt server entry to the interrupt server.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_server_entry_move(
2 rtems_interrupt_server_entry *entry,
3 uint32_t server_index
4 );
```

#### PARAMETERS:

#### **entry**

This parameter is the interrupt server entry to move.

### **server\_index**

This parameter is the index of the destination interrupt server. The constant RTEMS\_INTERRUPT\_SERVER\_DEFAULT may be used to specify the default interrupt server.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no interrupt server associated with the index specified by server\_index.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- The interrupt server entry shall have been initialized by *[rtems\\_interrupt\\_server\\_entry\\_initialize\(\)](#page-251-0)* (page 224) and further optional calls to *[rtems\\_interrupt\\_server\\_action\\_prepend\(\)](#page-252-0)* (page 225).
- The directive shall not be called concurrently with *[rtems\\_interrupt\\_server\\_action\\_prepend\(\)](#page-252-0)* (page 225) with the same interrupt server entry. Calling the directive under this condition is undefined behaviour.
- The directive shall not be called concurrently with *[rtems\\_interrupt\\_server\\_entry\\_move\(\)](#page-256-0)* (page 229) with the same interrupt server entry. Calling the directive under this condition is undefined behaviour.
- The directive shall not be called concurrently with *[rtems\\_interrupt\\_server\\_entry\\_submit\(\)](#page-255-0)* (page 228) with the same interrupt server entry. Calling the directive under this condition is undefined behaviour.
- The directive shall not be called while the interrupt server entry is pending on or serviced by its current interrupt server. Calling the directive under these conditions is undefined behaviour.

9.4. Directives 229

## <span id="page-257-1"></span><span id="page-257-0"></span>9.4.54 rtems\_interrupt\_server\_request\_initialize()

Initializes the interrupt server request.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_interrupt_server_request_initialize(
2 uint32_t server_index,
3 rtems_interrupt_server_request *request,
4 rtems_interrupt_handler routine,
5 void *arg
6 );
```

#### PARAMETERS:

#### **server\_index**

This parameter is the interrupt server index. The constant RTEMS\_INTERRUPT\_SERVER\_DEFAULT may be used to specify the default interrupt server.

#### **request**

This parameter is the interrupt server request to initialize.

#### **routine**

This parameter is the interrupt handler routine for the request action.

#### **arg**

This parameter is the interrupt handler argument for the request action.

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no interrupt server associated with the index specified by server\_index.

## NOTES:

An interrupt server requests consists of an interrupt server entry and exactly one interrupt server action. The interrupt vector of the request may be changed with *[rtems\\_interrupt\\_server\\_request\\_set\\_vector\(\)](#page-258-0)* (page 231). Interrupt server requests may be submitted to get serviced by the interrupt server with *[rtems\\_interrupt\\_server\\_request\\_submit\(\)](#page-260-0)* (page 233). Requests may be destroyed by *[rtems\\_interrupt\\_server\\_request\\_destroy\(\)](#page-259-0)* (page 232).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

## <span id="page-258-1"></span><span id="page-258-0"></span>9.4.55 rtems\_interrupt\_server\_request\_set\_vector()

Sets the interrupt vector in the interrupt server request.

#### CALLING SEQUENCE:

```
1 void rtems_interrupt_server_request_set_vector(
2 rtems_interrupt_server_request *request,
3 rtems_vector_number vector
4 );
```

#### PARAMETERS:

#### **request**

This parameter is the interrupt server request to change.

#### **vector**

This parameter is the interrupt vector number to be used by the request.

#### NOTES:

By default, the interrupt vector of an interrupt server request is set to a special value which is outside the range of vectors supported by the interrupt controller hardware.

Calls to *[rtems\\_interrupt\\_server\\_request\\_submit\(\)](#page-260-0)* (page 233) will disable the interrupt vector of the request. After processing of the request by the interrupt server the interrupt vector will be enabled again.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.
- The interrupt server request shall have been initialized by *[rtems\\_interrupt\\_server\\_request\\_initialize\(\)](#page-257-0)* (page 230).
- The directive shall not be called concurrently with *[rtems\\_interrupt\\_server\\_request\\_set\\_vector\(\)](#page-258-0)* (page 231) with the same interrupt server request. Calling the directive under this condition is undefined behaviour.
- The directive shall not be called concurrently with *[rtems\\_interrupt\\_server\\_request\\_submit\(\)](#page-260-0)* (page 233) with the same interrupt server request. Calling the directive under this condition is undefined behaviour.
- The directive shall not be called while the interrupt server entry is pending on or serviced by its current interrupt server. Calling the directive under these conditions is undefined behaviour.

9.4. Directives 231

## <span id="page-259-1"></span><span id="page-259-0"></span>9.4.56 rtems\_interrupt\_server\_request\_destroy()

Destroys the interrupt server request.

#### CALLING SEQUENCE:

```
1 void rtems_interrupt_server_request_destroy(
2 rtems_interrupt_server_request *request
3 );
```

#### PARAMETERS:

#### **request**

This parameter is the interrupt server request to destroy.

#### NOTES:

No error checking is performed by the directive.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive shall not be called from within the context of an interrupt server. Calling the directive from within the context of an interrupt server is undefined behaviour.
- The directive sends a request to another task and waits for a response. This may cause the calling task to be blocked and unblocked.
- The interrupt server request shall have been initialized by *[rtems\\_interrupt\\_server\\_request\\_initialize\(\)](#page-257-0)* (page 230).

## <span id="page-260-1"></span><span id="page-260-0"></span>9.4.57 rtems\_interrupt\_server\_request\_submit()

Submits the interrupt server request to be serviced by the interrupt server.

#### CALLING SEQUENCE:

```
1 void rtems_interrupt_server_request_submit(
2 rtems_interrupt_server_request *request
3 );
```

#### PARAMETERS:

#### **request**

This parameter is the interrupt server request to submit.

#### DESCRIPTION:

The directive appends the interrupt server entry of the request to the pending entries of the interrupt server. The interrupt server is notified that a new entry is pending. Once the interrupt server is scheduled it services the actions of all pending entries.

#### NOTES:

This directive may be used to do a two-step interrupt processing. The first step is done from within interrupt context by a call to this directive. The second step is then done from within the context of the interrupt server.

No error checking is performed by the directive.

A submitted request may be destroyed by *[rtems\\_interrupt\\_server\\_request\\_destroy\(\)](#page-259-0)* (page 232).

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may unblock a task. This may cause the calling task to be preempted.
- The interrupt server request shall have been initialized by *[rtems\\_interrupt\\_server\\_request\\_initialize\(\)](#page-257-0)* (page 230).
- The directive shall not be called concurrently with *[rtems\\_interrupt\\_server\\_request\\_set\\_vector\(\)](#page-258-0)* (page 231) with the same interrupt server request. Calling the directive under this condition is undefined behaviour.

9.4. Directives 233

CHAPTER

**TEN**

# <span id="page-262-0"></span>CLOCK MANAGER

# <span id="page-263-0"></span>10.1 Introduction

The Clock Manager provides support for time of day and other time related capabilities. The directives provided by the Clock Manager are:

- *[rtems\\_clock\\_set\(\)](#page-270-0)* (page 243) Sets the *[CLOCK\\_REALTIME](#page-1062-2)* to the time of day.
- *[rtems\\_clock\\_get\\_tod\(\)](#page-272-0)* (page 245) Gets the time of day associated with the current *[CLOCK\\_REALTIME](#page-1062-2)*.
- *[rtems\\_clock\\_get\\_tod\\_timeval\(\)](#page-273-0)* (page 246) Gets the seconds and microseconds elapsed since the *[Unix epoch](#page-1078-1)* and the current *[CLOCK\\_REALTIME](#page-1062-2)*.
- *[rtems\\_clock\\_get\\_realtime\(\)](#page-274-0)* (page 247) Gets the time elapsed since the *[Unix epoch](#page-1078-1)* measured using *[CLOCK\\_REALTIME](#page-1062-2)* in seconds and nanoseconds format.
- *[rtems\\_clock\\_get\\_realtime\\_bintime\(\)](#page-275-0)* (page 248) Gets the time elapsed since the *[Unix](#page-1078-1) [epoch](#page-1078-1)* measured using *[CLOCK\\_REALTIME](#page-1062-2)* in binary time format.
- *[rtems\\_clock\\_get\\_realtime\\_timeval\(\)](#page-276-0)* (page 249) Gets the time elapsed since the *[Unix epoch](#page-1078-1)* measured using *[CLOCK\\_REALTIME](#page-1062-2)* in seconds and microseconds format.
- *[rtems\\_clock\\_get\\_realtime\\_coarse\(\)](#page-277-0)* (page 250) Gets the time elapsed since the *[Unix epoch](#page-1078-1)* measured using *[CLOCK\\_REALTIME](#page-1062-2)* in coarse resolution in seconds and nanoseconds format.
- *[rtems\\_clock\\_get\\_realtime\\_coarse\\_bintime\(\)](#page-278-0)* (page 251) Gets the time elapsed since the *[Unix epoch](#page-1078-1)* measured using *[CLOCK\\_REALTIME](#page-1062-2)* in coarse resolution in binary time format.
- *[rtems\\_clock\\_get\\_realtime\\_coarse\\_timeval\(\)](#page-279-0)* (page 252) Gets the time elapsed since the *[Unix epoch](#page-1078-1)* measured using *[CLOCK\\_REALTIME](#page-1062-2)* in coarse resolution in seconds and microseconds format.
- *[rtems\\_clock\\_get\\_monotonic\(\)](#page-280-0)* (page 253) Gets the time elapsed since some fixed time point in the past measured using the *[CLOCK\\_MONOTONIC](#page-1062-0)* in seconds and nanoseconds format.
- *[rtems\\_clock\\_get\\_monotonic\\_bintime\(\)](#page-281-0)* (page 254) Gets the time elapsed since some fixed time point in the past measured using the *[CLOCK\\_MONOTONIC](#page-1062-0)* in binary time format.
- *[rtems\\_clock\\_get\\_monotonic\\_sbintime\(\)](#page-282-0)* (page 255) Gets the time elapsed since some fixed time point in the past measured using the *[CLOCK\\_MONOTONIC](#page-1062-0)* in signed binary time format.
- *[rtems\\_clock\\_get\\_monotonic\\_timeval\(\)](#page-283-0)* (page 256) Gets the time elapsed since some fixed time point in the past measured using the *[CLOCK\\_MONOTONIC](#page-1062-0)* in seconds and microseconds format.
- *[rtems\\_clock\\_get\\_monotonic\\_coarse\(\)](#page-284-0)* (page 257) Gets the time elapsed since some fixed time point in the past measured using the *[CLOCK\\_MONOTONIC](#page-1062-0)* in coarse resolution in seconds and nanoseconds format.
- *[rtems\\_clock\\_get\\_monotonic\\_coarse\\_bintime\(\)](#page-285-0)* (page 258) Gets the time elapsed since some fixed time point in the past measured using the *[CLOCK\\_MONOTONIC](#page-1062-0)* in coarse resolution in binary time format.
- *[rtems\\_clock\\_get\\_monotonic\\_coarse\\_timeval\(\)](#page-286-0)* (page 259) Gets the time elapsed since some fixed time point in the past measured using the *[CLOCK\\_MONOTONIC](#page-1062-0)* in coarse resolution in seconds and microseconds format.

- *[rtems\\_clock\\_get\\_boot\\_time\(\)](#page-287-0)* (page 260) Gets the time elapsed since the *[Unix epoch](#page-1078-1)* at some time point during system initialization in seconds and nanoseconds format.
- *[rtems\\_clock\\_get\\_boot\\_time\\_bintime\(\)](#page-288-0)* (page 261) Gets the time elapsed since the *[Unix](#page-1078-1) [epoch](#page-1078-1)* at some time point during system initialization in binary time format.
- *[rtems\\_clock\\_get\\_boot\\_time\\_timeval\(\)](#page-289-0)* (page 262) Gets the time elapsed since the *[Unix](#page-1078-1) [epoch](#page-1078-1)* at some time point during system initialization in seconds and microseconds format.
- *[rtems\\_clock\\_get\\_seconds\\_since\\_epoch\(\)](#page-290-0)* (page 263) Gets the seconds elapsed since the *[RTEMS epoch](#page-1073-1)* and the current *[CLOCK\\_REALTIME](#page-1062-2)*.
- *[rtems\\_clock\\_get\\_ticks\\_per\\_second\(\)](#page-291-0)* (page 264) Gets the number of *[clock ticks](#page-1062-1)* per second configured for the application.
- *[rtems\\_clock\\_get\\_ticks\\_since\\_boot\(\)](#page-292-0)* (page 265) Gets the number of *[clock ticks](#page-1062-1)* since some time point during the system initialization or the last overflow of the clock tick counter.
- *[rtems\\_clock\\_get\\_uptime\(\)](#page-293-0)* (page 266) Gets the seconds and nanoseconds elapsed since some time point during the system initialization using *[CLOCK\\_MONOTONIC](#page-1062-0)*.
- *[rtems\\_clock\\_get\\_uptime\\_timeval\(\)](#page-294-0)* (page 267) Gets the seconds and microseconds elapsed since some time point during the system initialization using *[CLOCK\\_MONOTONIC](#page-1062-0)*.
- *[rtems\\_clock\\_get\\_uptime\\_seconds\(\)](#page-295-0)* (page 268) Gets the seconds elapsed since some time point during the system initialization using *[CLOCK\\_MONOTONIC](#page-1062-0)*.
- *[rtems\\_clock\\_get\\_uptime\\_nanoseconds\(\)](#page-296-0)* (page 269) Gets the nanoseconds elapsed since some time point during the system initialization using *[CLOCK\\_MONOTONIC](#page-1062-0)*.
- *[rtems\\_clock\\_tick\\_later\(\)](#page-297-0)* (page 270) Gets a *[clock tick](#page-1062-1)* value which is at least delta clock ticks in the future.
- *[rtems\\_clock\\_tick\\_later\\_usec\(\)](#page-298-0)* (page 271) Gets a *[clock tick](#page-1062-1)* value which is at least delta microseconds in the future.
- *[rtems\\_clock\\_tick\\_before\(\)](#page-299-0)* (page 272) Indicates if the current *[clock tick](#page-1062-1)* counter is before the ticks.

10.1. Introduction 237

# <span id="page-265-3"></span><span id="page-265-0"></span>10.2 Background

## <span id="page-265-1"></span>10.2.1 Required Support

For the features provided by the Clock Manager to be utilized, a *[Clock Driver](#page-1062-3)* is required. The Clock Driver usually provides a clock interrupt which is serviced on each configured processor at each *[clock tick](#page-1062-1)*. In addition, the Clock Driver provides three clock sources:

- clock tick
- *[CLOCK\\_REALTIME](#page-1062-2)*
- *[CLOCK\\_MONOTONIC](#page-1062-0)*

The time of these clock sources advances at each clock tick. This yields the time of the clock sources in a coarse resolution. To get the time of the CLOCK\_REALTIME or CLOCK\_MONOTONIC clock sources in a higher resolution, the Clock Driver may use a clock device to get the time between clock ticks.

## <span id="page-265-2"></span>10.2.2 Time and Date Data Structures

The clock facilities of the Clock Manager operate upon calendar time. These directives utilize the following date and time structure for the native time and date format:

```
1 typedef struct {
2 uint32_t year; /* greater than 1987 */
3 uint32_t month; /* 1 - 12 */
4 uint32_t day; /* 1 - 31 */
5 uint32_t hour; /* 0 - 23 */
6 uint32_t minute; /* 0 - 59 */
7 uint32_t second; /* 0 - 59 */
8 uint32_t ticks; /* elapsed between seconds */
9 } rtems_time_of_day;
```

The native date and time format is the only format supported when setting the system date and time using the *[rtems\\_clock\\_set\(\)](#page-270-0)* (page 243) directive. Some applications expect to operate on a *UNIX-style* date and time data structure. For example, the *[rtems\\_clock\\_get\\_tod\\_timeval\(\)](#page-273-0)* (page 246) returns the date and time in struct timeval format.

Some directives use data structures defined by *[POSIX](#page-1071-2)*. The struct timeval data structure has two members: tv\_sec and tv\_usec which are seconds and microseconds, respectively. The struct timespec data structure has two members: tv\_sec and tv\_nsec which are seconds and nanoseconds, respectively. For *[CLOCK\\_REALTIME](#page-1062-2)* time points, the tv\_sec member in these data structures is the number of seconds since the *[Unix epoch](#page-1078-1)* but will never be prior to the *[RTEMS](#page-1073-1) [epoch](#page-1073-1)*.

The struct bintime and sbintime\_t time formats used by some directives originate in FreeBSD. The struct bintime data structure which represents time in a binary time format has two members: sec and frac which are seconds and fractions of a second in units of 1/2 <sup>64</sup> seconds, respectively. The sbintime\_t type is a signed 64-bit integer type used to represent time in units of 1/2 <sup>32</sup> seconds.

## <span id="page-266-3"></span><span id="page-266-0"></span>10.2.3 Clock Tick and Timeslicing

Timeslicing is a task scheduling discipline in which tasks of equal priority are executed for a specific period of time before control of the CPU is passed to another task. It is also sometimes referred to as the automatic round-robin scheduling algorithm. The length of time allocated to each task is known as the quantum or timeslice.

The system's timeslice is defined as an integral number of ticks, and is specified by the *[CON-](#page-615-0)[FIGURE\\_TICKS\\_PER\\_TIMESLICE](#page-615-0)* (page 588) application configuration option. The timeslice is defined for the entire system of tasks, but timeslicing is enabled and disabled on a per task basis.

The clock tick directives implement timeslicing by decrementing the running task's timeremaining counter when both timeslicing and preemption are enabled. If the task's timeslice has expired, then that task will be preempted if there exists a ready task of equal priority.

## <span id="page-266-1"></span>10.2.4 Delays

A sleep timer allows a task to delay for a given interval or up until a given time, and then wake and continue execution. This type of timer is created automatically by the *[rtems\\_task\\_wake\\_after\(\)](#page-161-0)* (page 134) and *[rtems\\_task\\_wake\\_when\(\)](#page-162-0)* (page 135) directives and, as a result, does not have an object identifier. Once activated, a sleep timer cannot be explicitly deleted. Each task may activate one and only one sleep timer at a time.

## <span id="page-266-2"></span>10.2.5 Timeouts

Timeouts are a special type of timer automatically created when the timeout option is used on the *[rtems\\_barrier\\_wait\(\)](#page-390-0)* (page 363), *[rtems\\_event\\_receive\(\)](#page-430-0)* (page 403), *[rtems\\_message\\_queue\\_receive\(\)](#page-416-0)* (page 389), *[rtems\\_region\\_get\\_segment\(\)](#page-473-0)* (page 446), and *[rtems\\_semaphore\\_obtain\(\)](#page-370-0)* (page 343) directives. Each task may have one and only one timeout active at a time. When a timeout expires, it unblocks the task with a timeout status code.

10.2. Background 239

# <span id="page-267-0"></span>10.3 Operations

## <span id="page-267-1"></span>10.3.1 Announcing a Tick

RTEMS provides the several clock tick directives which are called from the user's real-time clock ISR to inform RTEMS that a tick has elapsed. Depending on the timer hardware capabilities the clock driver must choose the most appropriate clock tick directive. The tick frequency value, defined in microseconds, is a configuration parameter found in the Configuration Table. RTEMS divides one million microseconds (one second) by the number of microseconds per tick to determine the number of calls to the clock tick directive per second. The frequency of clock tick calls determines the resolution (granularity) for all time dependent RTEMS actions. For example, calling the clock tick directive ten times per second yields a higher resolution than calling the clock tick two times per second. The clock tick directives are responsible for maintaining both calendar time and the dynamic set of timers.

## <span id="page-267-2"></span>10.3.2 Setting the Time

The rtems\_clock\_set directive allows a task or an ISR to set the date and time maintained by RTEMS. If setting the date and time causes any outstanding timers to pass their deadline, then the expired timers will be fired during the invocation of the rtems\_clock\_set directive.

## <span id="page-267-3"></span>10.3.3 Obtaining the Time

RTEMS provides multiple directives which can be used by an application to obtain the current date and time or date and time related information. These directives allow a task or an ISR to obtain the current date and time or date and time related information. The current date and time can be returned in either native or *UNIX-style* format. Additionally, the application can obtain date and time related information such as the number of seconds since the RTEMS epoch, the number of ticks since the executive was initialized, and the number of ticks per second. The following directives are available:

#### **rtems\_clock\_get\_tod**

obtain native style date and time

#### **rtems\_clock\_get\_time\_value**

obtain *UNIX-style* date and time

## **rtems\_clock\_get\_ticks\_since\_boot**

obtain number of ticks since RTEMS was initialized

#### **rtems\_clock\_get\_seconds\_since\_epoch**

obtain number of seconds since RTEMS epoch

#### **rtems\_clock\_get\_ticks\_per\_second**

obtain number of clock ticks per second

Calendar time operations will return an error code if invoked before the date and time have been set.

## <span id="page-267-4"></span>10.3.4 Transition Advice for the Removed rtems\_clock\_get()

The directive *[CLOCK\\_GET - Get date and time information](#page-301-0)* (page 274) took an untyped pointer with an options argument to indicate the time information desired. This has been replaced with a set of typed directives:

â€¢ rtems\_clock\_get\_seconds\_since\_epoch

- - rtems\_clock\_get\_ticks\_per\_second
  - rtems\_clock\_get\_ticks\_since\_boot
  - rtems\_clock\_get\_tod
  - rtems\_clock\_get\_tod\_timeval

These directives directly correspond to what were previously referred to as *clock options*. These strongly typed directives were available for multiple releases in parallel with rtems\_clock\_get() until that directive was removed.

10.3. Operations 241

# <span id="page-269-0"></span>10.4 Directives

This section details the directives of the Clock Manager. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

## <span id="page-270-1"></span><span id="page-270-0"></span>10.4.1 rtems\_clock\_set()

Sets the *[CLOCK\\_REALTIME](#page-1062-2)* to the time of day.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_clock_set( const rtems_time_of_day *time_of_day );
```

#### PARAMETERS:

#### **time\_of\_day**

This parameter is the time of day to set the clock.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The time\_of\_day parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

## **RTEMS\_INVALID\_CLOCK**

The time of day specified by time\_of\_day was invalid.

#### NOTES:

The date, time, and ticks specified by time\_of\_day are all range-checked, and an error is returned if any one is out of its valid range.

RTEMS can represent time points of the *[CLOCK\\_REALTIME](#page-1062-2)* clock in nanoseconds ranging from 1988-01-01T00:00:00.000000000Z to 2514-05-31T01:53:03.999999999Z. The future uptime of the system shall be in this range, otherwise the system behaviour is undefined. Due to implementation constraints, the time of day set by the directive shall be before 2100-01- 01:00:00.000000000Z. The latest valid time of day accepted by the POSIX [clock\\_settime\(\)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/clock_settime.html) is 2400-01-01T00:00:00.999999999Z.

The specified time is based on the configured *[clock tick](#page-1062-1)* rate, see the *[CONFIG-](#page-612-0)[URE\\_MICROSECONDS\\_PER\\_TICK](#page-612-0)* (page 585) application configuration option.

Setting the time forward will fire all *[CLOCK\\_REALTIME](#page-1062-2)* timers which are scheduled at a time point before or at the time set by the directive. This may unblock tasks, which may preempt the calling task. User-provided timer routines will execute in the context of the caller.

It is allowed to call this directive from within interrupt context, however, this is not recommended since an arbitrary number of timers may fire.

The directive shall be called at least once to enable the service of *[CLOCK\\_REALTIME](#page-1062-2)* related directives. If the clock is not set at least once, they may return an error status.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive may change the priority of a task. This may cause the calling task to be preempted.

10.4. Directives 243

- The directive may unblock a task. This may cause the calling task to be preempted.
- The time of day set by the directive shall be 1988-01-01T00:00:00.000000000Z or later.
- The time of day set by the directive shall be before 2100-01-01T00:00:00.000000000Z.

## <span id="page-272-1"></span><span id="page-272-0"></span>10.4.2 rtems\_clock\_get\_tod()

Gets the time of day associated with the current *[CLOCK\\_REALTIME](#page-1062-2)*.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_clock_get_tod( rtems_time_of_day *time_of_day );
```

#### PARAMETERS:

#### **time\_of\_day**

This parameter is the pointer to an *[rtems\\_time\\_of\\_day](#page-86-2)* (page 59) object. When the directive call is successful, the time of day associated with the *[CLOCK\\_REALTIME](#page-1062-2)* at some point during the directive call will be stored in this object.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The time\_of\_day parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_NOT\_DEFINED**

The *[CLOCK\\_REALTIME](#page-1062-2)* was not set. It can be set with *[rtems\\_clock\\_set\(\)](#page-270-0)* (page 243).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

10.4. Directives 245

## <span id="page-273-1"></span><span id="page-273-0"></span>10.4.3 rtems\_clock\_get\_tod\_timeval()

Gets the seconds and microseconds elapsed since the *[Unix epoch](#page-1078-1)* and the current *[CLOCK\\_REALTIME](#page-1062-2)*.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_clock_get_tod_timeval( struct timeval *time_of_day );
```

#### PARAMETERS:

#### **time\_of\_day**

This parameter is the pointer to a [struct timeval](https://pubs.opengroup.org/onlinepubs/009695399/basedefs/sys/time.h.html) object. When the directive call is successful, the seconds and microseconds elapsed since the *[Unix epoch](#page-1078-1)* and the *[CLOCK\\_REALTIME](#page-1062-2)* at some point during the directive call will be stored in this object.

### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The time\_of\_day parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_NOT\_DEFINED**

The *[CLOCK\\_REALTIME](#page-1062-2)* was not set. It can be set with *[rtems\\_clock\\_set\(\)](#page-270-0)* (page 243).

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

## <span id="page-274-1"></span><span id="page-274-0"></span>10.4.4 rtems\_clock\_get\_realtime()

Gets the time elapsed since the *[Unix epoch](#page-1078-1)* measured using *[CLOCK\\_REALTIME](#page-1062-2)* in seconds and nanoseconds format.

### CALLING SEQUENCE:

```
1 void rtems_clock_get_realtime( struct timespec *time_snapshot );
```

#### PARAMETERS:

#### **time\_snapshot**

This parameter is the pointer to a [struct timespec](https://en.cppreference.com/w/c/chrono/timespec) object. The time elapsed since the *[Unix](#page-1078-1) [epoch](#page-1078-1)* measured using the *[CLOCK\\_REALTIME](#page-1062-2)* at some time point during the directive call will be stored in this object. Calling the directive with a pointer equal to [NULL](https://en.cppreference.com/w/c/types/NULL) is undefined behaviour.

#### NOTES:

The directive accesses a device provided by the *[Clock Driver](#page-1062-3)* to get the time in the highest resolution available to the system. Alternatively, the *[rtems\\_clock\\_get\\_realtime\\_coarse\(\)](#page-277-0)* (page 250) directive may be used to get the time in a lower resolution and with less runtime overhead.

See *[rtems\\_clock\\_get\\_realtime\\_bintime\(\)](#page-275-0)* (page 248) and *[rtems\\_clock\\_get\\_realtime\\_timeval\(\)](#page-276-0)* (page 249) to get the time in alternative formats.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

10.4. Directives 247

## <span id="page-275-1"></span><span id="page-275-0"></span>10.4.5 rtems\_clock\_get\_realtime\_bintime()

Gets the time elapsed since the *[Unix epoch](#page-1078-1)* measured using *[CLOCK\\_REALTIME](#page-1062-2)* in binary time format.

### CALLING SEQUENCE:

```
1 void rtems_clock_get_realtime_bintime( struct bintime *time_snapshot );
```

#### PARAMETERS:

#### **time\_snapshot**

This parameter is the pointer to a struct bintime object. The time elapsed since the *[Unix](#page-1078-1) [epoch](#page-1078-1)* measured using the *[CLOCK\\_REALTIME](#page-1062-2)* at some time point during the directive call will be stored in this object. Calling the directive with a pointer equal to [NULL](https://en.cppreference.com/w/c/types/NULL) is undefined behaviour.

#### NOTES:

The directive accesses a device provided by the *[Clock Driver](#page-1062-3)* to get the time in the highest resolution available to the system. Alternatively, the *[rtems\\_clock\\_get\\_realtime\\_coarse\\_bintime\(\)](#page-278-0)* (page 251) directive may be used to get the time in a lower resolution and with less runtime overhead.

See *[rtems\\_clock\\_get\\_realtime\(\)](#page-274-0)* (page 247) and *[rtems\\_clock\\_get\\_realtime\\_timeval\(\)](#page-276-0)* (page 249) to get the time in alternative formats.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

## <span id="page-276-1"></span><span id="page-276-0"></span>10.4.6 rtems\_clock\_get\_realtime\_timeval()

Gets the time elapsed since the *[Unix epoch](#page-1078-1)* measured using *[CLOCK\\_REALTIME](#page-1062-2)* in seconds and microseconds format.

#### CALLING SEQUENCE:

```
1 void rtems_clock_get_realtime_timeval( struct timeval *time_snapshot );
```

#### PARAMETERS:

#### **time\_snapshot**

This parameter is the pointer to a [struct timeval](https://pubs.opengroup.org/onlinepubs/009695399/basedefs/sys/time.h.html) object. The time elapsed since the *[Unix](#page-1078-1) [epoch](#page-1078-1)* measured using the *[CLOCK\\_REALTIME](#page-1062-2)* at some time point during the directive call will be stored in this object. Calling the directive with a pointer equal to [NULL](https://en.cppreference.com/w/c/types/NULL) is undefined behaviour.

#### NOTES:

The directive accesses a device provided by the *[Clock Driver](#page-1062-3)* to get the time in the highest resolution available to the system. Alternatively, the *[rtems\\_clock\\_get\\_realtime\\_coarse\\_timeval\(\)](#page-279-0)* (page 252) directive may be used to get the time in a lower resolution and with less runtime overhead.

See *[rtems\\_clock\\_get\\_realtime\(\)](#page-274-0)* (page 247) and *[rtems\\_clock\\_get\\_realtime\\_bintime\(\)](#page-275-0)* (page 248) to get the time in alternative formats.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

10.4. Directives 249

## <span id="page-277-1"></span><span id="page-277-0"></span>10.4.7 rtems\_clock\_get\_realtime\_coarse()

Gets the time elapsed since the *[Unix epoch](#page-1078-1)* measured using *[CLOCK\\_REALTIME](#page-1062-2)* in coarse resolution in seconds and nanoseconds format.

### CALLING SEQUENCE:

```
1 void rtems_clock_get_realtime_coarse( struct timespec *time_snapshot );
```

#### PARAMETERS:

#### **time\_snapshot**

This parameter is the pointer to a [struct timespec](https://en.cppreference.com/w/c/chrono/timespec) object. The time elapsed since the *[Unix](#page-1078-1) [epoch](#page-1078-1)* measured using the *[CLOCK\\_REALTIME](#page-1062-2)* at some time point close to the directive call will be stored in this object. Calling the directive with a pointer equal to [NULL](https://en.cppreference.com/w/c/types/NULL) is undefined behaviour.

## NOTES:

The directive does not access a device to get the time. It uses a recent snapshot provided by the *[Clock Driver](#page-1062-3)*. Alternatively, the *[rtems\\_clock\\_get\\_realtime\(\)](#page-274-0)* (page 247) directive may be used to get the time in a higher resolution and with a higher runtime overhead.

See *[rtems\\_clock\\_get\\_realtime\\_coarse\\_bintime\(\)](#page-278-0)* (page 251) and *[rtems\\_clock\\_get\\_realtime\\_coarse\\_timeval\(\)](#page-279-0)* (page 252) to get the time in alternative formats.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

## <span id="page-278-1"></span><span id="page-278-0"></span>10.4.8 rtems\_clock\_get\_realtime\_coarse\_bintime()

Gets the time elapsed since the *[Unix epoch](#page-1078-1)* measured using *[CLOCK\\_REALTIME](#page-1062-2)* in coarse resolution in binary time format.

#### CALLING SEQUENCE:

```
1 void rtems_clock_get_realtime_coarse_bintime( struct bintime *time_snapshot );
```

#### PARAMETERS:

#### **time\_snapshot**

This parameter is the pointer to a struct bintime object. The time elapsed since the *[Unix](#page-1078-1) [epoch](#page-1078-1)* measured using the *[CLOCK\\_REALTIME](#page-1062-2)* at some time point close to the directive call will be stored in this object. Calling the directive with a pointer equal to [NULL](https://en.cppreference.com/w/c/types/NULL) is undefined behaviour.

## NOTES:

The directive does not access a device to get the time. It uses a recent snapshot provided by the *[Clock Driver](#page-1062-3)*. Alternatively, the *[rtems\\_clock\\_get\\_realtime\\_bintime\(\)](#page-275-0)* (page 248) directive may be used to get the time in a higher resolution and with a higher runtime overhead.

See *[rtems\\_clock\\_get\\_realtime\\_coarse\(\)](#page-277-0)* (page 250) and *[rtems\\_clock\\_get\\_realtime\\_coarse\\_timeval\(\)](#page-279-0)* (page 252) to get the time in alternative formats.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

10.4. Directives 251

## <span id="page-279-1"></span><span id="page-279-0"></span>10.4.9 rtems\_clock\_get\_realtime\_coarse\_timeval()

Gets the time elapsed since the *[Unix epoch](#page-1078-1)* measured using *[CLOCK\\_REALTIME](#page-1062-2)* in coarse resolution in seconds and microseconds format.

### CALLING SEQUENCE:

```
1 void rtems_clock_get_realtime_coarse_timeval( struct timeval *time_snapshot );
```

#### PARAMETERS:

#### **time\_snapshot**

This parameter is the pointer to a [struct timeval](https://pubs.opengroup.org/onlinepubs/009695399/basedefs/sys/time.h.html) object. The time elapsed since the *[Unix](#page-1078-1) [epoch](#page-1078-1)* measured using the *[CLOCK\\_REALTIME](#page-1062-2)* at some time point close to the directive call will be stored in this object. Calling the directive with a pointer equal to [NULL](https://en.cppreference.com/w/c/types/NULL) is undefined behaviour.

#### NOTES:

The directive does not access a device to get the time. It uses a recent snapshot provided by the *[Clock Driver](#page-1062-3)*. Alternatively, the *[rtems\\_clock\\_get\\_realtime\\_timeval\(\)](#page-276-0)* (page 249) directive may be used to get the time in a higher resolution and with a higher runtime overhead.

See *[rtems\\_clock\\_get\\_realtime\\_coarse\(\)](#page-277-0)* (page 250) and *[rtems\\_clock\\_get\\_realtime\\_coarse\\_timeval\(\)](#page-279-0)* (page 252) to get the time in alternative formats.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

## <span id="page-280-1"></span><span id="page-280-0"></span>10.4.10 rtems\_clock\_get\_monotonic()

Gets the time elapsed since some fixed time point in the past measured using the *[CLOCK\\_MONOTONIC](#page-1062-0)* in seconds and nanoseconds format.

## CALLING SEQUENCE:

```
1 void rtems_clock_get_monotonic( struct timespec *time_snapshot );
```

#### PARAMETERS:

#### **time\_snapshot**

This parameter is the pointer to a [struct timespec](https://en.cppreference.com/w/c/chrono/timespec) object. The time elapsed since some fixed time point in the past measured using the *[CLOCK\\_MONOTONIC](#page-1062-0)* at some time point during the directive call will be stored in this object. Calling the directive with a pointer equal to [NULL](https://en.cppreference.com/w/c/types/NULL) is undefined behaviour.

## NOTES:

The directive accesses a device provided by the *[Clock Driver](#page-1062-3)* to get the time in the highest resolution available to the system. Alternatively, the *[rtems\\_clock\\_get\\_monotonic\\_coarse\(\)](#page-284-0)* (page 257) directive may be used to get the time with in a lower resolution and with less runtime overhead.

See *[rtems\\_clock\\_get\\_monotonic\\_bintime\(\)](#page-281-0)* (page 254), *[rtems\\_clock\\_get\\_monotonic\\_sbintime\(\)](#page-282-0)* (page 255), and *[rtems\\_clock\\_get\\_monotonic\\_timeval\(\)](#page-283-0)* (page 256) to get the time in alternative formats.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

10.4. Directives 253

## <span id="page-281-1"></span><span id="page-281-0"></span>10.4.11 rtems\_clock\_get\_monotonic\_bintime()

Gets the time elapsed since some fixed time point in the past measured using the *[CLOCK\\_MONOTONIC](#page-1062-0)* in binary time format.

### CALLING SEQUENCE:

```
1 void rtems_clock_get_monotonic_bintime( struct bintime *time_snapshot );
```

#### PARAMETERS:

#### **time\_snapshot**

This parameter is the pointer to a struct bintime object. The time elapsed since some fixed time point in the past measured using the *[CLOCK\\_MONOTONIC](#page-1062-0)* at some time point during the directive call will be stored in this object. Calling the directive with a pointer equal to [NULL](https://en.cppreference.com/w/c/types/NULL) is undefined behaviour.

#### NOTES:

The directive accesses a device provided by the *[Clock Driver](#page-1062-3)* to get the time in the highest resolution available to the system. Alternatively, the *[rtems\\_clock\\_get\\_monotonic\\_coarse\\_bintime\(\)](#page-285-0)* (page 258) directive may be used to get the time in a lower resolution and with less runtime overhead.

See *[rtems\\_clock\\_get\\_monotonic\(\)](#page-280-0)* (page 253), *[rtems\\_clock\\_get\\_monotonic\\_sbintime\(\)](#page-282-0)* (page 255), and *[rtems\\_clock\\_get\\_monotonic\\_timeval\(\)](#page-283-0)* (page 256) to get the time in alternative formats.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

## <span id="page-282-1"></span><span id="page-282-0"></span>10.4.12 rtems\_clock\_get\_monotonic\_sbintime()

Gets the time elapsed since some fixed time point in the past measured using the *[CLOCK\\_MONOTONIC](#page-1062-0)* in signed binary time format.

### CALLING SEQUENCE:

```
1 int64_t rtems_clock_get_monotonic_sbintime( void );
```

#### RETURN VALUES:

Returns the time elapsed since some fixed time point in the past measured using the *[CLOCK\\_MONOTONIC](#page-1062-0)* at some time point during the directive call.

#### NOTES:

The directive accesses a device provided by the *[Clock Driver](#page-1062-3)* to get the time in the highest resolution available to the system.

See *[rtems\\_clock\\_get\\_monotonic\(\)](#page-280-0)* (page 253), *[rtems\\_clock\\_get\\_monotonic\\_bintime\(\)](#page-281-0)* (page 254), and *[rtems\\_clock\\_get\\_monotonic\\_timeval\(\)](#page-283-0)* (page 256) to get the time in alternative formats.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

10.4. Directives 255

## <span id="page-283-1"></span><span id="page-283-0"></span>10.4.13 rtems\_clock\_get\_monotonic\_timeval()

Gets the time elapsed since some fixed time point in the past measured using the *[CLOCK\\_MONOTONIC](#page-1062-0)* in seconds and microseconds format.

### CALLING SEQUENCE:

```
1 void rtems_clock_get_monotonic_timeval( struct timeval *time_snapshot );
```

#### PARAMETERS:

#### **time\_snapshot**

This parameter is the pointer to a [struct timeval](https://pubs.opengroup.org/onlinepubs/009695399/basedefs/sys/time.h.html) object. The time elapsed since some fixed time point in the past measured using the *[CLOCK\\_MONOTONIC](#page-1062-0)* at some time point during the directive call will be stored in this object. Calling the directive with a pointer equal to [NULL](https://en.cppreference.com/w/c/types/NULL) is undefined behaviour.

#### NOTES:

The directive accesses a device provided by the *[Clock Driver](#page-1062-3)* to get the time in the highest resolution available to the system. Alternatively, the *[rtems\\_clock\\_get\\_monotonic\\_coarse\\_timeval\(\)](#page-286-0)* (page 259) directive may be used to get the time in a lower resolution and with less runtime overhead.

See *[rtems\\_clock\\_get\\_monotonic\(\)](#page-280-0)* (page 253), *[rtems\\_clock\\_get\\_monotonic\\_bintime\(\)](#page-281-0)* (page 254), and *[rtems\\_clock\\_get\\_monotonic\\_sbintime\(\)](#page-282-0)* (page 255) to get the time in alternative formats.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

## <span id="page-284-1"></span><span id="page-284-0"></span>10.4.14 rtems\_clock\_get\_monotonic\_coarse()

Gets the time elapsed since some fixed time point in the past measured using the *[CLOCK\\_MONOTONIC](#page-1062-0)* in coarse resolution in seconds and nanoseconds format.

### CALLING SEQUENCE:

```
1 void rtems_clock_get_monotonic_coarse( struct timespec *time_snapshot );
```

#### PARAMETERS:

#### **time\_snapshot**

This parameter is the pointer to a [struct timespec](https://en.cppreference.com/w/c/chrono/timespec) object. The time elapsed since some fixed time point in the past measured using the *[CLOCK\\_MONOTONIC](#page-1062-0)* at some time point close to the directive call will be stored in this object. Calling the directive with a pointer equal to [NULL](https://en.cppreference.com/w/c/types/NULL) is undefined behaviour.

#### NOTES:

The directive does not access a device to get the time. It uses a recent snapshot provided by the *[Clock Driver](#page-1062-3)*. Alternatively, the *[rtems\\_clock\\_get\\_monotonic\(\)](#page-280-0)* (page 253) directive may be used to get the time in a higher resolution and with a higher runtime overhead.

See *[rtems\\_clock\\_get\\_monotonic\\_coarse\\_bintime\(\)](#page-285-0)* (page 258) and *[rtems\\_clock\\_get\\_monotonic\\_coarse\\_timeval\(\)](#page-286-0)* (page 259) to get the time in alternative formats.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

10.4. Directives 257

## <span id="page-285-1"></span><span id="page-285-0"></span>10.4.15 rtems\_clock\_get\_monotonic\_coarse\_bintime()

Gets the time elapsed since some fixed time point in the past measured using the *[CLOCK\\_MONOTONIC](#page-1062-0)* in coarse resolution in binary time format.

#### CALLING SEQUENCE:

```
1 void rtems_clock_get_monotonic_coarse_bintime( struct bintime *time_snapshot );
```

#### PARAMETERS:

#### **time\_snapshot**

This parameter is the pointer to a struct bintime object. The time elapsed since some fixed time point in the past measured using the *[CLOCK\\_MONOTONIC](#page-1062-0)* at some time point close to the directive call will be stored in this object. Calling the directive with a pointer equal to [NULL](https://en.cppreference.com/w/c/types/NULL) is undefined behaviour.

#### NOTES:

The directive does not access a device to get the time. It uses a recent snapshot provided by the *[Clock Driver](#page-1062-3)*. Alternatively, the *[rtems\\_clock\\_get\\_monotonic\\_bintime\(\)](#page-281-0)* (page 254) directive may be used to get the time in a higher resolution and with a higher runtime overhead.

See *[rtems\\_clock\\_get\\_monotonic\\_coarse\(\)](#page-284-0)* (page 257) and *[rtems\\_clock\\_get\\_monotonic\\_coarse\\_timeval\(\)](#page-286-0)* (page 259) to get the time in alternative formats.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

## <span id="page-286-1"></span><span id="page-286-0"></span>10.4.16 rtems\_clock\_get\_monotonic\_coarse\_timeval()

Gets the time elapsed since some fixed time point in the past measured using the *[CLOCK\\_MONOTONIC](#page-1062-0)* in coarse resolution in seconds and microseconds format.

#### CALLING SEQUENCE:

```
1 void rtems_clock_get_monotonic_coarse_timeval( struct timeval *time_snapshot );
```

#### PARAMETERS:

#### **time\_snapshot**

This parameter is the pointer to a [struct timeval](https://pubs.opengroup.org/onlinepubs/009695399/basedefs/sys/time.h.html) object. The time elapsed since some fixed time point in the past measured using the *[CLOCK\\_MONOTONIC](#page-1062-0)* at some time point close to the directive call will be stored in this object. Calling the directive with a pointer equal to [NULL](https://en.cppreference.com/w/c/types/NULL) is undefined behaviour.

#### NOTES:

The directive does not access a device to get the time. It uses a recent snapshot provided by the *[Clock Driver](#page-1062-3)*. Alternatively, the *[rtems\\_clock\\_get\\_monotonic\\_timeval\(\)](#page-283-0)* (page 256) directive may be used to get the time in a higher resolution and with a higher runtime overhead.

See *[rtems\\_clock\\_get\\_monotonic\\_coarse\(\)](#page-284-0)* (page 257) and *[rtems\\_clock\\_get\\_monotonic\\_coarse\\_bintime\(\)](#page-285-0)* (page 258) to get the time in alternative formats.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

10.4. Directives 259

## <span id="page-287-1"></span><span id="page-287-0"></span>10.4.17 rtems\_clock\_get\_boot\_time()

Gets the time elapsed since the *[Unix epoch](#page-1078-1)* at some time point during system initialization in seconds and nanoseconds format.

#### CALLING SEQUENCE:

```
1 void rtems_clock_get_boot_time( struct timespec *boot_time );
```

#### PARAMETERS:

#### **boot\_time**

This parameter is the pointer to a [struct timespec](https://en.cppreference.com/w/c/chrono/timespec) object. The time elapsed since the *[Unix](#page-1078-1) [epoch](#page-1078-1)* at some time point during system initialization call will be stored in this object. Calling the directive with a pointer equal to [NULL](https://en.cppreference.com/w/c/types/NULL) is undefined behaviour.

### NOTES:

See *[rtems\\_clock\\_get\\_boot\\_time\\_bintime\(\)](#page-288-0)* (page 261) and *[rtems\\_clock\\_get\\_boot\\_time\\_timeval\(\)](#page-289-0)* (page 262) to get the boot time in alternative formats. Setting the *[CLOCK\\_REALTIME](#page-1062-2)* will also set the boot time.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

## <span id="page-288-1"></span><span id="page-288-0"></span>10.4.18 rtems\_clock\_get\_boot\_time\_bintime()

Gets the time elapsed since the *[Unix epoch](#page-1078-1)* at some time point during system initialization in binary time format.

#### CALLING SEQUENCE:

```
1 void rtems_clock_get_boot_time_bintime( struct bintime *boot_time );
```

#### PARAMETERS:

#### **boot\_time**

This parameter is the pointer to a struct bintime object. The time elapsed since the *[Unix](#page-1078-1) [epoch](#page-1078-1)* at some time point during system initialization call will be stored in this object. Calling the directive with a pointer equal to [NULL](https://en.cppreference.com/w/c/types/NULL) is undefined behaviour.

#### NOTES:

See *[rtems\\_clock\\_get\\_boot\\_time\(\)](#page-287-0)* (page 260) and *[rtems\\_clock\\_get\\_boot\\_time\\_timeval\(\)](#page-289-0)* (page 262) to get the boot time in alternative formats. Setting the *[CLOCK\\_REALTIME](#page-1062-2)* will also set the boot time.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

10.4. Directives 261

## <span id="page-289-1"></span><span id="page-289-0"></span>10.4.19 rtems\_clock\_get\_boot\_time\_timeval()

Gets the time elapsed since the *[Unix epoch](#page-1078-1)* at some time point during system initialization in seconds and microseconds format.

### CALLING SEQUENCE:

```
1 void rtems_clock_get_boot_time_timeval( struct timeval *boot_time );
```

#### PARAMETERS:

#### **boot\_time**

This parameter is the pointer to a [struct timeval](https://pubs.opengroup.org/onlinepubs/009695399/basedefs/sys/time.h.html) object. The time elapsed since the *[Unix epoch](#page-1078-1)* at some time point during system initialization call will be stored in this object. Calling the directive with a pointer equal to [NULL](https://en.cppreference.com/w/c/types/NULL) is undefined behaviour.

#### NOTES:

See *[rtems\\_clock\\_get\\_boot\\_time\(\)](#page-287-0)* (page 260) and *[rtems\\_clock\\_get\\_boot\\_time\\_bintime\(\)](#page-288-0)* (page 261) to get the boot time in alternative formats. Setting the *[CLOCK\\_REALTIME](#page-1062-2)* will also set the boot time.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

<span id="page-290-1"></span><span id="page-290-0"></span>Gets the seconds elapsed since the *[RTEMS epoch](#page-1073-1)* and the current *[CLOCK\\_REALTIME](#page-1062-2)*.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_clock_get_seconds_since_epoch(
2 rtems_interval *seconds_since_rtems_epoch
3 );
```

#### PARAMETERS:

#### **seconds\_since\_rtems\_epoch**

This parameter is the pointer to an *[rtems\\_interval](#page-74-0)* (page 47) object. When the directive call is successful, the seconds elapsed since the *[RTEMS epoch](#page-1073-1)* and the *[CLOCK\\_REALTIME](#page-1062-2)* at some point during the directive call will be stored in this object.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The seconds\_since\_rtems\_epoch parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

## **RTEMS\_NOT\_DEFINED**

The *[CLOCK\\_REALTIME](#page-1062-2)* was not set. It can be set with *[rtems\\_clock\\_set\(\)](#page-270-0)* (page 243).

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

10.4. Directives 263

## <span id="page-291-1"></span><span id="page-291-0"></span>10.4.21 rtems\_clock\_get\_ticks\_per\_second()

Gets the number of *[clock ticks](#page-1062-1)* per second configured for the application.

## CALLING SEQUENCE:

```
1 rtems_interval rtems_clock_get_ticks_per_second( void );
```

#### RETURN VALUES:

Returns the number of clock ticks per second configured for this application.

## NOTES:

The number of clock ticks per second is defined indirectly by the *[CONFIG-](#page-612-0)[URE\\_MICROSECONDS\\_PER\\_TICK](#page-612-0)* (page 585) configuration option.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-292-1"></span><span id="page-292-0"></span>10.4.22 rtems\_clock\_get\_ticks\_since\_boot()

Gets the number of *[clock ticks](#page-1062-1)* since some time point during the system initialization or the last overflow of the clock tick counter.

### CALLING SEQUENCE:

```
1 rtems_interval rtems_clock_get_ticks_since_boot( void );
```

#### RETURN VALUES:

Returns the number of *[clock ticks](#page-1062-1)* since some time point during the system initialization or the last overflow of the clock tick counter.

#### NOTES:

With a 1ms clock tick, this counter overflows after 50 days since boot. This is the historical measure of uptime in an RTEMS system. The newer service *[rtems\\_clock\\_get\\_uptime\(\)](#page-293-0)* (page 266) is another and potentially more accurate way of obtaining similar information.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

10.4. Directives 265

## <span id="page-293-1"></span><span id="page-293-0"></span>10.4.23 rtems\_clock\_get\_uptime()

Gets the seconds and nanoseconds elapsed since some time point during the system initialization using *[CLOCK\\_MONOTONIC](#page-1062-0)*.

### CALLING SEQUENCE:

```
1 rtems_status_code rtems_clock_get_uptime( struct timespec *uptime );
```

#### PARAMETERS:

#### **uptime**

This parameter is the pointer to a [struct timespec](https://en.cppreference.com/w/c/chrono/timespec) object. When the directive call is successful, the seconds and nanoseconds elapsed since some time point during the system initialization and some point during the directive call using *[CLOCK\\_MONOTONIC](#page-1062-0)* will be stored in this object.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The uptime parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

<span id="page-294-1"></span><span id="page-294-0"></span>Gets the seconds and microseconds elapsed since some time point during the system initialization using *[CLOCK\\_MONOTONIC](#page-1062-0)*.

#### CALLING SEQUENCE:

```
1 void rtems_clock_get_uptime_timeval( struct timeval *uptime );
```

#### PARAMETERS:

#### **uptime**

This parameter is the pointer to a [struct timeval](https://pubs.opengroup.org/onlinepubs/009695399/basedefs/sys/time.h.html) object. The seconds and microseconds elapsed since some time point during the system initialization and some point during the directive call using *[CLOCK\\_MONOTONIC](#page-1062-0)* will be stored in this object. The pointer shall be valid, otherwise the behaviour is undefined.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

10.4. Directives 267

## <span id="page-295-1"></span><span id="page-295-0"></span>10.4.25 rtems\_clock\_get\_uptime\_seconds()

Gets the seconds elapsed since some time point during the system initialization using *[CLOCK\\_MONOTONIC](#page-1062-0)*.

#### CALLING SEQUENCE:

```
1 time_t rtems_clock_get_uptime_seconds( void );
```

#### RETURN VALUES:

Returns the seconds elapsed since some time point during the system initialization and some point during the directive call using *[CLOCK\\_MONOTONIC](#page-1062-0)*.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

## <span id="page-296-1"></span><span id="page-296-0"></span>10.4.26 rtems\_clock\_get\_uptime\_nanoseconds()

Gets the nanoseconds elapsed since some time point during the system initialization using *[CLOCK\\_MONOTONIC](#page-1062-0)*.

#### CALLING SEQUENCE:

```
1 uint64_t rtems_clock_get_uptime_nanoseconds( void );
```

#### RETURN VALUES:

Returns the nanoseconds elapsed since some time point during the system initialization and some point during the directive call using *[CLOCK\\_MONOTONIC](#page-1062-0)*.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

10.4. Directives 269

## <span id="page-297-1"></span><span id="page-297-0"></span>10.4.27 rtems\_clock\_tick\_later()

Gets a *[clock tick](#page-1062-1)* value which is at least delta clock ticks in the future.

#### CALLING SEQUENCE:

```
1 rtems_interval rtems_clock_tick_later( rtems_interval delta );
```

#### PARAMETERS:

## **delta**

This parameter is the delta value in clock ticks.

#### RETURN VALUES:

Returns a *[clock tick](#page-1062-1)* counter value which is at least delta clock ticks in the future.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

## <span id="page-298-1"></span><span id="page-298-0"></span>10.4.28 rtems\_clock\_tick\_later\_usec()

Gets a *[clock tick](#page-1062-1)* value which is at least delta microseconds in the future.

#### CALLING SEQUENCE:

```
1 rtems_interval rtems_clock_tick_later_usec( rtems_interval delta_in_usec );
```

#### PARAMETERS:

#### **delta\_in\_usec**

This parameter is the delta value in microseconds.

#### RETURN VALUES:

Returns a *[clock tick](#page-1062-1)* counter value which is at least delta\_in\_usec microseconds in the future.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

10.4. Directives 271

## <span id="page-299-1"></span><span id="page-299-0"></span>10.4.29 rtems\_clock\_tick\_before()

Indicates if the current *[clock tick](#page-1062-1)* counter is before the ticks.

## CALLING SEQUENCE:

```
1 bool rtems_clock_tick_before( rtems_interval ticks );
```

### PARAMETERS:

#### **ticks**

This parameter is the ticks value to check.

#### RETURN VALUES:

Returns true, if current *[clock tick](#page-1062-1)* counter indicates a time before the time in ticks, otherwise returns false.

## NOTES:

This directive can be used to write busy loops with a timeout.

```
1 status busy( void )
2 {
3 rtems_interval timeout;
4
5 timeout = rtems_clock_tick_later_usec( 10000 );
6
7 do {
8 if ( ok() ) {
9 return success;
10 }
11 } while ( rtems_clock_tick_before( timeout ) );
12
13 return timeout;
14 }
```

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- The directive requires a *[Clock Driver](#page-1062-3)*.

# <span id="page-300-0"></span>10.5 Removed Directives

## <span id="page-301-1"></span><span id="page-301-0"></span>10.5.1 CLOCK\_GET - Get date and time information

## . **Warning**

This directive was removed in RTEMS 5.1. See also *[Transition Advice for the Removed](#page-267-4) [rtems\\_clock\\_get\(\)](#page-267-4)* (page 240).

## **CALLING SEQUENCE:**

```
1 rtems_status_code rtems_clock_get(
2 rtems_clock_get_options option,
3 void *time_buffer
4 );
```

#### **DIRECTIVE STATUS CODES:**

| RTEMS_SUCCESSFUL      | current time obtained successfully |
|-----------------------|------------------------------------|
| RTEMS_NOT_DEFINED     | system date and time is not set    |
| RTEMS_INVALID_ADDRESS | time_buffer<br>is NULL             |

#### **DESCRIPTION:**

This directive obtains the system date and time. If the caller is attempting to obtain the date and time (i.e. option is set to either RTEMS\_CLOCK\_GET\_SECONDS\_SINCE\_EPOCH, RTEMS\_CLOCK\_GET\_TOD, or RTEMS\_CLOCK\_GET\_TIME\_VALUE) and the date and time has not been set with a previous call to rtems\_clock\_set, then the RTEMS\_NOT\_DEFINED status code is returned. The caller can always obtain the number of ticks per second (option is RTEMS\_CLOCK\_GET\_TICKS\_PER\_SECOND) and the number of ticks since the executive was initialized option is RTEMS\_CLOCK\_GET\_TICKS\_SINCE\_BOOT).

The option argument may taken on any value of the enumerated type rtems\_clock\_get\_options. The data type expected for time\_buffer is based on the value of option as indicated below:

| Option                              | Return type           |
|-------------------------------------|-----------------------|
| RTEMS_CLOCK_GET_TOD                 | (rtems_time_of_day *) |
| RTEMS_CLOCK_GET_SECONDS_SINCE_EPOCH | (rtems_interval *)    |
| RTEMS_CLOCK_GET_TICKS_SINCE_BOOT    | (rtems_interval *)    |
| RTEMS_CLOCK_GET_TICKS_PER_SECOND    | (rtems_interval *)    |
| RTEMS_CLOCK_GET_TIME_VALUE          | (struct timeval *)    |

#### **NOTES:**

This directive is callable from an ISR.

This directive will not cause the running task to be preempted. Re-initializing RTEMS causes the system date and time to be reset to an uninitialized state. Another call to rtems\_clock\_set is required to re-initialize the system date and time to application specific specifications.

CHAPTER

**ELEVEN**

# <span id="page-302-0"></span>TIMER MANAGER

# <span id="page-303-0"></span>11.1 Introduction

The Timer Manager provides support for timer facilities. The directives provided by the Timer Manager are:

- *[rtems\\_timer\\_create\(\)](#page-308-0)* (page 281) Creates a timer.
- *[rtems\\_timer\\_ident\(\)](#page-310-0)* (page 283) Identifies a timer by the object name.
- *[rtems\\_timer\\_cancel\(\)](#page-311-0)* (page 284) Cancels the timer.
- *[rtems\\_timer\\_delete\(\)](#page-312-0)* (page 285) Deletes the timer.
- *[rtems\\_timer\\_fire\\_after\(\)](#page-313-0)* (page 286) Fires the timer after the interval.
- *[rtems\\_timer\\_fire\\_when\(\)](#page-315-0)* (page 288) Fires the timer at the time of day.
- *[rtems\\_timer\\_initiate\\_server\(\)](#page-317-0)* (page 290) Initiates the Timer Server.
- *[rtems\\_timer\\_server\\_fire\\_after\(\)](#page-319-0)* (page 292) Fires the timer after the interval using the Timer Server.
- *[rtems\\_timer\\_server\\_fire\\_when\(\)](#page-321-0)* (page 294) Fires the timer at the time of day using the Timer Server.
- *[rtems\\_timer\\_reset\(\)](#page-323-0)* (page 296) Resets the timer.
- *[rtems\\_timer\\_get\\_information\(\)](#page-324-0)* (page 297) Gets information about the timer.

# <span id="page-304-5"></span><span id="page-304-0"></span>11.2 Background

## <span id="page-304-1"></span>11.2.1 Required Support

A clock tick is required to support the functionality provided by this manager.

# <span id="page-304-2"></span>11.2.2 Timers

A timer is an RTEMS object which allows the application to schedule operations to occur at specific times in the future. User supplied timer service routines are invoked by either a clock tick directive or a special Timer Server task when the timer fires. Timer service routines may perform any operations or directives which normally would be performed by the application code which invoked a clock tick directive.

The timer can be used to implement watchdog routines which only fire to denote that an application error has occurred. The timer is reset at specific points in the application to ensure that the watchdog does not fire. Thus, if the application does not reset the watchdog timer, then the timer service routine will fire to indicate that the application has failed to reach a reset point. This use of a timer is sometimes referred to as a "keep alive" or a "deadman" timer.

## <span id="page-304-3"></span>11.2.3 Timer Server

The Timer Server task is responsible for executing the timer service routines associated with all task-based timers. This task executes at a priority specified by rtems\_timer\_initiate\_server() and it may have a priority of zero (the highest priority). In uniprocessor configurations, it is created non-preemptible.

By providing a mechanism where timer service routines execute in task rather than interrupt space, the application is allowed a bit more flexibility in what operations a timer service routine can perform. For example, the Timer Server can be configured to have a floating point context in which case it would be safe to perform floating point operations from a task-based timer. Most of the time, executing floating point instructions from an interrupt service routine is not considered safe. The timer service routines invoked by the Timer Server may block, however, since this blocks the Timer Server itself, other timer service routines that are already pending do not run until the blocked timer service routine finished its work.

The Timer Server is designed to remain blocked until a task-based timer fires. This reduces the execution overhead of the Timer Server.

## <span id="page-304-4"></span>11.2.4 Timer Service Routines

The timer service routine should adhere to C calling conventions and have a prototype similar to the following:

```
1 rtems_timer_service_routine user_routine(
2 rtems_id timer_id,
3 void *user_data
4 );
```

Where the timer\_id parameter is the RTEMS object ID of the timer which is being fired and user\_data is a pointer to user-defined information which may be utilized by the timer service routine. The argument user\_data may be NULL.

11.2. Background 277

# <span id="page-305-0"></span>11.3 Operations

## <span id="page-305-1"></span>11.3.1 Creating a Timer

The rtems\_timer\_create directive creates a timer by allocating a Timer Control Block (TMCB), assigning the timer a user-specified name, and assigning it a timer ID. Newly created timers do not have a timer service routine associated with them and are not active.

## <span id="page-305-2"></span>11.3.2 Obtaining Timer IDs

When a timer is created, RTEMS generates a unique timer ID and assigns it to the created timer until it is deleted. The timer ID may be obtained by either of two methods. First, as the result of an invocation of the rtems\_timer\_create directive, the timer ID is stored in a user provided location. Second, the timer ID may be obtained later using the rtems\_timer\_ident directive. The timer ID is used by other directives to manipulate this timer.

## <span id="page-305-3"></span>11.3.3 Initiating an Interval Timer

The rtems\_timer\_fire\_after and rtems\_timer\_server\_fire\_after directives initiate a timer to fire a user provided timer service routine after the specified number of clock ticks have elapsed. When the interval has elapsed, the timer service routine will be invoked from a clock tick directive if it was initiated by the rtems\_timer\_fire\_after directive and from the Timer Server task if initiated by the rtems\_timer\_server\_fire\_after directive.

## <span id="page-305-4"></span>11.3.4 Initiating a Time of Day Timer

The rtems\_timer\_fire\_when and rtems\_timer\_server\_fire\_when directive initiate a timer to fire a user provided timer service routine when the specified time of day has been reached. When the interval has elapsed, the timer service routine will be invoked from a clock tick directive by the rtems\_timer\_fire\_when directive and from the Timer Server task if initiated by the rtems\_timer\_server\_fire\_when directive.

## <span id="page-305-5"></span>11.3.5 Canceling a Timer

The rtems\_timer\_cancel directive is used to halt the specified timer. Once canceled, the timer service routine will not fire unless the timer is reinitiated. The timer can be reinitiated using the rtems\_timer\_reset, rtems\_timer\_fire\_after, and rtems\_timer\_fire\_when directives.

## <span id="page-305-6"></span>11.3.6 Resetting a Timer

The rtems\_timer\_reset directive is used to restore an interval timer initiated by a previous invocation of rtems\_timer\_fire\_after or rtems\_timer\_server\_fire\_after to its original interval length. If the timer has not been used or the last usage of this timer was by the rtems\_timer\_fire\_when or rtems\_timer\_server\_fire\_when directive, then an error is returned. The timer service routine is not changed or fired by this directive.

## <span id="page-305-7"></span>11.3.7 Initiating the Timer Server

The rtems\_timer\_initiate\_server directive is used to allocate and start the execution of the Timer Server task. The application can specify both the stack size and attributes of the Timer Server. The Timer Server executes at a priority higher than any application task and thus the user can expect to be preempted as the result of executing the rtems\_timer\_initiate\_server directive.

## <span id="page-306-0"></span>11.3.8 Deleting a Timer

The rtems\_timer\_delete directive is used to delete a timer. If the timer is running and has not expired, the timer is automatically canceled. The timer's control block is returned to the TMCB free list when it is deleted. A timer can be deleted by a task other than the task which created the timer. Any subsequent references to the timer's name and ID are invalid.

11.3. Operations 279

# <span id="page-307-0"></span>11.4 Directives

This section details the directives of the Timer Manager. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

## <span id="page-308-1"></span><span id="page-308-0"></span>11.4.1 rtems\_timer\_create()

Creates a timer.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_timer_create( rtems_name name, rtems_id *id );
```

#### PARAMETERS:

#### **name**

This parameter is the object name of the timer.

#### **id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the identifier of the created timer will be stored in this object.

#### DESCRIPTION:

This directive creates a timer which resides on the local node. The timer has the user-defined object name specified in name. The assigned object identifier is returned in id. This identifier is used to access the timer with other timer related directives.

#### RETURN VALUES:

### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_NAME**

The name parameter was invalid.

#### **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

## **RTEMS\_TOO\_MANY**

There was no inactive object available to create a timer. The number of timers available to the application is configured through the *[CONFIGURE\\_MAXIMUM\\_TIMERS](#page-651-0)* (page 624) application configuration option.

## NOTES:

The processor used to maintain the timer is the processor of the calling task at some point during the timer creation.

For control and maintenance of the timer, RTEMS allocates a *[TMCB](#page-1077-4)* from the local TMCB free pool and initializes it.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

11.4. Directives 281

- The number of timers available to the application is configured through the *[CONFIG-](#page-651-0)[URE\\_MAXIMUM\\_TIMERS](#page-651-0)* (page 624) application configuration option.
- Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace.

## <span id="page-310-1"></span><span id="page-310-0"></span>11.4.2 rtems\_timer\_ident()

Identifies a timer by the object name.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_timer_ident( rtems_name name, rtems_id *id );
```

#### PARAMETERS:

#### **name**

This parameter is the object name to look up.

#### **id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the object identifier of an object with the specified name will be stored in this object.

#### DESCRIPTION:

This directive obtains a timer identifier associated with the timer name specified in name.

#### RETURN VALUES:

### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_NAME**

The name parameter was 0.

#### **RTEMS\_INVALID\_NAME**

There was no object with the specified name on the local node.

#### NOTES:

If the timer name is not unique, then the timer identifier will match the first timer with that name in the search order. However, this timer identifier is not guaranteed to correspond to the desired timer.

The objects are searched from lowest to the highest index. Only the local node is searched.

The timer identifier is used with other timer related directives to access the timer.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

11.4. Directives 283

## <span id="page-311-1"></span><span id="page-311-0"></span>11.4.3 rtems\_timer\_cancel()

Cancels the timer.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_timer_cancel( rtems_id id );
```

#### PARAMETERS:

**id**

This parameter is the timer identifier.

#### DESCRIPTION:

This directive cancels the timer specified by id. This timer will be reinitiated by the next invocation of *[rtems\\_timer\\_reset\(\)](#page-323-0)* (page 296), *[rtems\\_timer\\_fire\\_after\(\)](#page-313-0)* (page 286), *[rtems\\_timer\\_fire\\_when\(\)](#page-315-0)* (page 288), *[rtems\\_timer\\_server\\_fire\\_after\(\)](#page-319-0)* (page 292), or *[rtems\\_timer\\_server\\_fire\\_when\(\)](#page-321-0)* (page 294) with the same timer identifier.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

### **RTEMS\_INVALID\_ID**

There was no timer associated with the identifier specified by id.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

## <span id="page-312-1"></span><span id="page-312-0"></span>11.4.4 rtems\_timer\_delete()

Deletes the timer.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_timer_delete( rtems_id id );
```

#### PARAMETERS:

## **id**

This parameter is the timer identifier.

#### DESCRIPTION:

This directive deletes the timer specified by id. If the timer is running, it is automatically canceled.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no timer associated with the identifier specified by id.

#### NOTES:

The *[TMCB](#page-1077-4)* for the deleted timer is reclaimed by RTEMS.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- The calling task does not have to be the task that created the object. Any local task that knows the object identifier can delete the object.
- Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace.

11.4. Directives 285

## <span id="page-313-1"></span><span id="page-313-0"></span>11.4.5 rtems\_timer\_fire\_after()

Fires the timer after the interval.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_timer_fire_after(
2 rtems_id id,
3 rtems_interval ticks,
4 rtems_timer_service_routine_entry routine,
5 void *user_data
6 );
```

#### PARAMETERS:

#### **id**

This parameter is the timer identifier.

#### **ticks**

This parameter is the interval until the routine is fired in clock ticks.

#### **routine**

This parameter is the routine to schedule.

#### **user\_data**

This parameter is the argument passed to the routine when it is fired.

## DESCRIPTION:

This directive initiates the timer specified by id. If the timer is running, it is automatically canceled before being initiated. The timer is scheduled to fire after an interval of clock ticks has passed specified by ticks. When the timer fires, the timer service routine routine will be invoked with the argument user\_data in the context of the clock tick *[ISR](#page-1067-0)*.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_NUMBER**

The ticks parameter was 0.

#### **RTEMS\_INVALID\_ADDRESS**

The routine parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no timer associated with the identifier specified by id.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.

â€¢ The directive will not cause the calling task to be preempted.

11.4. Directives 287

## <span id="page-315-1"></span><span id="page-315-0"></span>11.4.6 rtems\_timer\_fire\_when()

Fires the timer at the time of day.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_timer_fire_when(
2 rtems_id id,
3 const rtems_time_of_day *wall_time,
4 rtems_timer_service_routine_entry routine,
5 void *user_data
6 );
```

#### PARAMETERS:

#### **id**

This parameter is the timer identifier.

#### **wall\_time**

This parameter is the time of day when the routine is fired.

#### **routine**

This parameter is the routine to schedule.

#### **user\_data**

This parameter is the argument passed to the routine when it is fired.

## DESCRIPTION:

This directive initiates the timer specified by id. If the timer is running, it is automatically canceled before being initiated. The timer is scheduled to fire at the time of day specified by wall\_time. When the timer fires, the timer service routine routine will be invoked with the argument user\_data in the context of the clock tick *[ISR](#page-1067-0)*.

## RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_NOT\_DEFINED**

The system date and time was not set.

#### **RTEMS\_INVALID\_ADDRESS**

The routine parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ADDRESS**

The wall\_time parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_CLOCK**

The time of day was invalid.

#### **RTEMS\_INVALID\_ID**

There was no timer associated with the identifier specified by id.

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

11.4. Directives 289

## <span id="page-317-1"></span><span id="page-317-0"></span>11.4.7 rtems\_timer\_initiate\_server()

Initiates the Timer Server.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_timer_initiate_server(
2 rtems_task_priority priority,
3 size_t stack_size,
4 rtems_attribute attribute_set
5 );
```

#### PARAMETERS:

#### **priority**

This parameter is the task priority.

#### **stack\_size**

This parameter is the task stack size in bytes.

#### **attribute\_set**

This parameter is the task attribute set.

## DESCRIPTION:

This directive initiates the Timer Server task. This task is responsible for executing all timers initiated via the *[rtems\\_timer\\_server\\_fire\\_after\(\)](#page-319-0)* (page 292) or *[rtems\\_timer\\_server\\_fire\\_when\(\)](#page-321-0)* (page 294) directives.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INCORRECT\_STATE**

The Timer Server was already initiated.

#### **RTEMS\_INVALID\_PRIORITY**

The task priority was invalid.

#### **RTEMS\_TOO\_MANY**

There was no inactive task object available to create the Timer Server task.

## **RTEMS\_UNSATISFIED**

There was not enough memory to allocate the task storage area. The task storage area contains the task stack, the thread-local storage, and the floating point context.

#### **RTEMS\_UNSATISFIED**

One of the task create extensions failed to create the Timer Server task.

## NOTES:

The Timer Server task is created using the *[rtems\\_task\\_create\(\)](#page-136-0)* (page 109) directive and must be accounted for when configuring the system.

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The number of timers available to the application is configured through the *[CONFIG-](#page-651-0)[URE\\_MAXIMUM\\_TIMERS](#page-651-0)* (page 624) application configuration option.
- Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace.

11.4. Directives 291

## <span id="page-319-1"></span><span id="page-319-0"></span>11.4.8 rtems\_timer\_server\_fire\_after()

Fires the timer after the interval using the Timer Server.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_timer_server_fire_after(
2 rtems_id id,
3 rtems_interval ticks,
4 rtems_timer_service_routine_entry routine,
5 void *user_data
6 );
```

#### PARAMETERS:

#### **id**

This parameter is the timer identifier.

#### **ticks**

This parameter is the interval until the routine is fired in clock ticks.

#### **routine**

This parameter is the routine to schedule.

#### **user\_data**

This parameter is the argument passed to the routine when it is fired.

## DESCRIPTION:

This directive initiates the timer specified by id. If the timer is running, it is automatically canceled before being initiated. The timer is scheduled to fire after an interval of clock ticks has passed specified by ticks. When the timer fires, the timer service routine routine will be invoked with the argument user\_data in the context of the Timer Server task.

## RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INCORRECT\_STATE**

The Timer Server was not initiated.

#### **RTEMS\_INVALID\_NUMBER**

The ticks parameter was 0.

#### **RTEMS\_INVALID\_ADDRESS**

The routine parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no timer associated with the identifier specified by id.

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

11.4. Directives 293

## <span id="page-321-1"></span><span id="page-321-0"></span>11.4.9 rtems\_timer\_server\_fire\_when()

Fires the timer at the time of day using the Timer Server.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_timer_server_fire_when(
2 rtems_id id,
3 const rtems_time_of_day *wall_time,
4 rtems_timer_service_routine_entry routine,
5 void *user_data
6 );
```

#### PARAMETERS:

#### **id**

This parameter is the timer identifier.

#### **wall\_time**

This parameter is the time of day when the routine is fired.

#### **routine**

This parameter is the routine to schedule.

#### **user\_data**

This parameter is the argument passed to the routine when it is fired.

## DESCRIPTION:

This directive initiates the timer specified by id. If the timer is running, it is automatically canceled before being initiated. The timer is scheduled to fire at the time of day specified by wall\_time. When the timer fires, the timer service routine routine will be invoked with the argument user\_data in the context of the Timer Server task.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INCORRECT\_STATE**

The Timer Server was not initiated.

## **RTEMS\_NOT\_DEFINED**

The system date and time was not set.

#### **RTEMS\_INVALID\_ADDRESS**

The routine parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ADDRESS**

The wall\_time parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_CLOCK**

The time of day was invalid.

## **RTEMS\_INVALID\_ID**

There was no timer associated with the identifier specified by id.

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

11.4. Directives 295

## <span id="page-323-1"></span><span id="page-323-0"></span>11.4.10 rtems\_timer\_reset()

Resets the timer.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_timer_reset( rtems_id id );
```

### PARAMETERS:

## **id**

This parameter is the timer identifier.

#### DESCRIPTION:

This directive resets the timer specified by id. This timer must have been previously initiated with either the *[rtems\\_timer\\_fire\\_after\(\)](#page-313-0)* (page 286) or *[rtems\\_timer\\_server\\_fire\\_after\(\)](#page-319-0)* (page 292) directive. If active the timer is canceled, after which the timer is reinitiated using the same interval and timer service routine which the original *[rtems\\_timer\\_fire\\_after\(\)](#page-313-0)* (page 286) or *[rtems\\_timer\\_server\\_fire\\_after\(\)](#page-319-0)* (page 292) directive used.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no timer associated with the identifier specified by id.

#### **RTEMS\_NOT\_DEFINED**

The timer was not of the interval class.

## NOTES:

If the timer has not been used or the last usage of this timer was by a *[rtems\\_timer\\_fire\\_when\(\)](#page-315-0)* (page 288) or *[rtems\\_timer\\_server\\_fire\\_when\(\)](#page-321-0)* (page 294) directive, then the RTEMS\_NOT\_DEFINED error is returned.

Restarting a cancelled after timer results in the timer being reinitiated with its previous timer service routine and interval.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

## <span id="page-324-1"></span><span id="page-324-0"></span>11.4.11 rtems\_timer\_get\_information()

Gets information about the timer.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_timer_get_information(
2 rtems_id id,
3 rtems_timer_information *the_info
4 );
```

#### PARAMETERS:

#### **id**

This parameter is the timer identifier.

#### **the\_info**

This parameter is the pointer to an *[rtems\\_timer\\_information](#page-86-3)* (page 59) object. When the directive call is successful, the information about the timer will be stored in this object.

#### DESCRIPTION:

This directive returns information about the timer.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The the\_info parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no timer associated with the identifier specified by id.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

11.4. Directives 297

CHAPTER

**TWELVE**

# <span id="page-326-0"></span>RATE MONOTONIC MANAGER

# <span id="page-327-0"></span>12.1 Introduction

The Rate-Monotonic Manager provides facilities to implement tasks which execute in a periodic fashion. Critically, it also gathers information about the execution of those periods and can provide important statistics to the user which can be used to analyze and tune the application. The directives provided by the Rate-Monotonic Manager are:

- *[rtems\\_rate\\_monotonic\\_create\(\)](#page-339-0)* (page 312) Creates a period.
- *[rtems\\_rate\\_monotonic\\_ident\(\)](#page-341-0)* (page 314) Identifies a period by the object name.
- *[rtems\\_rate\\_monotonic\\_cancel\(\)](#page-342-0)* (page 315) Cancels the period.
- *[rtems\\_rate\\_monotonic\\_delete\(\)](#page-343-0)* (page 316) Deletes the period.
- *[rtems\\_rate\\_monotonic\\_period\(\)](#page-344-0)* (page 317) Concludes the current period and start the next period, or gets the period status.
- *[rtems\\_rate\\_monotonic\\_get\\_status\(\)](#page-346-0)* (page 319) Gets the detailed status of the period.
- *[rtems\\_rate\\_monotonic\\_get\\_statistics\(\)](#page-348-0)* (page 321) Gets the statistics of the period.
- *[rtems\\_rate\\_monotonic\\_reset\\_statistics\(\)](#page-350-0)* (page 323) Resets the statistics of the period.
- *[rtems\\_rate\\_monotonic\\_reset\\_all\\_statistics\(\)](#page-351-0)* (page 324) Resets the statistics of all periods.
- *[rtems\\_rate\\_monotonic\\_report\\_statistics\(\)](#page-352-0)* (page 325) Reports the period statistics using the *[printk\(\)](#page-520-0)* (page 493) printer.
- *[rtems\\_rate\\_monotonic\\_report\\_statistics\\_with\\_plugin\(\)](#page-353-0)* (page 326) Reports the period statistics using the printer plugin.

# <span id="page-328-0"></span>12.2 Background

The rate monotonic manager provides facilities to manage the execution of periodic tasks. This manager was designed to support application designers who utilize the Rate Monotonic Scheduling Algorithm (RMS) to ensure that their periodic tasks will meet their deadlines, even under transient overload conditions. Although designed for hard real-time systems, the services provided by the rate monotonic manager may be used by any application which requires periodic tasks.

## <span id="page-328-1"></span>12.2.1 Rate Monotonic Manager Required Support

A clock tick is required to support the functionality provided by this manager.

## <span id="page-328-2"></span>12.2.2 Period Statistics

This manager maintains a set of statistics on each period object. These statistics are reset implictly at period creation time and may be reset or obtained at any time by the application. The following is a list of the information kept:

#### **owner**

is the id of the thread that owns this period.

#### **count**

is the total number of periods executed.

## **missed\_count**

is the number of periods that were missed.

#### **min\_cpu\_time**

is the minimum amount of CPU execution time consumed on any execution of the periodic loop.

#### **max\_cpu\_time**

is the maximum amount of CPU execution time consumed on any execution of the periodic loop.

#### **total\_cpu\_time**

is the total amount of CPU execution time consumed by executions of the periodic loop.

## **min\_wall\_time**

is the minimum amount of wall time that passed on any execution of the periodic loop.

## **max\_wall\_time**

is the maximum amount of wall time that passed on any execution of the periodic loop.

#### **total\_wall\_time**

is the total amount of wall time that passed during executions of the periodic loop.

Each period is divided into two consecutive phases. The period starts with the active phase of the task and is followed by the inactive phase of the task. In the inactive phase the task is blocked and waits for the start of the next period. The inactive phase is skipped in case of a period miss. The wall time includes the time during the active phase of the task on which the task is not executing on a processor. The task is either blocked (for example it waits for a resource) or a higher priority tasks executes, thus preventing it from executing. In case the wall time exceeds the period time, then this is a period miss. The gap between the wall time and the period time is the margin between a period miss or success.

12.2. Background 301

<span id="page-329-2"></span>The period statistics information is inexpensive to maintain and can provide very useful insights into the execution characteristics of a periodic task loop. But it is just information. The period statistics reported must be analyzed by the user in terms of what the applications is. For example, in an application where priorities are assigned by the Rate Monotonic Algorithm, it would be very undesirable for high priority (i.e. frequency) tasks to miss their period. Similarly, in nearly any application, if a task were supposed to execute its periodic loop every 10 milliseconds and it averaged 11 milliseconds, then application requirements are not being met.

The information reported can be used to determine the "hot spots" in the application. Given a period's id, the user can determine the length of that period. From that information and the CPU usage, the user can calculate the percentage of CPU time consumed by that periodic task. For example, a task executing for 20 milliseconds every 200 milliseconds is consuming 10 percent of the processor's execution time. This is usually enough to make it a good candidate for optimization.

However, execution time alone is not enough to gauge the value of optimizing a particular task. It is more important to optimize a task executing 2 millisecond every 10 milliseconds (20 percent of the CPU) than one executing 10 milliseconds every 100 (10 percent of the CPU). As a general rule of thumb, the higher frequency at which a task executes, the more important it is to optimize that task.

## <span id="page-329-0"></span>12.2.3 Periodicity Definitions

A periodic task is one which must be executed at a regular interval. The interval between successive iterations of the task is referred to as its period. Periodic tasks can be characterized by the length of their period and execution time. The period and execution time of a task can be used to determine the processor utilization for that task. Processor utilization is the percentage of processor time used and can be calculated on a per-task or system-wide basis. Typically, the task's worst-case execution time will be less than its period. For example, a periodic task's requirements may state that it should execute for 10 milliseconds every 100 milliseconds. Although the execution time may be the average, worst, or best case, the worst-case execution time is more appropriate for use when analyzing system behavior under transient overload conditions.

In contrast, an aperiodic task executes at irregular intervals and has only a soft deadline. In other words, the deadlines for aperiodic tasks are not rigid, but adequate response times are desirable. For example, an aperiodic task may process user input from a terminal.

Finally, a sporadic task is an aperiodic task with a hard deadline and minimum interarrival time. The minimum interarrival time is the minimum period of time which exists between successive iterations of the task. For example, a sporadic task could be used to process the pressing of a fire button on a joystick. The mechanical action of the fire button ensures a minimum time period between successive activations, but the missile must be launched by a hard deadline.

## <span id="page-329-1"></span>12.2.4 Rate Monotonic Scheduling Algorithm

The Rate Monotonic Scheduling Algorithm (RMS) is important to real-time systems designers because it allows one to sufficiently guarantee that a set of tasks is schedulable (see [\[LL73\]](#page-1083-4), [\[LSD89\]](#page-1083-5), [\[SG90\]](#page-1083-6), [\[Bur91\]](#page-1082-5)).

A set of tasks is said to be schedulable if all of the tasks can meet their deadlines. RMS provides a set of rules which can be used to perform a guaranteed schedulability analysis for a task set. This analysis determines whether a task set is schedulable under worst-case conditions and emphasizes the predictability of the system's behavior. It has been proven that:

## <span id="page-330-2"></span>*RMS*

RMS is an optimal fixed-priority algorithm for scheduling independent, preemptible, periodic tasks on a single processor.

RMS is optimal in the sense that if a set of tasks can be scheduled by any fixed-priority algorithm, then RMS will be able to schedule that task set. RMS bases it schedulability analysis on the processor utilization level below which all deadlines can be met.

RMS calls for the static assignment of task priorities based upon their period. The shorter a task's period, the higher its priority. For example, a task with a 1 millisecond period has higher priority than a task with a 100 millisecond period. If two tasks have the same period, then RMS does not distinguish between the tasks. However, RTEMS specifies that when given tasks of equal priority, the task which has been ready longest will execute first. RMS's priority assignment scheme does not provide one with exact numeric values for task priorities. For example, consider the following task set and priority assignments:

| Task | Period (in milliseconds) | Priority |
|------|--------------------------|----------|
| 1    | 100                      | Low      |
| 2    | 50                       | Medium   |
| 3    | 50                       | Medium   |
| 4    | 25                       | High     |

RMS only calls for task 1 to have the lowest priority, task 4 to have the highest priority, and tasks 2 and 3 to have an equal priority between that of tasks 1 and 4. The actual RTEMS priorities assigned to the tasks must only adhere to those guidelines.

Many applications have tasks with both hard and soft deadlines. The tasks with hard deadlines are typically referred to as the critical task set, with the soft deadline tasks being the noncritical task set. The critical task set can be scheduled using RMS, with the non-critical tasks not executing under transient overload, by simply assigning priorities such that the lowest priority critical task (i.e. longest period) has a higher priority than the highest priority non-critical task. Although RMS may be used to assign priorities to the non-critical tasks, it is not necessary. In this instance, schedulability is only guaranteed for the critical task set.

## <span id="page-330-0"></span>12.2.5 Schedulability Analysis

RMS allows application designers to ensure that tasks can meet all deadlines under fixedpriority assignment, even under transient overload, without knowing exactly when any given task will execute by applying proven schedulability analysis rules.

#### <span id="page-330-1"></span>12.2.5.1 Assumptions

The schedulability analysis rules for RMS were developed based on the following assumptions:

- The requests for all tasks for which hard deadlines exist are periodic, with a constant interval between requests.
- Each task must complete before the next request for it occurs.
- The tasks are independent in that a task does not depend on the initiation or completion of requests for other tasks.

12.2. Background 303

- <span id="page-331-3"></span>â€¢ The execution time for each task without preemption or interruption is constant and does not vary.
- Any non-periodic tasks in the system are special. These tasks should not displace periodic tasks while executing and do not have hard, critical deadlines.

Once the basic schedulability analysis is understood, some of the above assumptions can be relaxed and the side-effects accounted for.

#### <span id="page-331-0"></span>12.2.5.2 Processor Utilization Rule

The Processor Utilization Rule requires that processor utilization be calculated based upon the period and execution time of each task. The fraction of processor time spent executing task index is Time(i) / Period(i). The processor utilization can be calculated as follows where n is the number of tasks in the set being analyzed:

$$Utilization = \sum_{i=1}^{n} Time_i / Period_i$$

To ensure schedulability even under transient overload, the processor utilization must adhere to the following rule:

$$maximumUtilization = n * (2^{\frac{1}{n}} - 1)$$

As the number of tasks increases, the above formula approaches ln(2) for a worst-case utilization factor of approximately 0.693. Many tasks sets can be scheduled with a greater utilization factor. In fact, the average processor utilization threshold for a randomly generated task set is approximately 0.88. See more detail in [\[LL73\]](#page-1083-4).

## <span id="page-331-1"></span>12.2.5.3 Processor Utilization Rule Example

This example illustrates the application of the Processor Utilization Rule to an application with three critical periodic tasks. The following table details the RMS priority, period, execution time, and processor utilization for each task:

| Task | RMS Priority | Period | Execution Time | Processor Utilization |
|------|--------------|--------|----------------|-----------------------|
| 1    | High         | 100    | 15             | 0.15                  |
| 2    | Medium       | 200    | 50             | 0.25                  |
| 3    | Low          | 300    | 100            | 0.33                  |

The total processor utilization for this task set is 0.73 which is below the upper bound of 3 \* (2\*\*(1/3) - 1), or 0.779, imposed by the Processor Utilization Rule. Therefore, this task set is guaranteed to be schedulable using RMS.

## <span id="page-331-2"></span>12.2.5.4 First Deadline Rule

If a given set of tasks do exceed the processor utilization upper limit imposed by the Processor Utilization Rule, they can still be guaranteed to meet all their deadlines by application of the First Deadline Rule. This rule can be stated as follows:

For a given set of independent periodic tasks, if each task meets its first deadline when all tasks are started at the same time, then the deadlines will always be met for any combination of start times.

A key point with this rule is that ALL periodic tasks are assumed to start at the exact same instant in time. Although this assumption may seem to be invalid, RTEMS makes it quite easy to ensure. By having a non-preemptible user initialization task, all application tasks, regardless of priority, can be created and started before the initialization deletes itself. This technique ensures that all tasks begin to compete for execution time at the same instant - when the user initialization task deletes itself. See more detail in [\[LSD89\]](#page-1083-5).

#### <span id="page-332-0"></span>12.2.5.5 First Deadline Rule Example

The First Deadline Rule can ensure schedulability even when the Processor Utilization Rule fails. The example below is a modification of the Processor Utilization Rule example where task execution time has been increased from 15 to 25 units. The following table details the RMS priority, period, execution time, and processor utilization for each task:

| Task | RMS Priority | Period | Execution Time | Processor Utilization |
|------|--------------|--------|----------------|-----------------------|
| 1    | High         | 100    | 25             | 0.25                  |
| 2    | Medium       | 200    | 50             | 0.25                  |
| 3    | Low          | 300    | 100            | 0.33                  |

The total processor utilization for the modified task set is 0.83 which is above the upper bound of 3 \* (2\*\*(1/3) - 1), or 0.779, imposed by the Processor Utilization Rule. Therefore, this task set is not guaranteed to be schedulable using RMS. However, the First Deadline Rule can guarantee the schedulability of this task set. This rule calls for one to examine each occurrence of deadline until either all tasks have met their deadline or one task failed to meet its first deadline. The following table details the time of each deadline occurrence, the maximum number of times each task may have run, the total execution time, and whether all the deadlines have been met:

| Deadline Time | Task 1 | Task 2 | Task 3 | Total Execution Time | All Deadlines Met? |
|---------------|--------|--------|--------|----------------------|--------------------|
| 100           | 1      | 1      | 1      | 25 + 50 + 100 = 175  | NO                 |
| 200           | 2      | 1      | 1      | 50 + 50 + 100 = 200  | YES                |

The key to this analysis is to recognize when each task will execute. For example at time 100, task 1 must have met its first deadline, but tasks 2 and 3 may also have begun execution. In this example, at time 100 tasks 1 and 2 have completed execution and thus have met their first deadline. Tasks 1 and 2 have used (25 + 50) = 75 time units, leaving (100 - 75) = 25 time units for task 3 to begin. Because task 3 takes 100 ticks to execute, it will not have completed execution at time 100. Thus at time 100, all of the tasks except task 3 have met their first deadline.

At time 200, task 1 must have met its second deadline and task 2 its first deadline. As a result, of the first 200 time units, task 1 uses (2 \* 25) = 50 and task 2 uses 50, leaving (200 - 100) time units for task 3. Task 3 requires 100 time units to execute, thus it will have completed execution at time 200. Thus, all of the tasks have met their first deadlines at time 200, and the task set is schedulable using the First Deadline Rule.

12.2. Background 305

## <span id="page-333-0"></span>12.2.5.6 Relaxation of Assumptions

The assumptions used to develop the RMS schedulability rules are uncommon in most real-time systems. For example, it was assumed that tasks have constant unvarying execution time. It is possible to relax this assumption, simply by using the worst-case execution time of each task.

Another assumption is that the tasks are independent. This means that the tasks do not wait for one another or contend for resources. This assumption can be relaxed by accounting for the amount of time a task spends waiting to acquire resources. Similarly, each task's execution time must account for any I/O performed and any RTEMS directive calls.

In addition, the assumptions did not account for the time spent executing interrupt service routines. This can be accounted for by including all the processor utilization by interrupt service routines in the utilization calculation. Similarly, one should also account for the impact of delays in accessing local memory caused by direct memory access and other processors accessing local dual-ported memory.

The assumption that nonperiodic tasks are used only for initialization or failure-recovery can be relaxed by placing all periodic tasks in the critical task set. This task set can be scheduled and analyzed using RMS. All nonperiodic tasks are placed in the non-critical task set. Although the critical task set can be guaranteed to execute even under transient overload, the non-critical task set is not guaranteed to execute.

In conclusion, the application designer must be fully cognizant of the system and its run-time behavior when performing schedulability analysis for a system using RMS. Every hardware and software factor which impacts the execution time of each task must be accounted for in the schedulability analysis.

# <span id="page-334-0"></span>12.3 Operations

## <span id="page-334-1"></span>12.3.1 Creating a Rate Monotonic Period

The rtems\_rate\_monotonic\_create directive creates a rate monotonic period which is to be used by the calling task to delineate a period. RTEMS allocates a Period Control Block (PCB) from the PCB free list. This data structure is used by RTEMS to manage the newly created rate monotonic period. RTEMS returns a unique period ID to the application which is used by other rate monotonic manager directives to access this rate monotonic period.

# <span id="page-334-2"></span>12.3.2 Manipulating a Period

The rtems\_rate\_monotonic\_period directive is used to establish and maintain periodic execution utilizing a previously created rate monotonic period. Once initiated by the rtems\_rate\_monotonic\_period directive, the period is said to run until it either expires or is reinitiated. The state of the rate monotonic period results in one of the following scenarios:

- If the rate monotonic period is running, the calling task will be blocked for the remainder of the outstanding period and, upon completion of that period, the period will be reinitiated with the specified period.
- If the rate monotonic period is not currently running and has not expired, it is initiated with a length of period ticks and the calling task returns immediately.
- If the rate monotonic period has expired before the task invokes the rtems\_rate\_monotonic\_period directive, the postponed job will be released until there is no more postponed jobs. The calling task returns immediately with a timeout error status. In the watchdog routine, the period will still be updated periodically and track the count of the postponed jobs [\[CvdBruggenC16\]](#page-1083-7). Please note, the count of the postponed jobs is only saturated until 0xffffffff.

## <span id="page-334-3"></span>12.3.3 Obtaining the Status of a Period

If the rtems\_rate\_monotonic\_period directive is invoked with a period of RTEMS\_PERIOD\_STATUS ticks, the current state of the specified rate monotonic period will be returned. The following table details the relationship between the period's status and the directive status code returned by the rtems\_rate\_monotonic\_period directive:

| RTEMS_SUCCESSFUL  | period is running               |
|-------------------|---------------------------------|
| RTEMS_TIMEOUT     | period has expired              |
| RTEMS_NOT_DEFINED | period has never been initiated |

Obtaining the status of a rate monotonic period does not alter the state or length of that period.

## <span id="page-334-4"></span>12.3.4 Canceling a Period

The rtems\_rate\_monotonic\_cancel directive is used to stop the period maintained by the specified rate monotonic period. The period is stopped and the rate monotonic period can be reinitiated using the rtems\_rate\_monotonic\_period directive.

12.3. Operations 307

## <span id="page-335-0"></span>12.3.5 Deleting a Rate Monotonic Period

The rtems\_rate\_monotonic\_delete directive is used to delete a rate monotonic period. If the period is running and has not expired, the period is automatically canceled. The rate monotonic period's control block is returned to the PCB free list when it is deleted. A rate monotonic period can be deleted by a task other than the task which created the period.

## <span id="page-335-1"></span>12.3.6 Examples

The following sections illustrate common uses of rate monotonic periods to construct periodic tasks.

## <span id="page-335-2"></span>12.3.7 Simple Periodic Task

This example consists of a single periodic task which, after initialization, executes every 100 clock ticks.

```
1 rtems_task Periodic_task(rtems_task_argument arg)
2 {
3 rtems_name name;
4 rtems_id period;
5 rtems_status_code status;
6 name = rtems_build_name( 'P', 'E', 'R', 'D' );
7 status = rtems_rate_monotonic_create( name, &period );
8 if ( status != RTEMS_SUCCESSFUL ) {
9 printf( "rtems_monotonic_create failed with status of %d.\n", status );
10 exit( 1 );
11 }
12 while ( 1 ) {
13 if ( rtems_rate_monotonic_period( period, 100 ) == RTEMS_TIMEOUT )
14 break;
15 /* Perform some periodic actions */
16 }
17 /* missed period so delete period and SELF */
18 status = rtems_rate_monotonic_delete( period );
19 if ( status != RTEMS_SUCCESSFUL ) {
20 printf( "rtems_rate_monotonic_delete failed with status of %d.\n", statusâ£
  Ë“â†’);
21 exit( 1 );
22 }
23 status = rtems_task_delete( RTEMS_SELF ); /* should not return */
24 printf( "rtems_task_delete returned with status of %d.\n", status );
25 exit( 1 );
26 }
```

The above task creates a rate monotonic period as part of its initialization. The first time the loop is executed, the rtems\_rate\_monotonic\_period directive will initiate the period for 100 ticks and return immediately. Subsequent invocations of the rtems\_rate\_monotonic\_period directive will result in the task blocking for the remainder of the 100 tick period. If, for any reason, the body of the loop takes more than 100 ticks to execute, the rtems\_rate\_monotonic\_period directive will return the RTEMS\_TIMEOUT status. If the above task misses its deadline, it will delete the rate monotonic period and itself.

## <span id="page-336-0"></span>12.3.8 Task with Multiple Periods

This example consists of a single periodic task which, after initialization, performs two sets of actions every 100 clock ticks. The first set of actions is performed in the first forty clock ticks of every 100 clock ticks, while the second set of actions is performed between the fortieth and seventieth clock ticks. The last thirty clock ticks are not used by this task.

```
1 rtems_task Periodic_task(rtems_task_argument arg)
2 {
3 rtems_name name_1, name_2;
4 rtems_id period_1, period_2;
5 name_1 = rtems_build_name( 'P', 'E', 'R', '1' );
6 name_2 = rtems_build_name( 'P', 'E', 'R', '2' );
7 (void ) rtems_rate_monotonic_create( name_1, &period_1 );
8 (void ) rtems_rate_monotonic_create( name_2, &period_2 );
9 while ( 1 ) {
10 if ( rtems_rate_monotonic_period( period_1, 100 ) == RTEMS_TIMEOUT )
11 break;
12 if ( rtems_rate_monotonic_period( period_2, 40 ) == RTEMS_TIMEOUT )
13 break;
14 /*
15 * Perform first set of actions between clock
16 * ticks 0 and 39 of every 100 ticks.
17 */
18 if ( rtems_rate_monotonic_period( period_2, 30 ) == RTEMS_TIMEOUT )
19 break;
20 /*
21 * Perform second set of actions between clock 40 and 69
22 * of every 100 ticks. THEN ...
23 *
24 * Check to make sure we didn't miss the period_2 period.
25 */
26 if ( rtems_rate_monotonic_period( period_2, RTEMS_PERIOD_STATUS ) ==â£
  Ë“â†’RTEMS_TIMEOUT )
27 break;
28 (void) rtems_rate_monotonic_cancel( period_2 );
29 }
30 /* missed period so delete period and SELF */
31 (void ) rtems_rate_monotonic_delete( period_1 );
32 (void ) rtems_rate_monotonic_delete( period_2 );
33 (void ) rtems_task_delete( RTEMS_SELF );
34 }
```

The above task creates two rate monotonic periods as part of its initialization. The first time the loop is executed, the rtems\_rate\_monotonic\_period directive will initiate the period\_1 period for 100 ticks and return immediately. Subsequent invocations of the rtems\_rate\_monotonic\_period directive for period\_1 will result in the task blocking for the remainder of the 100 tick period. The period\_2 period is used to control the execution time of the two sets of actions within each 100 tick period established by period\_1. The rtems\_rate\_monotonic\_cancel( period\_2 ) call is performed to ensure that the period\_2 period does not expire while the task is blocked on the period\_1 period. If this cancel operation were not performed, every time the rtems\_rate\_monotonic\_period( period\_2, 40 ) call is ex-

12.3. Operations 309

ecuted, except for the initial one, a directive status of RTEMS\_TIMEOUT is returned. It is important to note that every time this call is made, the period\_2 period will be initiated immediately and the task will not block.

If, for any reason, the task misses any deadline, the rtems\_rate\_monotonic\_period directive will return the RTEMS\_TIMEOUT directive status. If the above task misses its deadline, it will delete the rate monotonic periods and itself.

# <span id="page-338-0"></span>12.4 Directives

This section details the directives of the Rate-Monotonic Manager. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

12.4. Directives 311

## <span id="page-339-1"></span><span id="page-339-0"></span>12.4.1 rtems\_rate\_monotonic\_create()

Creates a period.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_rate_monotonic_create( rtems_name name, rtems_id *id );
```

#### PARAMETERS:

#### **name**

This parameter is the object name of the period.

#### **id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the identifier of the created period will be stored in this object.

#### DESCRIPTION:

This directive creates a period which resides on the local node. The period has the user-defined object name specified in name The assigned object identifier is returned in id. This identifier is used to access the period with other rate monotonic related directives.

#### RETURN VALUES:

### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_NAME**

The name parameter was invalid.

#### **RTEMS\_TOO\_MANY**

There was no inactive object available to create a period. The number of periods available to the application is configured through the *[CONFIGURE\\_MAXIMUM\\_PERIODS](#page-646-0)* (page 619) application configuration option.

#### NOTES:

The calling task is registered as the owner of the created period. Some directives can be only used by this task for the created period.

For control and maintenance of the period, RTEMS allocates a *[PCB](#page-1070-0)* from the local PCB free pool and initializes it.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- The number of periods available to the application is configured through the *[CONFIG-](#page-646-0)[URE\\_MAXIMUM\\_PERIODS](#page-646-0)* (page 619) application configuration option.

â€¢ Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace.

12.4. Directives 313

## <span id="page-341-1"></span><span id="page-341-0"></span>12.4.2 rtems\_rate\_monotonic\_ident()

Identifies a period by the object name.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_rate_monotonic_ident( rtems_name name, rtems_id *id );
```

#### PARAMETERS:

#### **name**

This parameter is the object name to look up.

#### **id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the object identifier of an object with the specified name will be stored in this object.

#### DESCRIPTION:

This directive obtains a period identifier associated with the period name specified in name.

#### RETURN VALUES:

### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_NAME**

The name parameter was 0.

#### **RTEMS\_INVALID\_NAME**

There was no object with the specified name on the local node.

#### NOTES:

If the period name is not unique, then the period identifier will match the first period with that name in the search order. However, this period identifier is not guaranteed to correspond to the desired period.

The objects are searched from lowest to the highest index. Only the local node is searched.

The period identifier is used with other rate monotonic related directives to access the period.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-342-1"></span><span id="page-342-0"></span>12.4.3 rtems\_rate\_monotonic\_cancel()

Cancels the period.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_rate_monotonic_cancel( rtems_id id );
```

### PARAMETERS:

## **id**

This parameter is the rate monotonic period identifier.

#### DESCRIPTION:

This directive cancels the rate monotonic period specified by id. This period may be reinitiated by the next invocation of *[rtems\\_rate\\_monotonic\\_period\(\)](#page-344-0)* (page 317).

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no rate monotonic period associated with the identifier specified by id.

#### **RTEMS\_NOT\_OWNER\_OF\_RESOURCE**

The rate monotonic period was not created by the calling task.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.
- The directive may be used exclusively by the task which created the associated object.

12.4. Directives 315

## <span id="page-343-1"></span><span id="page-343-0"></span>12.4.4 rtems\_rate\_monotonic\_delete()

Deletes the period.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_rate_monotonic_delete( rtems_id id );
```

### PARAMETERS:

#### **id**

This parameter is the period identifier.

#### DESCRIPTION:

This directive deletes the period specified by id. If the period is running, it is automatically canceled.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no period associated with the identifier specified by id.

#### NOTES:

The *[PCB](#page-1070-0)* for the deleted period is reclaimed by RTEMS.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- The calling task does not have to be the task that created the object. Any local task that knows the object identifier can delete the object.
- Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace.

## <span id="page-344-1"></span><span id="page-344-0"></span>12.4.5 rtems\_rate\_monotonic\_period()

Concludes the current period and start the next period, or gets the period status.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_rate_monotonic_period(
2 rtems_id id,
3 rtems_interval length
4 );
```

#### PARAMETERS:

#### **id**

This parameter is the rate monotonic period identifier.

#### **length**

This parameter is the period length in *[clock ticks](#page-1062-1)* or RTEMS\_PERIOD\_STATUS to get the period status.

#### DESCRIPTION:

This directive initiates the rate monotonic period specified by id with a length of period ticks specified by length. If the period is running, then the calling task will block for the remainder of the period before reinitiating the period with the specified period length. If the period was not running (either expired or never initiated), the period is immediately initiated and the directive returns immediately. If the period has expired, the postponed job will be released immediately and the following calls of this directive will release postponed jobs until there is no more deadline miss.

If invoked with a period length of RTEMS\_PERIOD\_STATUS ticks, the current state of the period will be returned. The directive status indicates the current state of the period. This does not alter the state or period length of the period.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no rate monotonic period associated with the identifier specified by id.

#### **RTEMS\_NOT\_OWNER\_OF\_RESOURCE**

The rate monotonic period was not created by the calling task.

#### **RTEMS\_NOT\_DEFINED**

The rate monotonic period has never been initiated (only possible when the length parameter was equal to RTEMS\_PERIOD\_STATUS).

#### **RTEMS\_TIMEOUT**

The rate monotonic period has expired.

12.4. Directives 317

### NOTES:

Resetting the processor usage time of tasks has no impact on the period status and statistics.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive may be used exclusively by the task which created the associated object.

## <span id="page-346-1"></span><span id="page-346-0"></span>12.4.6 rtems\_rate\_monotonic\_get\_status()

Gets the detailed status of the period.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_rate_monotonic_get_status(
2 rtems_id id,
3 rtems_rate_monotonic_period_status *status
4 );
```

#### PARAMETERS:

#### **id**

This parameter is the rate monotonic period identifier.

#### **status**

This parameter is the pointer to an *[rtems\\_rate\\_monotonic\\_period\\_status](#page-77-0)* (page 50) object. When the directive call is successful, the detailed period status will be stored in this object.

#### DESCRIPTION:

This directive returns the detailed status of the rate monotonic period specified by id. The detailed status of the period will be returned in the members of the period status object referenced by status:

- The owner member is set to the identifier of the owner task of the period.
- The state member is set to the current state of the period.
- The postponed\_jobs\_count member is set to the count of jobs which are not released yet.
- If the current state of the period is RATE\_MONOTONIC\_INACTIVE, the since\_last\_period and executed\_since\_last\_period members will be set to zero. Otherwise, both members will contain time information since the last successful invocation of the *[rtems\\_rate\\_monotonic\\_period\(\)](#page-344-0)* (page 317) directive by the owner task. More specifically, the since\_last\_period member will be set to the time elapsed since the last successful invocation. The executed\_since\_last\_period member will be set to the processor time consumed by the owner task since the last successful invocation.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no rate monotonic period associated with the identifier specified by id.

#### **RTEMS\_INVALID\_ADDRESS**

The status parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

12.4. Directives 319

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive may be called from within interrupt context.
- The directive will not cause the calling task to be preempted.

## <span id="page-348-1"></span><span id="page-348-0"></span>12.4.7 rtems\_rate\_monotonic\_get\_statistics()

Gets the statistics of the period.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_rate_monotonic_get_statistics(
2 rtems_id id,
3 rtems_rate_monotonic_period_statistics *status
4 );
```

#### PARAMETERS:

#### **id**

This parameter is the rate monotonic period identifier.

#### **status**

This parameter is the pointer to an *[rtems\\_rate\\_monotonic\\_period\\_statistics](#page-76-3)* (page 49) object. When the directive call is successful, the period statistics will be stored in this object.

#### DESCRIPTION:

This directive returns the statistics of the rate monotonic period specified by id. The statistics of the period will be returned in the members of the period statistics object referenced by status:

- The count member is set to the number of periods executed.
- The missed\_count member is set to the number of periods missed.
- The min\_cpu\_time member is set to the least amount of processor time used in the period.
- The max\_cpu\_time member is set to the highest amount of processor time used in the period.
- The total\_cpu\_time member is set to the total amount of processor time used in the period.
- The min\_wall\_time member is set to the least amount of *[CLOCK\\_MONOTONIC](#page-1062-0)* time used in the period.
- The max\_wall\_time member is set to the highest amount of *[CLOCK\\_MONOTONIC](#page-1062-0)* time used in the period.
- The total\_wall\_time member is set to the total amount of *[CLOCK\\_MONOTONIC](#page-1062-0)* time used in the period.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no rate monotonic period associated with the identifier specified by id.

### **RTEMS\_INVALID\_ADDRESS**

The status parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

12.4. Directives 321

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive may be called from within interrupt context.
- The directive will not cause the calling task to be preempted.

## <span id="page-350-1"></span><span id="page-350-0"></span>12.4.8 rtems\_rate\_monotonic\_reset\_statistics()

Resets the statistics of the period.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_rate_monotonic_reset_statistics( rtems_id id );
```

#### PARAMETERS:

## **id**

This parameter is the rate monotonic period identifier.

#### DESCRIPTION:

This directive resets the statistics of the rate monotonic period specified by id.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no rate monotonic period associated with the identifier specified by id.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive may be called from within interrupt context.
- The directive will not cause the calling task to be preempted.

12.4. Directives 323

<span id="page-351-1"></span><span id="page-351-0"></span>12.4.9 rtems\_rate\_monotonic\_reset\_all\_statistics()

Resets the statistics of all periods.

## CALLING SEQUENCE:

```
1 void rtems_rate_monotonic_reset_all_statistics( void );
```

### DESCRIPTION:

This directive resets the statistics information associated with all rate monotonic period instances.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

## <span id="page-352-1"></span><span id="page-352-0"></span>12.4.10 rtems\_rate\_monotonic\_report\_statistics()

Reports the period statistics using the *[printk\(\)](#page-520-0)* (page 493) printer.

#### CALLING SEQUENCE:

```
1 void rtems_rate_monotonic_report_statistics( void );
```

### DESCRIPTION:

This directive prints a report on all active periods which have executed at least one period using the *[printk\(\)](#page-520-0)* (page 493) printer.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

12.4. Directives 325

## <span id="page-353-1"></span><span id="page-353-0"></span>12.4.11 rtems\_rate\_monotonic\_report\_statistics\_with\_plugin()

Reports the period statistics using the printer plugin.

#### CALLING SEQUENCE:

```
1 void rtems_rate_monotonic_report_statistics_with_plugin(
2 const struct rtems_printer *printer
3 );
```

#### PARAMETERS:

#### **printer**

This parameter is the printer plugin to output the report.

#### DESCRIPTION:

This directive prints a report on all active periods which have executed at least one period using the printer plugin specified by printer.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

CHAPTER

# **THIRTEEN**

# <span id="page-354-0"></span>SEMAPHORE MANAGER

# <span id="page-355-0"></span>13.1 Introduction

The Semaphore Manager utilizes standard Dijkstra counting semaphores to provide synchronization and mutual exclusion capabilities. The directives provided by the Semaphore Manager are:

- *[rtems\\_semaphore\\_create\(\)](#page-362-0)* (page 335) Creates a semaphore.
- *[rtems\\_semaphore\\_ident\(\)](#page-366-0)* (page 339) Identifies a semaphore by the object name.
- *[rtems\\_semaphore\\_delete\(\)](#page-368-0)* (page 341) Deletes the semaphore.
- *[rtems\\_semaphore\\_obtain\(\)](#page-370-0)* (page 343) Obtains the semaphore.
- *[rtems\\_semaphore\\_release\(\)](#page-373-0)* (page 346) Releases the semaphore.
- *[rtems\\_semaphore\\_flush\(\)](#page-375-0)* (page 348) Flushes the semaphore.
- *[rtems\\_semaphore\\_set\\_priority\(\)](#page-377-0)* (page 350) Sets the priority by scheduler for the semaphore.

# <span id="page-356-0"></span>13.2 Background

A semaphore can be viewed as a protected variable whose value can be modified only with the rtems\_semaphore\_create, rtems\_semaphore\_obtain, and rtems\_semaphore\_release directives. RTEMS supports both binary and counting semaphores. A binary semaphore is restricted to values of zero or one, while a counting semaphore can assume any non-negative integer value.

A binary semaphore (not a simple binary semaphore) can be used to control access to a single resource. In particular, it can be used to enforce mutual exclusion for a critical section in user code (mutex). In this instance, the semaphore would be created with an initial count of one to indicate that no task is executing the critical section of code. Upon entry to the critical section, a task must issue the rtems\_semaphore\_obtain directive to prevent other tasks from entering the critical section. Upon exit from the critical section, the task that obtained the binary semaphore must issue the rtems\_semaphore\_release directive to allow another task to execute the critical section. A binary semaphore must be released by the task that obtained it.

A counting semaphore can be used to control access to a pool of two or more resources. For example, access to three printers could be administered by a semaphore created with an initial count of three. When a task requires access to one of the printers, it issues the rtems\_semaphore\_obtain directive to obtain access to a printer. If a printer is not currently available, the task can wait for a printer to become available or return immediately. When the task has completed printing, it should issue the rtems\_semaphore\_release directive to allow other tasks access to the printer.

Task synchronization may be achieved by creating a semaphore with an initial count of zero. One task waits for the arrival of another task by issuing a rtems\_semaphore\_obtain directive when it reaches a synchronization point. The other task performs a corresponding rtems\_semaphore\_release operation when it reaches its synchronization point, thus unblocking the pending task.

# <span id="page-356-1"></span>13.2.1 Nested Resource Access

Deadlock occurs when a task owning a binary semaphore attempts to acquire that same semaphore and blocks as result. Since the semaphore is allocated to a task, it cannot be deleted. Therefore, the task that currently holds the semaphore and is also blocked waiting for that semaphore will never execute again.

RTEMS addresses this problem by allowing the task holding the binary semaphore to obtain the same binary semaphore multiple times in a nested manner. Each rtems\_semaphore\_obtain must be accompanied with a rtems\_semaphore\_release. The semaphore will only be made available for acquisition by other tasks when the outermost rtems\_semaphore\_obtain is matched with a rtems\_semaphore\_release.

Simple binary semaphores do not allow nested access and so can be used for task synchronization.

## <span id="page-356-2"></span>13.2.2 Priority Inheritance

RTEMS supports *[priority inheritance](#page-56-3)* (page 29) for local, binary semaphores that use the priority task wait queue blocking discipline. In SMP configurations, the *[O\(m\) Independence-Preserving](#page-57-1) [Protocol \(OMIP\)](#page-57-1)* (page 30) is used instead.

13.2. Background 329

## <span id="page-357-0"></span>13.2.3 Priority Ceiling

RTEMS supports *[priority ceiling](#page-56-2)* (page 29) for local, binary semaphores that use the priority task wait queue blocking discipline.

## <span id="page-357-1"></span>13.2.4 Multiprocessor Resource Sharing Protocol

RTEMS supports the *[Multiprocessor Resource Sharing Protocol \(MrsP\)](#page-57-0)* (page 30) for local, binary semaphores that use the priority task wait queue blocking discipline. In uniprocessor configurations, the *[Immediate Ceiling Priority Protocol \(ICPP\)](#page-56-2)* (page 29) is used instead.

## <span id="page-357-2"></span>13.2.5 Building a Semaphore Attribute Set

In general, an attribute set is built by a bitwise OR of the desired attribute components. The following table lists the set of valid semaphore attributes:

| RTEMS_FIFO                | tasks wait by FIFO (default)                                  |
|---------------------------|---------------------------------------------------------------|
| RTEMS_PRIORITY            | tasks wait by priority                                        |
| RTEMS_BINARY_SEMAPHORE    | restrict values to 0 and 1                                    |
| RTEMS_COUNTING_SEMAPHORE  | no restriction on values (default)                            |
| RTEMS_SIMPLE_BINARY_      | restrict values to 0 and 1, do not allow nested access, allow |
| SEMAPHORE                 | deletion of locked semaphore.                                 |
| RTEMS_NO_INHERIT_PRIORITY | do not use priority inheritance (default)                     |
| RTEMS_INHERIT_PRIORITY    | use priority inheritance                                      |
| RTEMS_NO_PRIORITY_CEILING | do not use priority ceiling (default)                         |
| RTEMS_PRIORITY_CEILING    | use priority ceiling                                          |
| RTEMS_NO_MULTIPROCESSOR_  | do not use Multiprocessor Resource Sharing Protocol (de       |
| RESOURCE_SHARING          | fault)                                                        |
| RTEMS_MULTIPROCESSOR_     | use Multiprocessor Resource Sharing Protocol                  |
| RESOURCE_SHARING          |                                                               |
| RTEMS_LOCAL               | local semaphore (default)                                     |
| RTEMS_GLOBAL              | global semaphore                                              |

Attribute values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each attribute appears exactly once in the component list. An attribute listed as a default is not required to appear in the attribute list, although it is a good programming practice to specify default attributes. If all defaults are desired, the attribute RTEMS\_DEFAULT\_ATTRIBUTES should be specified on this call.

This example demonstrates the attribute\_set parameter needed to create a local semaphore with the task priority waiting queue discipline. The attribute\_set parameter passed to the rtems\_semaphore\_create directive could be either RTEMS\_PRIORITY or RTEMS\_LOCAL | RTEMS\_PRIORITY. The attribute\_set parameter can be set to RTEMS\_PRIORITY because RTEMS\_LOCAL is the default for all created tasks. If a similar semaphore were to be known globally, then the attribute\_set parameter would be RTEMS\_GLOBAL | RTEMS\_PRIORITY.

Some combinatinos of these attributes are invalid. For example, priority ordered blocking discipline must be applied to a binary semaphore in order to use either the priority inheritance or priority ceiling functionality. The following tree figure illustrates the valid combinations.

# <span id="page-358-0"></span>13.2.6 Building a SEMAPHORE\_OBTAIN Option Set

In general, an option is built by a bitwise OR of the desired option components. The set of valid options for the rtems\_semaphore\_obtain directive are listed in the following table:

| RTEMS_WAIT    | task will wait for semaphore (default) |
|---------------|----------------------------------------|
| RTEMS_NO_WAIT | task should not wait                   |

Option values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each attribute appears exactly once in the component list. An option listed as a default is not required to appear in the list, although it is a good programming practice to specify default options. If all defaults are desired, the option RTEMS\_DEFAULT\_OPTIONS should be specified on this call.

This example demonstrates the option parameter needed to poll for a semaphore. The option parameter passed to the rtems\_semaphore\_obtain directive should be RTEMS\_NO\_WAIT.

13.2. Background 331

# <span id="page-359-0"></span>13.3 Operations

## <span id="page-359-1"></span>13.3.1 Creating a Semaphore

The rtems\_semaphore\_create directive creates a binary or counting semaphore with a userspecified name as well as an initial count. If a binary semaphore is created with a count of zero (0) to indicate that it has been allocated, then the task creating the semaphore is considered the current holder of the semaphore. At create time the method for ordering waiting tasks in the semaphore's task wait queue (by FIFO or task priority) is specified. Additionally, the priority inheritance or priority ceiling algorithm may be selected for local, binary semaphores that use the priority task wait queue blocking discipline. If the priority ceiling algorithm is selected, then the highest priority of any task which will attempt to obtain this semaphore must be specified. RTEMS allocates a Semaphore Control Block (SMCB) from the SMCB free list. This data structure is used by RTEMS to manage the newly created semaphore. Also, a unique semaphore ID is generated and returned to the calling task.

## <span id="page-359-2"></span>13.3.2 Obtaining Semaphore IDs

When a semaphore is created, RTEMS generates a unique semaphore ID and assigns it to the created semaphore until it is deleted. The semaphore ID may be obtained by either of two methods. First, as the result of an invocation of the rtems\_semaphore\_create directive, the semaphore ID is stored in a user provided location. Second, the semaphore ID may be obtained later using the rtems\_semaphore\_ident directive. The semaphore ID is used by other semaphore manager directives to access this semaphore.

## <span id="page-359-3"></span>13.3.3 Acquiring a Semaphore

The rtems\_semaphore\_obtain directive is used to acquire the specified semaphore. A simplified version of the rtems\_semaphore\_obtain directive can be described as follows:

If the semaphore's count is greater than zero then decrement the semaphore's count else wait for release of semaphore then return SUCCESSFUL.

When the semaphore cannot be immediately acquired, one of the following situations applies:

- By default, the calling task will wait forever to acquire the semaphore.
- Specifying RTEMS\_NO\_WAIT forces an immediate return with an error status code.
- Specifying a timeout limits the interval the task will wait before returning with an error status code.

If the task waits to acquire the semaphore, then it is placed in the semaphore's task wait queue in either FIFO or task priority order. If the task blocked waiting for a binary semaphore using priority inheritance and the task's priority is greater than that of the task currently holding the semaphore, then the holding task will inherit the priority of the blocking task. All tasks waiting on a semaphore are returned an error code when the semaphore is deleted.

When a task successfully obtains a semaphore using priority ceiling and the priority ceiling for this semaphore is greater than that of the holder, then the holder's priority will be elevated.

## <span id="page-360-0"></span>13.3.4 Releasing a Semaphore

The rtems\_semaphore\_release directive is used to release the specified semaphore. A simplified version of the rtems\_semaphore\_release directive can be described as follows:

If there are no tasks are waiting on this semaphore then increment the semaphore's count else assign semaphore to a waiting task and return SUCCESSFUL.

If this is the outermost release of a binary semaphore that uses priority inheritance or priority ceiling and the task does not currently hold any other binary semaphores, then the task performing the rtems\_semaphore\_release will have its priority restored to its normal value.

## <span id="page-360-1"></span>13.3.5 Deleting a Semaphore

The rtems\_semaphore\_delete directive removes a semaphore from the system and frees its control block. A semaphore can be deleted by any local task that knows the semaphore's ID. As a result of this directive, all tasks blocked waiting to acquire the semaphore will be readied and returned a status code which indicates that the semaphore was deleted. Any subsequent references to the semaphore's name and ID are invalid.

13.3. Operations 333

# <span id="page-361-0"></span>13.4 Directives

This section details the directives of the Semaphore Manager. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

## <span id="page-362-1"></span><span id="page-362-0"></span>13.4.1 rtems\_semaphore\_create()

Creates a semaphore.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_semaphore_create(
2 rtems_name name,
3 uint32_t count,
4 rtems_attribute attribute_set,
5 rtems_task_priority priority_ceiling,
6 rtems_id *id
7 );
```

## PARAMETERS:

#### **name**

This parameter is the object name of the semaphore.

#### **count**

This parameter is the initial count of the semaphore. If the semaphore is a binary semaphore, then a count of 0 will make the calling task the owner of the binary semaphore and a count of 1 will create a binary semaphore without an owner.

#### **attribute\_set**

This parameter is the attribute set of the semaphore.

#### **priority\_ceiling**

This parameter is the priority ceiling if the semaphore is a binary semaphore with the priority ceiling or MrsP locking protocol as defined by the attribute set.

#### **id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the identifier of the created semaphore will be stored in this object.

#### DESCRIPTION:

This directive creates a semaphore which resides on the local node. The semaphore has the userdefined object name specified in name and the initial count specified in count. The assigned object identifier is returned in id. This identifier is used to access the semaphore with other semaphore related directives.

The **attribute set** specified in attribute\_set is built through a *bitwise or* of the attribute constants described below. Not all combinations of attributes are allowed. Some attributes are mutually exclusive. If mutually exclusive attributes are combined, the behaviour is undefined. Attributes not mentioned below are not evaluated by this directive and have no effect. Default attributes can be selected by using the RTEMS\_DEFAULT\_ATTRIBUTES constant. The attribute set defines

- the scope of the semaphore: RTEMS\_LOCAL (default) or RTEMS\_GLOBAL,
- the task wait queue discipline used by the semaphore: RTEMS\_FIFO (default) or RTEMS\_PRIORITY,
- the class of the semaphore: RTEMS\_COUNTING\_SEMAPHORE (default), RTEMS\_BINARY\_SEMAPHORE, or RTEMS\_SIMPLE\_BINARY\_SEMAPHORE, and

13.4. Directives 335

â€¢ the locking protocol of a binary semaphore: no locking protocol (default), RTEMS\_INHERIT\_PRIORITY, RTEMS\_PRIORITY\_CEILING, or RTEMS\_MULTIPROCESSOR\_RESOURCE\_SHARING.

The semaphore has a local or global **scope** in a multiprocessing network (this attribute does not refer to SMP systems). The scope is selected by the mutually exclusive RTEMS\_LOCAL and RTEMS\_GLOBAL attributes.

- A **local scope** is the default and can be emphasized through the use of the RTEMS\_LOCAL attribute. A local semaphore can be only used by the node which created it.
- A **global scope** is established if the RTEMS\_GLOBAL attribute is set. Setting the global attribute in a single node system has no effect.

The **task wait queue discipline** is selected by the mutually exclusive RTEMS\_FIFO and RTEMS\_PRIORITY attributes.

- The **FIFO discipline** is the default and can be emphasized through use of the RTEMS\_FIFO attribute.
- The **priority discipline** is selected by the RTEMS\_PRIORITY attribute. The locking protocols require the priority discipline.

The **semaphore class** is selected by the mutually exclusive RTEMS\_COUNTING\_SEMAPHORE, RTEMS\_BINARY\_SEMAPHORE, and RTEMS\_SIMPLE\_BINARY\_SEMAPHORE attributes.

- The **counting semaphore class** is the default and can be emphasized through use of the RTEMS\_COUNTING\_SEMAPHORE attribute.
- The **binary semaphore class** is selected by the RTEMS\_BINARY\_SEMAPHORE attribute. Binary semaphores are mutual exclusion (mutex) synchronization primitives which may have an owner. The count of a binary semaphore is restricted to 0 and 1 values.
- The **simple binary semaphore class** is selected by the RTEMS\_SIMPLE\_BINARY\_SEMAPHORE attribute. Simple binary semaphores have no owner. They may be used for task and interrupt synchronization. The count of a simple binary semaphore is restricted to 0 and 1 values.

Binary semaphores may use a **locking protocol**. If a locking protocol is selected, then the scope shall be local and the priority task wait queue discipline shall be selected. The locking protocol is selected by the mutually exclusive RTEMS\_INHERIT\_PRIORITY, RTEMS\_PRIORITY\_CEILING, and RTEMS\_MULTIPROCESSOR\_RESOURCE\_SHARING attributes.

- The default is **no locking protocol**. This can be emphasized through use of the RTEMS\_NO\_INHERIT\_PRIORITY, RTEMS\_NO\_MULTIPROCESSOR\_RESOURCE\_SHARING, and RTEMS\_NO\_PRIORITY\_CEILING attributes.
- The **priority inheritance locking protocol** is selected by the RTEMS\_INHERIT\_PRIORITY attribute.
- The **priority ceiling locking protocol** is selected by the RTEMS\_PRIORITY\_CEILING attribute. For this locking protocol a priority ceiling shall be specified in priority\_ceiling.
- The **MrsP locking protocol** is selected by the RTEMS\_MULTIPROCESSOR\_RESOURCE\_SHARING attribute in SMP configurations, otherwise this attribute selects the **priority ceiling locking protocol**. For these locking protocols a priority ceiling shall be specified in priority\_ceiling. This priority is used to set the priority ceiling for all schedulers. This can be changed later with the *[rtems\\_semaphore\\_set\\_priority\(\)](#page-377-0)* (page 350) directive using the returned object identifier.

### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_NAME**

The name parameter was invalid.

#### **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_NUMBER**

The count parameter was invalid.

#### **RTEMS\_NOT\_DEFINED**

The attribute\_set parameter was invalid.

#### **RTEMS\_TOO\_MANY**

There was no inactive object available to create a semaphore. The number of semaphores available to the application is configured through the *[CONFIGURE\\_MAXIMUM\\_SEMAPHORES](#page-649-0)* (page 622) application configuration option.

## **RTEMS\_TOO\_MANY**

In multiprocessing configurations, there was no inactive global object available to create a global semaphore. The number of global objects available to the application is configured through the *[CONFIGURE\\_MP\\_MAXIMUM\\_GLOBAL\\_OBJECTS](#page-765-0)* (page 738) application configuration option.

#### **RTEMS\_INVALID\_PRIORITY**

The priority\_ceiling parameter was invalid.

#### NOTES:

For control and maintenance of the semaphore, RTEMS allocates a *[SMCB](#page-1074-0)* from the local SMCB free pool and initializes it.

The SMCB for a global semaphore is allocated on the local node. Semaphores should not be made global unless remote tasks must interact with the semaphore. This is to avoid the system overhead incurred by the creation of a global semaphore. When a global semaphore is created, the semaphore's name and identifier must be transmitted to every node in the system for insertion in the local copy of the global object table.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- When the directive operates on a global object, the directive sends a message to remote nodes. This may preempt the calling task.
- The number of semaphores available to the application is configured through the *[CON-](#page-649-0)[FIGURE\\_MAXIMUM\\_SEMAPHORES](#page-649-0)* (page 622) application configuration option.

13.4. Directives 337

- Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace.
- The number of global objects available to the application is configured through the *[CON-](#page-765-0)[FIGURE\\_MP\\_MAXIMUM\\_GLOBAL\\_OBJECTS](#page-765-0)* (page 738) application configuration option.

## <span id="page-366-1"></span><span id="page-366-0"></span>13.4.2 rtems\_semaphore\_ident()

Identifies a semaphore by the object name.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_semaphore_ident(
2 rtems_name name,
3 uint32_t node,
4 rtems_id *id
5 );
```

#### PARAMETERS:

#### **name**

This parameter is the object name to look up.

#### **node**

This parameter is the node or node set to search for a matching object.

**id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the object identifier of an object with the specified name will be stored in this object.

#### DESCRIPTION:

This directive obtains a semaphore identifier associated with the semaphore name specified in name.

The node to search is specified in node. It shall be

- a valid node number,
- the constant RTEMS\_SEARCH\_ALL\_NODES to search in all nodes,
- the constant RTEMS\_SEARCH\_LOCAL\_NODE to search in the local node only, or
- the constant RTEMS\_SEARCH\_OTHER\_NODES to search in all nodes except the local node.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_NAME**

The name parameter was 0.

#### **RTEMS\_INVALID\_NAME**

There was no object with the specified name on the specified nodes.

### **RTEMS\_INVALID\_NODE**

In multiprocessing configurations, the specified node was invalid.

13.4. Directives 339

#### NOTES:

If the semaphore name is not unique, then the semaphore identifier will match the first semaphore with that name in the search order. However, this semaphore identifier is not guaranteed to correspond to the desired semaphore.

The objects are searched from lowest to the highest index. If node is RTEMS\_SEARCH\_ALL\_NODES, all nodes are searched with the local node being searched first. All other nodes are searched from lowest to the highest node number.

If node is a valid node number which does not represent the local node, then only the semaphores exported by the designated node are searched.

This directive does not generate activity on remote nodes. It accesses only the local copy of the global object table.

The semaphore identifier is used with other semaphore related directives to access the semaphore.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-368-1"></span><span id="page-368-0"></span>13.4.3 rtems\_semaphore\_delete()

Deletes the semaphore.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_semaphore_delete( rtems_id id );
```

### PARAMETERS:

## **id**

This parameter is the semaphore identifier.

#### DESCRIPTION:

This directive deletes the semaphore specified by id.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no semaphore associated with the identifier specified by id.

## **RTEMS\_ILLEGAL\_ON\_REMOTE\_OBJECT**

The semaphore resided on a remote node.

## **RTEMS\_RESOURCE\_IN\_USE**

The binary semaphore had an owner.

## NOTES:

Binary semaphores with an owner cannot be deleted.

When a semaphore is deleted, all tasks blocked waiting to obtain the semaphore will be readied and returned a status code which indicates that the semaphore was deleted.

The *[SMCB](#page-1074-0)* for the deleted semaphore is reclaimed by RTEMS.

When a global semaphore is deleted, the semaphore identifier must be transmitted to every node in the system for deletion from the local copy of the global object table.

The semaphore must reside on the local node, even if the semaphore was created with the RTEMS\_GLOBAL attribute.

Proxies, used to represent remote tasks, are reclaimed when the semaphore is deleted.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

13.4. Directives 341

- When the directive operates on a global object, the directive sends a message to remote nodes. This may preempt the calling task.
- The calling task does not have to be the task that created the object. Any local task that knows the object identifier can delete the object.
- Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace.

## <span id="page-370-1"></span><span id="page-370-0"></span>13.4.4 rtems\_semaphore\_obtain()

Obtains the semaphore.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_semaphore_obtain(
2 rtems_id id,
3 rtems_option option_set,
4 rtems_interval timeout
5 );
```

#### PARAMETERS:

#### **id**

This parameter is the semaphore identifier.

#### **option\_set**

This parameter is the option set.

#### **timeout**

This parameter is the timeout in *[clock ticks](#page-1062-1)* if the RTEMS\_WAIT option is set. Use RTEMS\_NO\_TIMEOUT to wait potentially forever.

## DESCRIPTION:

This directive obtains the semaphore specified by id.

The **option set** specified in option\_set is built through a *bitwise or* of the option constants described below. Not all combinations of options are allowed. Some options are mutually exclusive. If mutually exclusive options are combined, the behaviour is undefined. Options not mentioned below are not evaluated by this directive and have no effect. Default options can be selected by using the RTEMS\_DEFAULT\_OPTIONS constant.

The calling task can **wait** or **try to obtain** the semaphore according to the mutually exclusive RTEMS\_WAIT and RTEMS\_NO\_WAIT options.

- **Waiting to obtain** the semaphore is the default and can be emphasized through the use of the RTEMS\_WAIT option. The timeout parameter defines how long the calling task is willing to wait. Use RTEMS\_NO\_TIMEOUT to wait potentially forever, otherwise set a timeout interval in clock ticks.
- **Trying to obtain** the semaphore is selected by the RTEMS\_NO\_WAIT option. If this option is defined, then the timeout parameter is ignored. When the semaphore cannot be immediately obtained, then the RTEMS\_UNSATISFIED status is returned.

With either RTEMS\_WAIT or RTEMS\_NO\_WAIT if the current semaphore count is positive, then it is decremented by one and the semaphore is successfully obtained by returning immediately with the RTEMS\_SUCCESSFUL status code.

If the calling task chooses to return immediately and the current semaphore count is zero, then the RTEMS\_UNSATISFIED status code is returned indicating that the semaphore is not available.

If the calling task chooses to wait for a semaphore and the current semaphore count is zero, then the calling task is placed on the semaphore's wait queue and blocked. If a local, binary semaphore was created with the RTEMS\_INHERIT\_PRIORITY attribute, then the priority of the task currently holding the binary semaphore will inherit the current priority set of the blocking

13.4. Directives 343

task. The priority inheritance is carried out recursively. This means, that if the task currently holding the binary semaphore is blocked on another local, binary semaphore using the priority inheritance locking protocol, then the owner of this semaphore will inherit the current priority sets of both tasks, and so on. A task has a current priority for each scheduler.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no semaphore associated with the identifier specified by id.

#### **RTEMS\_NOT\_DEFINED**

The semaphore uses a priority ceiling and there was no priority ceiling defined for the *[home](#page-1066-0) [scheduler](#page-1066-0)* of the calling task.

#### **RTEMS\_UNSATISFIED**

The semaphore could not be obtained immediately.

#### **RTEMS\_INVALID\_PRIORITY**

The semaphore uses a priority ceiling and the calling task had a current priority less than the priority ceiling.

#### **RTEMS\_INCORRECT\_STATE**

Acquiring of the local, binary semaphore by the calling task would have cased a deadlock.

#### **RTEMS\_INCORRECT\_STATE**

The calling task attempted to recursively obtain a local, binary semaphore using the MrsP locking protocol.

#### **RTEMS\_UNSATISFIED**

The semaphore was flushed while the calling task was waiting to obtain the semaphore.

#### **RTEMS\_TIMEOUT**

The timeout happened while the calling task was waiting to obtain the semaphore.

## **RTEMS\_OBJECT\_WAS\_DELETED**

The semaphore was deleted while the calling task was waiting to obtain the semaphore.

## NOTES:

If a local, binary semaphore was created with the RTEMS\_PRIORITY\_CEILING or RTEMS\_MULTIPROCESSOR\_RESOURCE\_SHARING attribute, a task successfully obtains the semaphore, and the priority of that task is greater than the ceiling priority for this semaphore, then the priority of the task acquiring the semaphore is elevated to that of the ceiling.

Deadlock situations are detected for local, binary semaphores. If a deadlock is detected, then the directive immediately returns the RTEMS\_INCORRECT\_STATE status code.

It is not allowed to recursively obtain (nested access) a local, binary semaphore using the MrsP locking protocol and any attempt to do this will just return the RTEMS\_INCORRECT\_STATE status code. This error can only happen in SMP configurations.

If the semaphore was created with the RTEMS\_PRIORITY attribute, then the calling task is inserted into the wait queue according to its priority. However, if the semaphore was created with the RTEMS\_FIFO attribute, then the calling task is placed at the rear of the wait queue.

Attempting to obtain a global semaphore which does not reside on the local node will generate a request to the remote node to access the semaphore. If the semaphore is not available and RTEMS\_NO\_WAIT was not specified, then the task must be blocked until the semaphore is released. A proxy is allocated on the remote node to represent the task until the semaphore is released.

## CONSTRAINTS:

The following constraints apply to this directive:

- When a local, counting semaphore or a local, simple binary semaphore is accessed and the RTEMS\_NO\_WAIT option is set, the directive may be called from within interrupt context.
- When a local semaphore is accessed and the request can be immediately satisfied, the directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- When the request cannot be immediately satisfied and the RTEMS\_WAIT option is set, the calling task blocks at some point during the directive call.
- The timeout functionality of the directive requires a *[clock tick](#page-1062-1)*.
- When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply. This will preempt the calling task.

13.4. Directives 345

## <span id="page-373-1"></span><span id="page-373-0"></span>13.4.5 rtems\_semaphore\_release()

Releases the semaphore.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_semaphore_release( rtems_id id );
```

### PARAMETERS:

## **id**

This parameter is the semaphore identifier.

#### DESCRIPTION:

This directive releases the semaphore specified by id. If the semaphore's wait queue is not empty, then

- the first task on the wait queue is removed and unblocked, the semaphore's count is not changed, otherwise
- the semaphore's count is incremented by one for counting semaphores and set to one for binary and simple binary semaphores.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no semaphore associated with the identifier specified by id.

#### **RTEMS\_NOT\_OWNER\_OF\_RESOURCE**

The calling task was not the owner of the semaphore.

## **RTEMS\_UNSATISFIED**

The semaphore's count already had the maximum value of [UINT32\\_MAX.](https://en.cppreference.com/w/c/types/integer)

## NOTES:

The calling task may be preempted if it causes a higher priority task to be made ready for execution.

The outermost release of a local, binary semaphore using the priority inheritance, priority ceiling, or MrsP locking protocol may result in the calling task having its priority lowered. This will occur if the highest priority of the calling task was available due to the ownership of the released semaphore. If a task was on the semaphore's wait queue, then the priority associated with the semaphore will be transferred to the new owner.

Releasing a global semaphore which does not reside on the local node will generate a request telling the remote node to release the semaphore.

If the task to be unblocked resides on a different node from the semaphore, then the semaphore allocation is forwarded to the appropriate node, the waiting task is unblocked, and the proxy used to represent the task is reclaimed.

### CONSTRAINTS:

The following constraints apply to this directive:

- When a local, counting semaphore or a local, simple binary semaphore is accessed, the directive may be called from within interrupt context.
- When a local semaphore is accessed, the directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may unblock a task. This may cause the calling task to be preempted.
- When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply. This will preempt the calling task.

13.4. Directives 347

## <span id="page-375-1"></span><span id="page-375-0"></span>13.4.6 rtems\_semaphore\_flush()

Flushes the semaphore.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_semaphore_flush( rtems_id id );
```

#### PARAMETERS:

#### **id**

This parameter is the semaphore identifier.

#### DESCRIPTION:

This directive unblocks all tasks waiting on the semaphore specified by id. The semaphore's count is not changed by this directive. Tasks which are unblocked as the result of this directive will return from the *[rtems\\_semaphore\\_obtain\(\)](#page-370-0)* (page 343) directive with a status code of RTEMS\_UNSATISFIED to indicate that the semaphore was not obtained.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ID**

There was no semaphore associated with the identifier specified by id.

#### **RTEMS\_ILLEGAL\_ON\_REMOTE\_OBJECT**

The semaphore resided on a remote node.

#### **RTEMS\_NOT\_DEFINED**

Flushing a semaphore using the MrsP locking protocol is undefined behaviour.

#### NOTES:

If the task to be unblocked resides on a different node from the semaphore, then the waiting task is unblocked, and the proxy used to represent the task is reclaimed.

It is not allowed to flush a local, binary semaphore using the MrsP locking protocol and any attempt to do this will just return the RTEMS\_NOT\_DEFINED status code. This error can only happen in SMP configurations.

For barrier synchronization, the *[Barrier Manager](#page-382-0)* (page 355) offers a cleaner alternative to using the semaphore flush directive. Unlike POSIX barriers, they have a manual release option.

Using the semaphore flush directive for condition synchronization in concert with another semaphore may be subject to the lost wake-up problem. The following attempt to implement a condition variable is broken.

```
1 #include <rtems.h>
2 #include <assert.h>
3
4 void cnd_wait( rtems_id cnd, rtems_id mtx )
5 {
```

(continues on next page)

(continued from previous page)

```
6 rtems_status_code sc;
7
8 sc = rtems_semaphore_release( mtx );
9 assert( sc == RTEMS_SUCCESSFUL );
10
11 // Here, a higher priority task may run and satisfy the condition.
12 // We may never wake up from the next semaphore obtain.
13
14 sc = rtems_semaphore_obtain( cnd, RTEMS_WAIT, RTEMS_NO_TIMEOUT );
15 assert( sc == RTEMS_UNSATISFIED );
16
17 sc = rtems_semaphore_obtain( mtx, RTEMS_WAIT, RTEMS_NO_TIMEOUT );
18 assert( sc == RTEMS_SUCCESSFUL );
19 }
20
21 void cnd_broadcast( rtems_id cnd )
22 {
23 rtems_status_code sc;
24
25 sc = rtems_semaphore_flush( cnd );
26 assert( sc == RTEMS_SUCCESSFUL );
27 }
```

#### CONSTRAINTS:

The following constraints apply to this directive:

- When a local, counting semaphore or a local, simple binary semaphore is accessed, the directive may be called from within interrupt context.
- When a local semaphore is accessed, the directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may unblock a task. This may cause the calling task to be preempted.
- When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply. This will preempt the calling task.

13.4. Directives 349

## <span id="page-377-1"></span><span id="page-377-0"></span>13.4.7 rtems\_semaphore\_set\_priority()

Sets the priority by scheduler for the semaphore.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_semaphore_set_priority(
2 rtems_id semaphore_id,
3 rtems_id scheduler_id,
4 rtems_task_priority new_priority,
5 rtems_task_priority *old_priority
6 );
```

## PARAMETERS:

#### **semaphore\_id**

This parameter is the semaphore identifier.

#### **scheduler\_id**

This parameter is the identifier of the scheduler corresponding to the new priority.

#### **new\_priority**

This parameter is the new priority corresponding to the specified scheduler.

#### **old\_priority**

This parameter is the pointer to an *[rtems\\_task\\_priority](#page-84-0)* (page 57) object. When the directive call is successful, the old priority of the semaphore corresponding to the specified scheduler will be stored in this object.

### DESCRIPTION:

This directive sets the priority of the semaphore specified by semaphore\_id. The priority corresponds to the scheduler specified by scheduler\_id.

The special priority value RTEMS\_CURRENT\_PRIORITY can be used to get the current priority without changing it.

The availability and use of a priority depends on the class and locking protocol of the semaphore:

- For local, binary semaphores using the MrsP locking protocol, the ceiling priority for each scheduler can be set by this directive.
- For local, binary semaphores using the priority ceiling protocol, the ceiling priority can be set by this directive.
- For other semaphore classes and locking protocols, setting a priority is undefined behaviour.

#### RETURN VALUES:

# **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ADDRESS**

The old\_priority parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no scheduler associated with the identifier specified by scheduler\_id.

#### **RTEMS\_INVALID\_ID**

There was no semaphore associated with the identifier specified by semaphore\_id.

## **RTEMS\_ILLEGAL\_ON\_REMOTE\_OBJECT**

The semaphore resided on a remote node.

## **RTEMS\_INVALID\_PRIORITY**

The new\_priority parameter was invalid.

### **RTEMS\_NOT\_DEFINED**

Setting a priority for the class or locking protocol of the semaphore is undefined behaviour.

#### NOTES:

Please have a look at the following example:

```
1 #include <assert.h>
2 #include <rtems.h>
3
4 #define SCHED_A rtems_build_name( ' ', ' ', ' ', 'A' )
5 #define SCHED_B rtems_build_name( ' ', ' ', ' ', 'B' )
6
7 static void Init( rtems_task_argument arg )
8 {
9 rtems_status_code sc;
10 rtems_id semaphore_id;
11 rtems_id scheduler_a_id;
12 rtems_id scheduler_b_id;
13 rtems_task_priority prio;
14
15 (void) arg;
16
17 // Get the scheduler identifiers
18 sc = rtems_scheduler_ident( SCHED_A, &scheduler_a_id );
19 assert( sc == RTEMS_SUCCESSFUL );
20 sc = rtems_scheduler_ident( SCHED_B, &scheduler_b_id );
21 assert( sc == RTEMS_SUCCESSFUL );
22
23 // Create a local, binary semaphore using the MrsP locking protocol
24 sc = rtems_semaphore_create(
25 rtems_build_name( 'M', 'R', 'S', 'P' ),
26 1,
27 RTEMS_BINARY_SEMAPHORE | RTEMS_PRIORITY |
28 RTEMS_MULTIPROCESSOR_RESOURCE_SHARING,
29 1,
30 &semaphore_id
31 );
32 assert( sc == RTEMS_SUCCESSFUL );
33
34 // The ceiling priority for each scheduler is equal to the priority
```

(continues on next page)

13.4. Directives 351

(continued from previous page)

```
35 // specified for the semaphore creation.
36 prio = RTEMS_CURRENT_PRIORITY;
37 sc = rtems_semaphore_set_priority( semaphore_id, scheduler_a_id, prio, &prio );
38 assert( sc == RTEMS_SUCCESSFUL );
39 assert( prio == 1 );
40
41 // Check the old value and set a new ceiling priority for scheduler B
42 prio = 2;
43 sc = rtems_semaphore_set_priority( semaphore_id, scheduler_b_id, prio, &prio );
44 assert( sc == RTEMS_SUCCESSFUL );
45 assert( prio == 1 );
46
47 // Check the ceiling priority values
48 prio = RTEMS_CURRENT_PRIORITY;
49 sc = rtems_semaphore_set_priority( semaphore_id, scheduler_a_id, prio, &prio );
50 assert( sc == RTEMS_SUCCESSFUL );
51 assert( prio == 1 );
52 prio = RTEMS_CURRENT_PRIORITY;
53 sc = rtems_semaphore_set_priority( semaphore_id, scheduler_b_id, prio, &prio );
54 assert( sc == RTEMS_SUCCESSFUL );
55 assert( prio == 2 );
56
57 sc = rtems_semaphore_delete( semaphore_id );
58 assert( sc == RTEMS_SUCCESSFUL );
59
60 rtems_shutdown_executive( 0 );
61 }
62
63 #define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
64 #define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
65 #define CONFIGURE_MAXIMUM_TASKS 1
66 #define CONFIGURE_MAXIMUM_SEMAPHORES 1
67 #define CONFIGURE_MAXIMUM_PROCESSORS 2
68
69 #define CONFIGURE_SCHEDULER_SIMPLE_SMP
70
71 #include <rtems/scheduler.h>
72
73 RTEMS_SCHEDULER_CONTEXT_SIMPLE_SMP( a );
74 RTEMS_SCHEDULER_CONTEXT_SIMPLE_SMP( b );
75
76 #define CONFIGURE_SCHEDULER_TABLE_ENTRIES \
77 RTEMS_SCHEDULER_TABLE_SIMPLE_SMP( a, SCHED_A ), \
78 RTEMS_SCHEDULER_TABLE_SIMPLE_SMP( b, SCHED_B )
79
80 #define CONFIGURE_SCHEDULER_ASSIGNMENTS \
81 RTEMS_SCHEDULER_ASSIGN( 0, RTEMS_SCHEDULER_ASSIGN_PROCESSOR_MANDATORY ), \
82 RTEMS_SCHEDULER_ASSIGN( 1, RTEMS_SCHEDULER_ASSIGN_PROCESSOR_MANDATORY )
83
```

(continues on next page)

(continued from previous page)

```
84 #define CONFIGURE_RTEMS_INIT_TASKS_TABLE
85 #define CONFIGURE_INIT
86
87 #include <rtems/confdefs.h>
```

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may change the priority of a task. This may cause the calling task to be preempted.

13.4. Directives 353

CHAPTER

# **FOURTEEN**

# <span id="page-382-0"></span>BARRIER MANAGER

# <span id="page-383-0"></span>14.1 Introduction

The Barrier Manager provides a unique synchronization capability which can be used to have a set of tasks block and be unblocked as a set. The directives provided by the Barrier Manager are:

- *[rtems\\_barrier\\_create\(\)](#page-386-0)* (page 359) Creates a barrier.
- *[rtems\\_barrier\\_ident\(\)](#page-388-0)* (page 361) Identifies a barrier by the object name.
- *[rtems\\_barrier\\_delete\(\)](#page-389-0)* (page 362) Deletes the barrier.
- *[rtems\\_barrier\\_wait\(\)](#page-390-0)* (page 363) Waits at the barrier.
- *[rtems\\_barrier\\_release\(\)](#page-391-0)* (page 364) Releases the barrier.
- *[rtems\\_barrier\\_get\\_number\\_waiting\(\)](#page-392-0)* (page 365) Gets the number of tasks waiting at the barrier.

# <span id="page-384-0"></span>14.2 Background

A barrier can be viewed as a gate at which tasks wait until the gate is opened. This has many analogies in the real world. Horses and other farm animals may approach a closed gate and gather in front of it, waiting for someone to open the gate so they may proceed. Similarly, ticket holders gather at the gates of arenas before concerts or sporting events waiting for the arena personnel to open the gates so they may enter.

Barriers are useful during application initialization. Each application task can perform its local initialization before waiting for the application as a whole to be initialized. Once all tasks have completed their independent initializations, the "application ready" barrier can be released.

## <span id="page-384-1"></span>14.2.1 Automatic Versus Manual Barriers

Just as with a real-world gate, barriers may be configured to be manually opened or automatically opened. All tasks calling the rtems\_barrier\_wait directive will block until a controlling task invokes the rtems\_barrier\_release directive.

Automatic barriers are created with a limit to the number of tasks which may simultaneously block at the barrier. Once this limit is reached, all of the tasks are released. For example, if the automatic limit is ten tasks, then the first nine tasks calling the rtems\_barrier\_wait directive will block. When the tenth task calls the rtems\_barrier\_wait directive, the nine blocked tasks will be released and the tenth task returns to the caller without blocking.

## <span id="page-384-2"></span>14.2.2 Building a Barrier Attribute Set

In general, an attribute set is built by a bitwise OR of the desired attribute components. The following table lists the set of valid barrier attributes:

## **RTEMS\_BARRIER\_AUTOMATIC\_RELEASE**

automatically release the barrier when the configured number of tasks are blocked

## **RTEMS\_BARRIER\_MANUAL\_RELEASE**

only release the barrier when the application invokes the rtems\_barrier\_release directive. (default)

![](_page_384_Figure_14.jpeg)

## Ã² **Note**

Barriers only support FIFO blocking order because all waiting tasks are released as a set. Thus the released tasks will all become ready to execute at the same time and compete for the processor based upon their priority.

Attribute values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each attribute appears exactly once in the component list. An attribute listed as a default is not required to appear in the attribute list, although it is a good programming practice to specify default attributes. If all defaults are desired, the attribute RTEMS\_DEFAULT\_ATTRIBUTES should be specified on this call.

This example demonstrates the attribute\_set parameter needed to create a barrier with the automatic release policy. The attribute\_set parameter passed to the rtems\_barrier\_create directive will be RTEMS\_BARRIER\_AUTOMATIC\_RELEASE. In this case, the user must also specify the maximum\_waiters parameter.

14.2. Background 357

# <span id="page-385-0"></span>14.3 Directives

This section details the directives of the Barrier Manager. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

## <span id="page-386-1"></span><span id="page-386-0"></span>14.3.1 rtems\_barrier\_create()

Creates a barrier.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_barrier_create(
2 rtems_name name,
3 rtems_attribute attribute_set,
4 uint32_t maximum_waiters,
5 rtems_id *id
6 );
```

#### PARAMETERS:

#### **name**

This parameter is the object name of the barrier.

#### **attribute\_set**

This parameter is the attribute set of the barrier.

#### **maximum\_waiters**

This parameter is the maximum count of waiters on an automatic release barrier.

**id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the identifier of the created barrier will be stored in this object.

#### DESCRIPTION:

This directive creates a barrier which resides on the local node. The barrier has the user-defined object name specified in name and the initial count specified in attribute\_set. The assigned object identifier is returned in id. This identifier is used to access the barrier with other barrier related directives.

The **attribute set** specified in attribute\_set is built through a *bitwise or* of the attribute constants described below. Not all combinations of attributes are allowed. Some attributes are mutually exclusive. If mutually exclusive attributes are combined, the behaviour is undefined. Attributes not mentioned below are not evaluated by this directive and have no effect. Default attributes can be selected by using the RTEMS\_DEFAULT\_ATTRIBUTES constant.

The **barrier class** is selected by the mutually exclusive RTEMS\_BARRIER\_MANUAL\_RELEASE and RTEMS\_BARRIER\_AUTOMATIC\_RELEASE attributes.

- The **manual release class** is the default and can be emphasized through use of the RTEMS\_BARRIER\_MANUAL\_RELEASE attribute. For this class, there is no limit on the number of tasks that will block at the barrier. Only when the *[rtems\\_barrier\\_release\(\)](#page-391-0)* (page 364) directive is invoked, are the tasks waiting at the barrier unblocked.
- The **automatic release class** is selected by the RTEMS\_BARRIER\_AUTOMATIC\_RELEASE attribute. For this class, tasks calling the *[rtems\\_barrier\\_wait\(\)](#page-390-0)* (page 363) directive will block until there are maximum\_waiters minus one tasks waiting at the barrier. When the maximum\_waiters task invokes the *[rtems\\_barrier\\_wait\(\)](#page-390-0)* (page 363) directive, the previous maximum\_waiters - 1 tasks are automatically released and the caller returns.

14.3. Directives 359

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_NAME**

The name parameter was invalid.

## **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_NUMBER**

The maximum\_waiters parameter was 0 for an automatic release barrier.

#### **RTEMS\_TOO\_MANY**

There was no inactive object available to create a barrier. The number of barriers available to the application is configured through the *[CONFIGURE\\_MAXIMUM\\_BARRIERS](#page-643-0)* (page 616) application configuration option.

#### NOTES:

For control and maintenance of the barrier, RTEMS allocates a *[BCB](#page-1061-1)* from the local BCB free pool and initializes it.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- The number of barriers available to the application is configured through the *[CONFIG-](#page-643-0)[URE\\_MAXIMUM\\_BARRIERS](#page-643-0)* (page 616) application configuration option.
- Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace.

## <span id="page-388-1"></span><span id="page-388-0"></span>14.3.2 rtems\_barrier\_ident()

Identifies a barrier by the object name.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_barrier_ident( rtems_name name, rtems_id *id );
```

#### PARAMETERS:

#### **name**

This parameter is the object name to look up.

#### **id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the object identifier of an object with the specified name will be stored in this object.

#### DESCRIPTION:

This directive obtains a barrier identifier associated with the barrier name specified in name.

#### RETURN VALUES:

### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_NAME**

The name parameter was 0.

#### **RTEMS\_INVALID\_NAME**

There was no object with the specified name on the local node.

#### NOTES:

If the barrier name is not unique, then the barrier identifier will match the first barrier with that name in the search order. However, this barrier identifier is not guaranteed to correspond to the desired barrier.

The objects are searched from lowest to the highest index. Only the local node is searched.

The barrier identifier is used with other barrier related directives to access the barrier.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

14.3. Directives 361

## <span id="page-389-1"></span><span id="page-389-0"></span>14.3.3 rtems\_barrier\_delete()

Deletes the barrier.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_barrier_delete( rtems_id id );
```

### PARAMETERS:

## **id**

This parameter is the barrier identifier.

#### DESCRIPTION:

This directive deletes the barrier specified by id. All tasks blocked waiting for the barrier to be released will be readied and returned a status code which indicates that the barrier was deleted.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no barrier associated with the identifier specified by id.

#### NOTES:

The *[BCB](#page-1061-1)* for the deleted barrier is reclaimed by RTEMS.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- The calling task does not have to be the task that created the object. Any local task that knows the object identifier can delete the object.
- Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace.

## <span id="page-390-1"></span><span id="page-390-0"></span>14.3.4 rtems\_barrier\_wait()

Waits at the barrier.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_barrier_wait( rtems_id id, rtems_interval timeout );
```

### PARAMETERS:

## **id**

This parameter is the barrier identifier.

#### **timeout**

This parameter is the timeout in clock ticks. Use RTEMS\_NO\_TIMEOUT to wait potentially forever.

#### DESCRIPTION:

This directive waits at the barrier specified by id. The timeout parameter defines how long the calling task is willing to wait. Use RTEMS\_NO\_TIMEOUT to wait potentially forever, otherwise set a timeout interval in clock ticks.

Conceptually, the calling task should always be thought of as blocking when it makes this call and being unblocked when the barrier is released. If the barrier is configured for manual release, this rule of thumb will always be valid. If the barrier is configured for automatic release, all callers will block except for the one which trips the automatic release condition.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no barrier associated with the identifier specified by id.

## **RTEMS\_TIMEOUT**

The timeout happened while the calling task was waiting at the barrier.

#### **RTEMS\_OBJECT\_WAS\_DELETED**

The barrier was deleted while the calling task was waiting at the barrier.

#### NOTES:

For automatic release barriers, the maximum count of waiting tasks is defined during barrier creation, see *[rtems\\_barrier\\_create\(\)](#page-386-0)* (page 359).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The timeout functionality of the directive requires a *[clock tick](#page-1062-1)*.

14.3. Directives 363

## <span id="page-391-1"></span><span id="page-391-0"></span>14.3.5 rtems\_barrier\_release()

Releases the barrier.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_barrier_release( rtems_id id, uint32_t *released );
```

### PARAMETERS:

## **id**

This parameter is the barrier identifier.

#### **released**

This parameter is the pointer to an [uint32\\_t](https://en.cppreference.com/w/c/types/integer) object. When the directive call is successful, the number of released tasks will be stored in this object.

#### DESCRIPTION:

This directive releases the barrier specified by id. All tasks waiting at the barrier will be unblocked. The number of released tasks will be returned in released.

#### RETURN VALUES:

### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The released parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no barrier associated with the identifier specified by id.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within task context.
- The directive may unblock a task. This may cause the calling task to be preempted.

## <span id="page-392-1"></span><span id="page-392-0"></span>14.3.6 rtems\_barrier\_get\_number\_waiting()

Gets the number of tasks waiting at the barrier.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_barrier_get_number_waiting(
2 rtems_id id,
3 uint32_t *waiting
4 );
```

#### PARAMETERS:

#### **id**

This parameter is the barrier identifier.

#### **waiting**

This parameter is the pointer to an [uint32\\_t](https://en.cppreference.com/w/c/types/integer) object. When the directive call is successful, the number of waiting tasks will be stored in this object.

#### DESCRIPTION:

This directive gets the number of tasks waiting at the barrier specified by id. The number of waiting tasks will be returned in waiting.

## RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The waiting parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no barrier associated with the identifier specified by id.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within task context.

14.3. Directives 365

CHAPTER

**FIFTEEN**

# <span id="page-394-0"></span>MESSAGE MANAGER

# <span id="page-395-0"></span>15.1 Introduction

The Message Manager provides communication and synchronization capabilities using RTEMS message queues. The directives provided by the Message Manager are:

- *[rtems\\_message\\_queue\\_create\(\)](#page-401-0)* (page 374) Creates a message queue.
- *[rtems\\_message\\_queue\\_construct\(\)](#page-404-0)* (page 377) Constructs a message queue from the specified the message queue configuration.
- *[rtems\\_message\\_queue\\_ident\(\)](#page-406-0)* (page 379) Identifies a message queue by the object name.
- *[rtems\\_message\\_queue\\_delete\(\)](#page-408-0)* (page 381) Deletes the message queue.
- *[rtems\\_message\\_queue\\_send\(\)](#page-410-0)* (page 383) Puts the message at the rear of the queue.
- *[rtems\\_message\\_queue\\_urgent\(\)](#page-412-0)* (page 385) Puts the message at the front of the queue.
- *[rtems\\_message\\_queue\\_broadcast\(\)](#page-414-0)* (page 387) Broadcasts the messages to the tasks waiting at the queue.
- *[rtems\\_message\\_queue\\_receive\(\)](#page-416-0)* (page 389) Receives a message from the queue.
- *[rtems\\_message\\_queue\\_get\\_number\\_pending\(\)](#page-418-0)* (page 391) Gets the number of messages pending on the queue.
- *[rtems\\_message\\_queue\\_flush\(\)](#page-419-0)* (page 392) Flushes all messages on the queue.
- *[RTEMS\\_MESSAGE\\_QUEUE\\_BUFFER\(\)](#page-420-0)* (page 393) Defines a structure which can be used as a message queue buffer for messages of the specified maximum size.

# <span id="page-396-5"></span><span id="page-396-0"></span>15.2 Background

## <span id="page-396-1"></span>15.2.1 Messages

A message is a variable length buffer where information can be stored to support communication. The length of the message and the information stored in that message are user-defined and can be actual data, pointer(s), or empty.

## <span id="page-396-2"></span>15.2.2 Message Queues

A message queue permits the passing of messages among tasks and ISRs. Message queues can contain a variable number of messages. Normally messages are sent to and received from the queue in FIFO order using the rtems\_message\_queue\_send directive. However, the rtems\_message\_queue\_urgent directive can be used to place messages at the head of a queue in LIFO order.

Synchronization can be accomplished when a task can wait for a message to arrive at a queue. Also, a task may poll a queue for the arrival of a message.

The maximum length message which can be sent is set on a per message queue basis. The message content must be copied in general to/from an internal buffer of the message queue or directly to a peer in certain cases. This copy operation is performed with interrupts disabled. So it is advisable to keep the messages as short as possible.

## <span id="page-396-3"></span>15.2.3 Building a Message Queue Attribute Set

In general, an attribute set is built by a bitwise OR of the desired attribute components. The set of valid message queue attributes is provided in the following table:

| RTEMS_FIFO     | tasks wait by FIFO (default)  |
|----------------|-------------------------------|
| RTEMS_PRIORITY | tasks wait by priority        |
| RTEMS_LOCAL    | local message queue (default) |
| RTEMS_GLOBAL   | global message queue          |

An attribute listed as a default is not required to appear in the attribute list, although it is a good programming practice to specify default attributes. If all defaults are desired, the attribute RTEMS\_DEFAULT\_ATTRIBUTES should be specified on this call.

This example demonstrates the attribute\_set parameter needed to create a local message queue with the task priority waiting queue discipline. The attribute\_set parameter to the rtems\_message\_queue\_create directive could be either RTEMS\_PRIORITY or RTEMS\_LOCAL | RTEMS\_PRIORITY. The attribute\_set parameter can be set to RTEMS\_PRIORITY because RTEMS\_LOCAL is the default for all created message queues. If a similar message queue were to be known globally, then the attribute\_set parameter would be RTEMS\_GLOBAL | RTEMS\_PRIORITY.

# <span id="page-396-4"></span>15.2.4 Building a MESSAGE\_QUEUE\_RECEIVE Option Set

In general, an option is built by a bitwise OR of the desired option components. The set of valid options for the rtems\_message\_queue\_receive directive are listed in the following table:

| RTEMS_WAIT    | task will wait for a message (default) |
|---------------|----------------------------------------|
| RTEMS_NO_WAIT | task should not wait                   |

15.2. Background 369

An option listed as a default is not required to appear in the option OR list, although it is a good programming practice to specify default options. If all defaults are desired, the option RTEMS\_DEFAULT\_OPTIONS should be specified on this call.

This example demonstrates the option parameter needed to poll for a message to arrive. The option parameter passed to the rtems\_message\_queue\_receive directive should be RTEMS\_NO\_WAIT.

# <span id="page-398-0"></span>15.3 Operations

## <span id="page-398-1"></span>15.3.1 Creating a Message Queue

The rtems\_message\_queue\_create directive creates a message queue with the user-defined name. The user specifies the maximum message size and maximum number of messages which can be placed in the message queue at one time. The user may select FIFO or task priority as the method for placing waiting tasks in the task wait queue. RTEMS allocates a Queue Control Block (QCB) from the QCB free list to maintain the newly created queue as well as memory for the message buffer pool associated with this message queue. RTEMS also generates a message queue ID which is returned to the calling task.

For GLOBAL message queues, the maximum message size is effectively limited to the longest message which the MPCI is capable of transmitting.

## <span id="page-398-2"></span>15.3.2 Obtaining Message Queue IDs

When a message queue is created, RTEMS generates a unique message queue ID. The message queue ID may be obtained by either of two methods. First, as the result of an invocation of the rtems\_message\_queue\_create directive, the queue ID is stored in a user provided location. Second, the queue ID may be obtained later using the rtems\_message\_queue\_ident directive. The queue ID is used by other message manager directives to access this message queue.

## <span id="page-398-3"></span>15.3.3 Receiving a Message

The rtems\_message\_queue\_receive directive attempts to retrieve a message from the specified message queue. If at least one message is in the queue, then the message is removed from the queue, copied to the caller's message buffer, and returned immediately along with the length of the message. When messages are unavailable, one of the following situations applies:

- By default, the calling task will wait forever for the message to arrive.
- Specifying the RTEMS\_NO\_WAIT option forces an immediate return with an error status code.
- Specifying a timeout limits the period the task will wait before returning with an error status.

If the task waits for a message, then it is placed in the message queue's task wait queue in either FIFO or task priority order. All tasks waiting on a message queue are returned an error code when the message queue is deleted.

## <span id="page-398-4"></span>15.3.4 Sending a Message

Messages can be sent to a queue with the rtems\_message\_queue\_send and rtems\_message\_queue\_urgent directives. These directives work identically when tasks are waiting to receive a message. A task is removed from the task waiting queue, unblocked, and the message is copied to a waiting task's message buffer.

When no tasks are waiting at the queue, rtems\_message\_queue\_send places the message at the rear of the message queue, while rtems\_message\_queue\_urgent places the message at the front of the queue. The message is copied to a message buffer from this message queue's buffer pool and then placed in the message queue. Neither directive can successfully send a message to a message queue which has a full queue of pending messages.

15.3. Operations 371

## <span id="page-399-0"></span>15.3.5 Broadcasting a Message

The rtems\_message\_queue\_broadcast directive sends the same message to each task waiting on the specified message queue until no more tasks remain. The message is copied to each waiting task's message buffer and each task is unblocked. The number of tasks which were unblocked is returned to the caller.

## <span id="page-399-1"></span>15.3.6 Deleting a Message Queue

The rtems\_message\_queue\_delete directive removes a message queue from the system and frees its control block as well as the memory associated with this message queue's message buffer pool. A message queue can be deleted by any local task that knows the message queue's ID. As a result of this directive, all tasks blocked waiting to receive a message from the message queue will be readied and returned a status code which indicates that the message queue was deleted. Any subsequent references to the message queue's name and ID are invalid. Any messages waiting at the message queue are also deleted and deallocated.

# <span id="page-400-0"></span>15.4 Directives

This section details the directives of the Message Manager. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

15.4. Directives 373

## <span id="page-401-1"></span><span id="page-401-0"></span>15.4.1 rtems\_message\_queue\_create()

Creates a message queue.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_message_queue_create(
2 rtems_name name,
3 uint32_t count,
4 size_t max_message_size,
5 rtems_attribute attribute_set,
6 rtems_id *id
7 );
```

#### PARAMETERS:

#### **name**

This parameter is the object name of the message queue.

#### **count**

This parameter is the maximum count of pending messages supported by the message queue.

#### **max\_message\_size**

This parameter is the maximum size in bytes of a message supported by the message queue.

#### **attribute\_set**

This parameter is the attribute set of the message queue.

## **id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the identifier of the created message queue will be stored in this object.

## DESCRIPTION:

This directive creates a message queue which resides on the local node. The message queue has the user-defined object name specified in name. Memory is allocated from the RTEMS Workspace for the count of messages specified in count, each of max\_message\_size bytes in length. The assigned object identifier is returned in id. This identifier is used to access the message queue with other message queue related directives.

The **attribute set** specified in attribute\_set is built through a *bitwise or* of the attribute constants described below. Not all combinations of attributes are allowed. Some attributes are mutually exclusive. If mutually exclusive attributes are combined, the behaviour is undefined. Attributes not mentioned below are not evaluated by this directive and have no effect. Default attributes can be selected by using the RTEMS\_DEFAULT\_ATTRIBUTES constant. The attribute set defines

- the scope of the message queue: RTEMS\_LOCAL (default) or RTEMS\_GLOBAL and
- the task wait queue discipline used by the message queue: RTEMS\_FIFO (default) or RTEMS\_PRIORITY.

The message queue has a local or global **scope** in a multiprocessing network (this attribute does not refer to SMP systems). The scope is selected by the mutually exclusive RTEMS\_LOCAL and RTEMS\_GLOBAL attributes.

- A **local scope** is the default and can be emphasized through the use of the RTEMS\_LOCAL attribute. A local message queue can be only used by the node which created it.
- A **global scope** is established if the RTEMS\_GLOBAL attribute is set. Setting the global attribute in a single node system has no effect.

The **task wait queue discipline** is selected by the mutually exclusive RTEMS\_FIFO and RTEMS\_PRIORITY attributes. The discipline defines the order in which tasks wait for a message to receive on a currently empty message queue.

- The **FIFO discipline** is the default and can be emphasized through use of the RTEMS\_FIFO attribute.
- The **priority discipline** is selected by the RTEMS\_PRIORITY attribute.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_NAME**

The name parameter was invalid.

#### **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

## **RTEMS\_INVALID\_NUMBER**

The count parameter was invalid.

#### **RTEMS\_INVALID\_SIZE**

The max\_message\_size parameter was invalid.

#### **RTEMS\_TOO\_MANY**

There was no inactive object available to create a message queue. The number of message queue available to the application is configured through the *[CONFIG-](#page-644-0)[URE\\_MAXIMUM\\_MESSAGE\\_QUEUES](#page-644-0)* (page 617) application configuration option.

## **RTEMS\_TOO\_MANY**

In multiprocessing configurations, there was no inactive global object available to create a global message queue. The number of global objects available to the application is configured through the *[CONFIGURE\\_MP\\_MAXIMUM\\_GLOBAL\\_OBJECTS](#page-765-0)* (page 738) application configuration option.

#### **RTEMS\_INVALID\_NUMBER**

The product of count and max\_message\_size is greater than the maximum storage size.

#### **RTEMS\_UNSATISFIED**

There was not enough memory available in the RTEMS Workspace to allocate the message buffers for the message queue.

## NOTES:

For message queues with a global scope, the maximum message size is effectively limited to the longest message which the *[MPCI](#page-1069-0)* is capable of transmitting.

For control and maintenance of the message queue, RTEMS allocates a *[QCB](#page-1072-1)* from the local QCB free pool and initializes it.

15.4. Directives 375

The QCB for a global message queue is allocated on the local node. Message queues should not be made global unless remote tasks must interact with the message queue. This is to avoid the system overhead incurred by the creation of a global message queue. When a global message queue is created, the message queue's name and identifier must be transmitted to every node in the system for insertion in the local copy of the global object table.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- When the directive operates on a global object, the directive sends a message to remote nodes. This may preempt the calling task.
- The number of message queues available to the application is configured through the *[CONFIGURE\\_MAXIMUM\\_MESSAGE\\_QUEUES](#page-644-0)* (page 617) application configuration option.
- Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace.
- The number of global objects available to the application is configured through the *[CON-](#page-765-0)[FIGURE\\_MP\\_MAXIMUM\\_GLOBAL\\_OBJECTS](#page-765-0)* (page 738) application configuration option.

## <span id="page-404-1"></span><span id="page-404-0"></span>15.4.2 rtems\_message\_queue\_construct()

Constructs a message queue from the specified the message queue configuration.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_message_queue_construct(
2 const rtems_message_queue_config *config,
3 rtems_id *id
4 );
```

## PARAMETERS:

#### **config**

This parameter is the pointer to an *[rtems\\_message\\_queue\\_config](#page-74-3)* (page 47) object. It configures the message queue.

#### **id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the identifier of the constructed message queue will be stored in this object.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The config parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_NAME**

The message queue name in the configuration was invalid.

## **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_NUMBER**

The maximum number of pending messages in the configuration was zero.

#### **RTEMS\_INVALID\_SIZE**

The maximum message size in the configuration was zero.

#### **RTEMS\_TOO\_MANY**

There was no inactive message queue object available to construct a message queue.

#### **RTEMS\_TOO\_MANY**

In multiprocessing configurations, there was no inactive global object available to construct a global message queue.

#### **RTEMS\_INVALID\_SIZE**

The maximum message size in the configuration was too big and resulted in integer overflows in calculations carried out to determine the size of the message buffer area.

## **RTEMS\_INVALID\_NUMBER**

The maximum number of pending messages in the configuration was too big and resulted in integer overflows in calculations carried out to determine the size of the message buffer area.

#### **RTEMS\_UNSATISFIED**

The message queue storage area begin pointer in the configuration was [NULL.](https://en.cppreference.com/w/c/types/NULL)

15.4. Directives 377

#### **RTEMS\_UNSATISFIED**

The message queue storage area size in the configuration was not equal to the size calculated from the maximum number of pending messages and the maximum message size.

#### NOTES:

In contrast to message queues created by *[rtems\\_message\\_queue\\_create\(\)](#page-401-0)* (page 374), the message queues constructed by this directive use a user-provided message buffer storage area.

This directive is intended for applications which do not want to use the RTEMS Workspace and instead statically allocate all operating system resources. An application based solely on static allocation can avoid any runtime memory allocators. This can simplify the application architecture as well as any analysis that may be required.

The value for *[CONFIGURE\\_MESSAGE\\_BUFFER\\_MEMORY](#page-610-0)* (page 583) should not include memory for message queues constructed by *[rtems\\_message\\_queue\\_construct\(\)](#page-404-0)* (page 377).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- When the directive operates on a global object, the directive sends a message to remote nodes. This may preempt the calling task.
- The number of message queues available to the application is configured through the *[CONFIGURE\\_MAXIMUM\\_MESSAGE\\_QUEUES](#page-644-0)* (page 617) application configuration option.
- Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace.
- The number of global objects available to the application is configured through the *[CON-](#page-765-0)[FIGURE\\_MP\\_MAXIMUM\\_GLOBAL\\_OBJECTS](#page-765-0)* (page 738) application configuration option.

## <span id="page-406-1"></span><span id="page-406-0"></span>15.4.3 rtems\_message\_queue\_ident()

Identifies a message queue by the object name.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_message_queue_ident(
2 rtems_name name,
3 uint32_t node,
4 rtems_id *id
5 );
```

#### PARAMETERS:

#### **name**

This parameter is the object name to look up.

#### **node**

This parameter is the node or node set to search for a matching object.

#### **id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the object identifier of an object with the specified name will be stored in this object.

#### DESCRIPTION:

This directive obtains a message queue identifier associated with the message queue name specified in name.

The node to search is specified in node. It shall be

- a valid node number,
- the constant RTEMS\_SEARCH\_ALL\_NODES to search in all nodes,
- the constant RTEMS\_SEARCH\_LOCAL\_NODE to search in the local node only, or
- the constant RTEMS\_SEARCH\_OTHER\_NODES to search in all nodes except the local node.

# RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_NAME**

The name parameter was 0.

#### **RTEMS\_INVALID\_NAME**

There was no object with the specified name on the specified nodes.

### **RTEMS\_INVALID\_NODE**

In multiprocessing configurations, the specified node was invalid.

15.4. Directives 379

#### NOTES:

If the message queue name is not unique, then the message queue identifier will match the first message queue with that name in the search order. However, this message queue identifier is not guaranteed to correspond to the desired message queue.

The objects are searched from lowest to the highest index. If node is RTEMS\_SEARCH\_ALL\_NODES, all nodes are searched with the local node being searched first. All other nodes are searched from lowest to the highest node number.

If node is a valid node number which does not represent the local node, then only the message queues exported by the designated node are searched.

This directive does not generate activity on remote nodes. It accesses only the local copy of the global object table.

The message queue identifier is used with other message related directives to access the message queue.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-408-1"></span><span id="page-408-0"></span>15.4.4 rtems\_message\_queue\_delete()

Deletes the message queue.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_message_queue_delete( rtems_id id );
```

#### PARAMETERS:

## **id**

This parameter is the message queue identifier.

#### DESCRIPTION:

This directive deletes the message queue specified by id. As a result of this directive, all tasks blocked waiting to receive a message from this queue will be readied and returned a status code which indicates that the message queue was deleted.

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

### **RTEMS\_INVALID\_ID**

There was no message queue associated with the identifier specified by id.

#### **RTEMS\_ILLEGAL\_ON\_REMOTE\_OBJECT**

The message queue resided on a remote node.

## NOTES:

When the message queue is deleted, any messages in the queue are returned to the free message buffer pool. Any information stored in those messages is lost. The message buffers allocated for the message queue are reclaimed.

The *[QCB](#page-1072-1)* for the deleted message queue is reclaimed by RTEMS.

When a global message queue is deleted, the message queue identifier must be transmitted to every node in the system for deletion from the local copy of the global object table.

The message queue must reside on the local node, even if the message queue was created with the RTEMS\_GLOBAL attribute.

Proxies, used to represent remote tasks, are reclaimed when the message queue is deleted.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

15.4. Directives 381

- When the directive operates on a global object, the directive sends a message to remote nodes. This may preempt the calling task.
- The calling task does not have to be the task that created the object. Any local task that knows the object identifier can delete the object.
- Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace.

## <span id="page-410-1"></span><span id="page-410-0"></span>15.4.5 rtems\_message\_queue\_send()

Puts the message at the rear of the queue.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_message_queue_send(
2 rtems_id id,
3 const void *buffer,
4 size_t size
5 );
```

#### PARAMETERS:

#### **id**

This parameter is the queue identifier.

#### **buffer**

This parameter is the begin address of the message buffer to send.

#### **size**

This parameter is the size in bytes of the message buffer to send.

## DESCRIPTION:

This directive sends the message buffer of size bytes in length to the queue specified by id. If a task is waiting at the queue, then the message is copied to the waiting task's buffer and the task is unblocked. If no tasks are waiting at the queue, then the message is copied to a message buffer which is obtained from this message queue's message buffer pool. The message buffer is then placed at the rear of the queue.

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no queue associated with the identifier specified by id.

#### **RTEMS\_INVALID\_ADDRESS**

The buffer parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_SIZE**

The size of the message exceeded the maximum message size of the queue as defined by *[rtems\\_message\\_queue\\_create\(\)](#page-401-0)* (page 374) or *[rtems\\_message\\_queue\\_construct\(\)](#page-404-0)* (page 377).

#### **RTEMS\_TOO\_MANY**

The maximum number of pending messages supported by the queue as defined by *[rtems\\_message\\_queue\\_create\(\)](#page-401-0)* (page 374) or *[rtems\\_message\\_queue\\_construct\(\)](#page-404-0)* (page 377) has been reached.

15.4. Directives 383

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive may be called from within interrupt context.
- The directive may unblock a task. This may cause the calling task to be preempted.
- When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply. This will preempt the calling task.

## <span id="page-412-1"></span><span id="page-412-0"></span>15.4.6 rtems\_message\_queue\_urgent()

Puts the message at the front of the queue.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_message_queue_urgent(
2 rtems_id id,
3 const void *buffer,
4 size_t size
5 );
```

#### PARAMETERS:

#### **id**

This parameter is the queue identifier.

#### **buffer**

This parameter is the begin address of the message buffer to send urgently.

#### **size**

This parameter is the size in bytes of the message buffer to send urgently.

## DESCRIPTION:

This directive sends the message buffer of size bytes in length to the queue specified by id. If a task is waiting at the queue, then the message is copied to the waiting task's buffer and the task is unblocked. If no tasks are waiting at the queue, then the message is copied to a message buffer which is obtained from this message queue's message buffer pool. The message buffer is then placed at the front of the queue.

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no queue associated with the identifier specified by id.

# **RTEMS\_INVALID\_ADDRESS**

The buffer parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_SIZE**

The size of the message exceeded the maximum message size of the queue as defined by *[rtems\\_message\\_queue\\_create\(\)](#page-401-0)* (page 374) or *[rtems\\_message\\_queue\\_construct\(\)](#page-404-0)* (page 377).

#### **RTEMS\_TOO\_MANY**

The maximum number of pending messages supported by the queue as defined by *[rtems\\_message\\_queue\\_create\(\)](#page-401-0)* (page 374) or *[rtems\\_message\\_queue\\_construct\(\)](#page-404-0)* (page 377) has been reached.

15.4. Directives 385

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive may be called from within interrupt context.
- The directive may unblock a task. This may cause the calling task to be preempted.
- When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply. This will preempt the calling task.

## <span id="page-414-1"></span><span id="page-414-0"></span>15.4.7 rtems\_message\_queue\_broadcast()

Broadcasts the messages to the tasks waiting at the queue.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_message_queue_broadcast(
2 rtems_id id,
3 const void *buffer,
4 size_t size,
5 uint32_t *count
6 );
```

#### PARAMETERS:

#### **id**

This parameter is the queue identifier.

#### **buffer**

This parameter is the begin address of the message buffer to broadcast.

#### **size**

This parameter is the size in bytes of the message buffer to broadcast.

#### **count**

This parameter is the pointer to an [uint32\\_t](https://en.cppreference.com/w/c/types/integer) object. When the directive call is successful, the number of unblocked tasks will be stored in this object.

#### DESCRIPTION:

This directive causes all tasks that are waiting at the queue specified by id to be unblocked and sent the message contained in buffer. Before a task is unblocked, the message buffer of size bytes in length is copied to that task's message buffer. The number of tasks that were unblocked is returned in count.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no queue associated with the identifier specified by id.

## **RTEMS\_INVALID\_ADDRESS**

The buffer parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ADDRESS**

The count parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_SIZE**

The size of the message exceeded the maximum message size of the queue as defined by *[rtems\\_message\\_queue\\_create\(\)](#page-401-0)* (page 374) or *[rtems\\_message\\_queue\\_construct\(\)](#page-404-0)* (page 377).

15.4. Directives 387

#### NOTES:

The execution time of this directive is directly related to the number of tasks waiting on the message queue, although it is more efficient than the equivalent number of invocations of *[rtems\\_message\\_queue\\_send\(\)](#page-410-0)* (page 383).

This directive unblocks receivers in a non-atomic way. Meaning, it will not only unblock those receivers it finds waiting at the queue when it is invoked but also any new receivers which start waiting for messages after it is invoked and before it returns. This may lead to infinite unblocking loops.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive may be called from within interrupt context.
- The directive may unblock a task. This may cause the calling task to be preempted.
- When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply. This will preempt the calling task.

## <span id="page-416-1"></span><span id="page-416-0"></span>15.4.8 rtems\_message\_queue\_receive()

Receives a message from the queue.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_message_queue_receive(
2 rtems_id id,
3 void *buffer,
4 size_t *size,
5 rtems_option option_set,
6 rtems_interval timeout
7 );
```

#### PARAMETERS:

#### **id**

This parameter is the queue identifier.

#### **buffer**

This parameter is the begin address of the buffer to receive the message. The buffer shall be large enough to receive a message of the maximum length of the queue as defined by *[rtems\\_message\\_queue\\_create\(\)](#page-401-0)* (page 374) or *[rtems\\_message\\_queue\\_construct\(\)](#page-404-0)* (page 377). The size parameter cannot be used to specify the size of the buffer.

#### **size**

This parameter is the pointer to a [size\\_t](https://en.cppreference.com/w/c/types/size_t) object. When the directive call is successful, the size in bytes of the received messages will be stored in this object. This parameter cannot be used to specify the size of the buffer.

#### **option\_set**

This parameter is the option set.

#### **timeout**

This parameter is the timeout in *[clock ticks](#page-1062-1)* if the RTEMS\_WAIT option is set. Use RTEMS\_NO\_TIMEOUT to wait potentially forever.

#### DESCRIPTION:

This directive receives a message from the queue specified by id.

The **option set** specified in option\_set is built through a *bitwise or* of the option constants described below. Not all combinations of options are allowed. Some options are mutually exclusive. If mutually exclusive options are combined, the behaviour is undefined. Options not mentioned below are not evaluated by this directive and have no effect. Default options can be selected by using the RTEMS\_DEFAULT\_OPTIONS constant.

The calling task can **wait** or **try to receive** a message from the queue according to the mutually exclusive RTEMS\_WAIT and RTEMS\_NO\_WAIT options.

â€¢ **Waiting to receive** a message from the queue is the default and can be emphasized through the use of the RTEMS\_WAIT option. The timeout parameter defines how long the calling task is willing to wait. Use RTEMS\_NO\_TIMEOUT to wait potentially forever, otherwise set a timeout interval in clock ticks.

15.4. Directives 389

â€¢ **Trying to receive** a message from the queue is selected by the RTEMS\_NO\_WAIT option. If this option is defined, then the timeout parameter is ignored. When a message from the queue cannot be immediately received, then the RTEMS\_UNSATISFIED status is returned.

With either RTEMS\_WAIT or RTEMS\_NO\_WAIT if there is at least one message in the queue, then it is copied to the buffer, the size is set to return the length of the message in bytes, and this directive returns immediately with the RTEMS\_SUCCESSFUL status code. The buffer has to be big enough to receive a message of the maximum length with respect to this message queue.

If the calling task chooses to return immediately and the queue is empty, then the directive returns immediately with the RTEMS\_UNSATISFIED status code. If the calling task chooses to wait at the message queue and the queue is empty, then the calling task is placed on the message wait queue and blocked. If the queue was created with the RTEMS\_PRIORITY option specified, then the calling task is inserted into the wait queue according to its priority. But, if the queue was created with the RTEMS\_FIFO option specified, then the calling task is placed at the rear of the wait queue.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no queue associated with the identifier specified by id.

#### **RTEMS\_INVALID\_ADDRESS**

The buffer parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ADDRESS**

The size parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_UNSATISFIED**

The queue was empty.

#### **RTEMS\_TIMEOUT**

The timeout happened while the calling task was waiting to receive a message

## **RTEMS\_OBJECT\_WAS\_DELETED**

The queue was deleted while the calling task was waiting to receive a message.

## CONSTRAINTS:

The following constraints apply to this directive:

- When a local queue is accessed and the RTEMS\_NO\_WAIT option is set, the directive may be called from within interrupt context.
- The directive may be called from within task context.
- When the request cannot be immediately satisfied and the RTEMS\_WAIT option is set, the calling task blocks at some point during the directive call.
- The timeout functionality of the directive requires a *[clock tick](#page-1062-1)*.
- When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply. This will preempt the calling task.

## <span id="page-418-1"></span><span id="page-418-0"></span>15.4.9 rtems\_message\_queue\_get\_number\_pending()

Gets the number of messages pending on the queue.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_message_queue_get_number_pending(
2 rtems_id id,
3 uint32_t *count
4 );
```

#### PARAMETERS:

#### **id**

This parameter is the queue identifier.

#### **count**

This parameter is the pointer to an [uint32\\_t](https://en.cppreference.com/w/c/types/integer) object. When the directive call is successful, the number of pending messages will be stored in this object.

#### DESCRIPTION:

This directive returns the number of messages pending on the queue specified by id in count. If no messages are present on the queue, count is set to zero.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no queue associated with the identifier specified by id.

#### **RTEMS\_INVALID\_ADDRESS**

The count parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive may be called from within interrupt context.
- When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply. This will preempt the calling task.

15.4. Directives 391

## <span id="page-419-1"></span><span id="page-419-0"></span>15.4.10 rtems\_message\_queue\_flush()

Flushes all messages on the queue.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_message_queue_flush( rtems_id id, uint32_t *count );
```

### PARAMETERS:

## **id**

This parameter is the queue identifier.

#### **count**

This parameter is the pointer to an [uint32\\_t](https://en.cppreference.com/w/c/types/integer) object. When the directive call is successful, the number of pending messages removed from the queue will be stored in this object.

#### DESCRIPTION:

This directive removes all pending messages from the queue specified by id. The number of messages removed is returned in count. If no messages are present on the queue, count is set to zero.

#### RETURN VALUES:

### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no queue associated with the identifier specified by id.

#### **RTEMS\_INVALID\_ADDRESS**

The count parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### NOTES:

The directive does not flush tasks waiting to receive a message from the *[wait queue](#page-1078-0)* of the message queue.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

## <span id="page-420-1"></span><span id="page-420-0"></span>15.4.11 RTEMS\_MESSAGE\_QUEUE\_BUFFER()

Defines a structure which can be used as a message queue buffer for messages of the specified maximum size.

#### CALLING SEQUENCE:

```
1 RTEMS_MESSAGE_QUEUE_BUFFER( size_t maximum_message_size );
```

#### PARAMETERS:

#### **maximum\_message\_size**

This parameter is the maximum message size in bytes.

#### NOTES:

Use this macro to define the message buffer storage area for *[rtems\\_message\\_queue\\_construct\(\)](#page-404-0)* (page 377).

15.4. Directives 393

CHAPTER

# **SIXTEEN**

# <span id="page-422-0"></span>EVENT MANAGER

# <span id="page-423-0"></span>16.1 Introduction

The Event Manager provides a high performance method of inter-task communication and synchronization. The directives provided by the Event Manager are:

- *[rtems\\_event\\_send\(\)](#page-428-0)* (page 401) Sends the event set to the task.
- *[rtems\\_event\\_receive\(\)](#page-430-0)* (page 403) Receives or gets an event set from the calling task.

# <span id="page-424-4"></span><span id="page-424-0"></span>16.2 Background

## <span id="page-424-1"></span>16.2.1 Event Sets

An event flag is used by a task (or ISR) to inform another task of the occurrence of a significant situation. Thirty-two event flags are associated with each task. A collection of one or more event flags is referred to as an event set. The data type rtems\_event\_set is used to manage event sets.

The application developer should remember the following key characteristics of event operations when utilizing the event manager:

- Events provide a simple synchronization facility.
- Events are aimed at tasks.
- Tasks can wait on more than one event simultaneously.
- Events are independent of one another.
- Events do not hold or transport data.
- Events are not queued. In other words, if an event is sent more than once to a task before being received, the second and subsequent send operations to that same task have no effect.

An event set is posted when it is directed (or sent) to a task. A pending event is an event that has been posted but not received. An event condition is used to specify the event set which the task desires to receive and the algorithm which will be used to determine when the request is satisfied. An event condition is satisfied based upon one of two algorithms which are selected by the user. The RTEMS\_EVENT\_ANY algorithm states that an event condition is satisfied when at least a single requested event is posted. The RTEMS\_EVENT\_ALL algorithm states that an event condition is satisfied when every requested event is posted.

## <span id="page-424-2"></span>16.2.2 Building an Event Set or Condition

An event set or condition is built by a bitwise OR of the desired events. The set of valid events is RTEMS\_EVENT\_0 through RTEMS\_EVENT\_31. If an event is not explicitly specified in the set or condition, then it is not present. Events are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each event appears exactly once in the event set list.

For example, when sending the event set consisting of RTEMS\_EVENT\_6, RTEMS\_EVENT\_15, and RTEMS\_EVENT\_31, the event parameter to the rtems\_event\_send directive should be RTEMS\_EVENT\_6 | RTEMS\_EVENT\_15 | RTEMS\_EVENT\_31.

## <span id="page-424-3"></span>16.2.3 Building an EVENT\_RECEIVE Option Set

In general, an option is built by a bitwise OR of the desired option components. The set of valid options for the rtems\_event\_receive directive are listed in the following table:

| RTEMS_WAIT      | task will wait for event (default) |
|-----------------|------------------------------------|
| RTEMS_NO_WAIT   | task should not wait               |
| RTEMS_EVENT_ALL | return after all events (default)  |
| RTEMS_EVENT_ANY | return after any events            |

16.2. Background 397

Option values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each option appears exactly once in the component list. An option listed as a default is not required to appear in the option list, although it is a good programming practice to specify default options. If all defaults are desired, the option RTEMS\_DEFAULT\_OPTIONS should be specified on this call.

This example demonstrates the option parameter needed to poll for all events in a particular event condition to arrive. The option parameter passed to the rtems\_event\_receive directive should be either RTEMS\_EVENT\_ALL | RTEMS\_NO\_WAIT or RTEMS\_NO\_WAIT. The option parameter can be set to RTEMS\_NO\_WAIT because RTEMS\_EVENT\_ALL is the default condition for rtems\_event\_receive.

# <span id="page-426-0"></span>16.3 Operations

## <span id="page-426-1"></span>16.3.1 Sending an Event Set

The rtems\_event\_send directive allows a task (or an ISR) to direct an event set to a target task. Based upon the state of the target task, one of the following situations applies:

- Target Task is Blocked Waiting for Events
  - **â€“** If the waiting task's input event condition is satisfied, then the task is made ready for execution.
  - **â€“** If the waiting task's input event condition is not satisfied, then the event set is posted but left pending and the task remains blocked.
- Target Task is Not Waiting for Events
  - **â€“** The event set is posted and left pending.

## <span id="page-426-2"></span>16.3.2 Receiving an Event Set

The rtems\_event\_receive directive is used by tasks to accept a specific input event condition. The task also specifies whether the request is satisfied when all requested events are available or any single requested event is available. If the requested event condition is satisfied by pending events, then a successful return code and the satisfying event set are returned immediately. If the condition is not satisfied, then one of the following situations applies:

- By default, the calling task will wait forever for the event condition to be satisfied.
- Specifying the RTEMS\_NO\_WAIT option forces an immediate return with an error status code.
- Specifying a timeout limits the period the task will wait before returning with an error status code.

## <span id="page-426-3"></span>16.3.3 Determining the Pending Event Set

A task can determine the pending event set by calling the rtems\_event\_receive directive with a value of RTEMS\_PENDING\_EVENTS for the input event condition. The pending events are returned to the calling task but the event set is left unaltered.

## <span id="page-426-4"></span>16.3.4 Receiving all Pending Events

A task can receive all of the currently pending events by calling the rtems\_event\_receive directive with a value of RTEMS\_ALL\_EVENTS for the input event condition and RTEMS\_NO\_WAIT | RTEMS\_EVENT\_ANY for the option set. The pending events are returned to the calling task and the event set is cleared. If no events are pending then the RTEMS\_UNSATISFIED status code will be returned.

16.3. Operations 399

# <span id="page-427-0"></span>16.4 Directives

This section details the directives of the Event Manager. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

## <span id="page-428-1"></span><span id="page-428-0"></span>16.4.1 rtems\_event\_send()

Sends the event set to the task.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_event_send( rtems_id id, rtems_event_set event_in );
```

### PARAMETERS:

## **id**

This parameter is the identifier of the target task to receive the event set.

#### **event\_in**

This parameter is the event set to send.

#### DESCRIPTION:

This directive sends the event set, event\_in, to the target task identified by id. Based upon the state of the target task, one of the following situations applies:

- The target task is blocked waiting for events, then
  - **â€“** if the waiting task's input event condition is satisfied, then the task is made ready for execution, or
  - **â€“** otherwise, the event set is posted but left pending and the task remains blocked.
- The target task is not waiting for events, then the event set is posted and left pending.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ID**

There was no task associated with the identifier specified by id.

#### NOTES:

Events can be sent by tasks or an *[ISR](#page-1067-0)*.

Specifying RTEMS\_SELF for id results in the event set being sent to the calling task.

The event set to send shall be built by a *bitwise or* of the desired events. The set of valid events is RTEMS\_EVENT\_0 through RTEMS\_EVENT\_31. If an event is not explicitly specified in the set, then it is not present.

Identical events sent to a task are not queued. In other words, the second, and subsequent, posting of an event to a task before it can perform an *[rtems\\_event\\_receive\(\)](#page-430-0)* (page 403) has no effect.

The calling task will be preempted if it has preemption enabled and a higher priority task is unblocked as the result of this directive.

Sending an event set to a global task which does not reside on the local node will generate a request telling the remote node to send the event set to the appropriate task.

16.4. Directives 401

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may unblock a task. This may cause the calling task to be preempted.

## <span id="page-430-1"></span><span id="page-430-0"></span>16.4.2 rtems\_event\_receive()

Receives or gets an event set from the calling task.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_event_receive(
2 rtems_event_set event_in,
3 rtems_option option_set,
4 rtems_interval ticks,
5 rtems_event_set *event_out
6 );
```

#### PARAMETERS:

#### **event\_in**

This parameter is the event set of interest. Use RTEMS\_PENDING\_EVENTS to get the pending events.

#### **option\_set**

This parameter is the option set.

### **ticks**

This parameter is the timeout in clock ticks if the RTEMS\_WAIT option is set. Use RTEMS\_NO\_TIMEOUT to wait potentially forever.

#### **event\_out**

This parameter is the pointer to an event set. The received or pending events are stored in the referenced event set if the operation was successful.

## DESCRIPTION:

This directive can be used to

- get the pending events of the calling task, or
- receive events.

To **get the pending events** use the constant RTEMS\_PENDING\_EVENTS for the event\_in parameter. The pending events are returned to the calling task but the event set of the calling task is left unaltered. The option\_set and ticks parameters are ignored in this case. The directive returns immediately and does not block.

To **receive events** you have to define an input event condition and some options.

The **option set** specified in option\_set is built through a *bitwise or* of the option constants described below. Not all combinations of options are allowed. Some options are mutually exclusive. If mutually exclusive options are combined, the behaviour is undefined. Options not mentioned below are not evaluated by this directive and have no effect. Default options can be selected by using the RTEMS\_DEFAULT\_OPTIONS constant. The option set defines

- if the calling task will wait or poll for the events, and
- if the calling task wants to receive all or any of the input events.

The calling task can **wait** or **poll** for the events.

16.4. Directives 403

- <span id="page-431-0"></span>â€¢ **Waiting** for events is the default and can be emphasized through the use of the RTEMS\_WAIT option. The ticks parameter defines how long the calling task is willing to wait. Use RTEMS\_NO\_TIMEOUT to wait potentially forever, otherwise set a timeout interval in clock ticks.
- Not waiting for events (**polling**) is selected by the RTEMS\_NO\_WAIT option. If this option is defined, then the ticks parameter is ignored.

The calling task can receive **all** or **any** of the input events specified in event\_in.

- Receiving **all** input events is the default and can be emphasized through the use of the RTEMS\_EVENT\_ALL option.
- Receiving **any** of the input events is selected by the RTEMS\_EVENT\_ANY option.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The event\_out parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_UNSATISFIED**

The events of interest were not immediately available.

#### **RTEMS\_TIMEOUT**

The events of interest were not available within the specified timeout interval.

#### NOTES:

This directive only affects the events specified in event\_in. Any pending events that do not correspond to any of the events specified in event\_in will be left pending.

To receive all events use the event set constant RTEMS\_ALL\_EVENTS for the event\_in parameter. Do not confuse this event set constant with the directive option RTEMS\_EVENT\_ALL.

A task can **receive all of the pending events** by calling the directive with a value of RTEMS\_ALL\_EVENTS for the event\_in parameter and the bitwise or of the RTEMS\_NO\_WAIT and RTEMS\_EVENT\_ANY options for the option\_set parameter. The pending events are returned and the event set of the task is cleared. If no events are pending then the RTEMS\_UNSATISFIED status code will be returned.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The timeout functionality of the directive requires a *[clock tick](#page-1062-1)*.

CHAPTER

# **SEVENTEEN**

# <span id="page-432-0"></span>SIGNAL MANAGER

# <span id="page-433-0"></span>17.1 Introduction

The Signal Manager provides the capabilities required for asynchronous communication. The directives provided by the Signal Manager are:

- *[rtems\\_signal\\_catch\(\)](#page-439-0)* (page 412) Establishes an asynchronous signal routine (ASR) for the calling task.
- *[rtems\\_signal\\_send\(\)](#page-441-0)* (page 414) Sends the signal set to the task.

# <span id="page-434-5"></span><span id="page-434-0"></span>17.2 Background

## <span id="page-434-1"></span>17.2.1 Signal Manager Definitions

The signal manager allows a task to optionally define an asynchronous signal routine (ASR). An ASR is to a task what an ISR is to an application's set of tasks. When the processor is interrupted, the execution of an application is also interrupted and an ISR is given control. Similarly, when a signal is sent to a task, that task's execution path will be "interrupted" by the ASR. Sending a signal to a task has no effect on the receiving task's current execution state.

A signal flag is used by a task (or ISR) to inform another task of the occurrence of a significant situation. Thirty-two signal flags are associated with each task. A collection of one or more signals is referred to as a signal set. The data type rtems\_signal\_set is used to manipulate signal sets.

A signal set is posted when it is directed (or sent) to a task. A pending signal is a signal that has been sent to a task with a valid ASR, but has not been processed by that task's ASR.

## <span id="page-434-2"></span>17.2.2 A Comparison of ASRs and ISRs

The format of an ASR is similar to that of an ISR with the following exceptions:

- ISRs are scheduled by the processor hardware. ASRs are scheduled by RTEMS.
- ISRs do not execute in the context of a task and may invoke only a subset of directives. ASRs execute in the context of a task and may execute any directive.
- When an ISR is invoked, it is passed the vector number as its argument. When an ASR is invoked, it is passed the signal set as its argument.
- An ASR has a task mode which can be different from that of the task. An ISR does not execute as a task and, as a result, does not have a task mode.

## <span id="page-434-3"></span>17.2.3 Building a Signal Set

A signal set is built by a bitwise OR of the desired signals. The set of valid signals is RTEMS\_SIGNAL\_0 through RTEMS\_SIGNAL\_31. If a signal is not explicitly specified in the signal set, then it is not present. Signal values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each signal appears exactly once in the component list.

This example demonstrates the signal parameter used when sending the signal set consisting of RTEMS\_SIGNAL\_6, RTEMS\_SIGNAL\_15, and RTEMS\_SIGNAL\_31. The signal parameter provided to the rtems\_signal\_send directive should be RTEMS\_SIGNAL\_6 | RTEMS\_SIGNAL\_15 | RTEMS\_SIGNAL\_31.

## <span id="page-434-4"></span>17.2.4 Building an ASR Mode

In general, an ASR's mode is built by a bitwise OR of the desired mode components. The set of valid mode components is the same as those allowed with the task\_create and task\_mode directives. A complete list of mode options is provided in the following table:

17.2. Background 407

| RTEMS_PREEMPT<br>RTEMS_NO_PREEMPT | RTEMS_PREEMPT_MASK<br>is masked by<br>and enables preemption<br>RTEMS_PREEMPT_MASK<br>is masked by<br>and disables preemption |
|-----------------------------------|-------------------------------------------------------------------------------------------------------------------------------|
| RTEMS_NO_TIMESLICE                | is masked by<br>RTEMS_TIMESLICE_MASK<br>and disables timeslicing                                                              |
| RTEMS_TIMESLICE                   | is masked by<br>RTEMS_TIMESLICE_MASK<br>and enables timeslicing                                                               |
| RTEMS_ASR                         | is masked by<br>RTEMS_ASR_MASK<br>and enables ASR processing                                                                  |
| RTEMS_NO_ASR                      | is masked by<br>RTEMS_ASR_MASK<br>and disables ASR processing                                                                 |
| RTEMS_INTERRUPT_<br>LEVEL(0)      | is masked by<br>RTEMS_INTERRUPT_MASK<br>and enables all interrupts                                                            |
| RTEMS_INTERRUPT_<br>LEVEL(n)      | is masked by<br>RTEMS_INTERRUPT_MASK<br>and sets interrupts level n                                                           |

Mode values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each mode appears exactly once in the component list. A mode component listed as a default is not required to appear in the mode list, although it is a good programming practice to specify default components. If all defaults are desired, the mode DEFAULT\_MODES should be specified on this call.

This example demonstrates the mode parameter used with the rtems\_signal\_catch to establish an ASR which executes at interrupt level three and is non-preemptible. The mode should be set to RTEMS\_INTERRUPT\_LEVEL(3) | RTEMS\_NO\_PREEMPT to indicate the desired processor mode and interrupt level.

# <span id="page-436-4"></span><span id="page-436-0"></span>17.3 Operations

## <span id="page-436-1"></span>17.3.1 Establishing an ASR

The rtems\_signal\_catch directive establishes an ASR for the calling task. The address of the ASR and its execution mode are specified to this directive. The ASR's mode is distinct from the task's mode. For example, the task may allow preemption, while that task's ASR may have preemption disabled. Until a task calls rtems\_signal\_catch the first time, its ASR is invalid, and no signal sets can be sent to the task.

A task may invalidate its ASR and discard all pending signals by calling rtems\_signal\_catch with a value of NULL for the ASR's address. When a task's ASR is invalid, new signal sets sent to this task are discarded.

A task may disable ASR processing (RTEMS\_NO\_ASR) via the task\_mode directive. When a task's ASR is disabled, the signals sent to it are left pending to be processed later when the ASR is enabled.

Any directive that can be called from a task can also be called from an ASR. A task is only allowed one active ASR. Thus, each call to rtems\_signal\_catch replaces the previous one.

Normally, signal processing is disabled for the ASR's execution mode, but if signal processing is enabled for the ASR, the ASR must be reentrant.

## <span id="page-436-2"></span>17.3.2 Sending a Signal Set

The rtems\_signal\_send directive allows both tasks and ISRs to send signals to a target task. The target task and a set of signals are specified to the rtems\_signal\_send directive. The sending of a signal to a task has no effect on the execution state of that task. If the task is not the currently running task, then the signals are left pending and processed by the task's ASR the next time the task is dispatched to run. The ASR is executed immediately before the task is dispatched. If the currently running task sends a signal to itself or is sent a signal from an ISR, its ASR is immediately dispatched to run provided signal processing is enabled.

If an ASR with signals enabled is preempted by another task or an ISR and a new signal set is sent, then a new copy of the ASR will be invoked, nesting the preempted ASR. Upon completion of processing the new signal set, control will return to the preempted ASR. In this situation, the ASR must be reentrant.

Like events, identical signals sent to a task are not queued. In other words, sending the same signal multiple times to a task (without any intermediate signal processing occurring for the task), has the same result as sending that signal to that task once.

## <span id="page-436-3"></span>17.3.3 Processing an ASR

Asynchronous signals were designed to provide the capability to generate software interrupts. The processing of software interrupts parallels that of hardware interrupts. As a result, the differences between the formats of ASRs and ISRs is limited to the meaning of the single argument passed to an ASR. The ASR should have the following calling sequence and adhere to C calling conventions:

```
1 rtems_asr user_routine(
2 rtems_signal_set signals
3 );
```

17.3. Operations 409

When the ASR returns to RTEMS the mode and execution path of the interrupted task (or ASR) is restored to the context prior to entering the ASR.

# <span id="page-438-0"></span>17.4 Directives

This section details the directives of the Signal Manager. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

17.4. Directives 411

## <span id="page-439-1"></span><span id="page-439-0"></span>17.4.1 rtems\_signal\_catch()

Establishes an asynchronous signal routine (ASR) for the calling task.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_signal_catch(
2 rtems_asr_entry asr_handler,
3 rtems_mode mode_set
4 );
```

#### PARAMETERS:

#### **asr\_handler**

This parameter is the handler to process an asynchronous signal set.

#### **mode\_set**

This parameter is the task mode while an asynchronous signal set is processed by the handler. See *[rtems\\_task\\_mode\(\)](#page-159-0)* (page 132).

#### DESCRIPTION:

This directive establishes an asynchronous signal routine (ASR) for the calling task. The asr\_handler parameter specifies the entry point of the ASR. A task may have at most one handler installed at a time. The most recently installed handler is used. When asr\_handler is [NULL,](https://en.cppreference.com/w/c/types/NULL) the ASR for the calling task is invalidated and all pending signals are cleared. Any signals sent to a task with an invalid ASR are discarded. The mode\_set parameter specifies the execution mode for the ASR. This execution mode supersedes the task's execution mode while the ASR is executing.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_NOT\_IMPLEMENTED**

The RTEMS\_NO\_PREEMPT was set in mode\_set and the system configuration had no implementation for this mode.

#### **RTEMS\_NOT\_IMPLEMENTED**

The RTEMS\_INTERRUPT\_LEVEL() was set to a positive level in mode\_set and the system configuration had no implementation for this mode.

#### NOTES:

It is strongly recommended to disable ASR processing during ASR processing by setting RTEMS\_NO\_ASR in mode\_set, otherwise a recursion may happen during ASR processing. Uncontrolled recursion may lead to stack overflows.

Using the same mutex (in particular a recursive mutex) in normal task context and during ASR processing may result in undefined behaviour.

Asynchronous signal handlers can access thread-local storage (*[TLS](#page-1077-2)*). When thread-local storage is shared between normal task context and ASR processing, it may be protected by disabled interrupts.

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

17.4. Directives 413

## <span id="page-441-1"></span><span id="page-441-0"></span>17.4.2 rtems\_signal\_send()

Sends the signal set to the task.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_signal_send(
2 rtems_id id,
3 rtems_signal_set signal_set
4 );
```

#### PARAMETERS:

#### **id**

This parameter is the identifier of the target task to receive the signal set.

#### **signal\_set**

This parameter is the signal set to send.

#### DESCRIPTION:

This directive sends the signal set, signal\_set, to the target task identified by id.

If a caller sends a signal set to a task with an invalid *[ASR](#page-1060-2)*, then an error code is returned to the caller. If a caller sends a signal set to a task whose ASR is valid but disabled, then the signal set will be caught and left pending for the ASR to process when it is enabled. If a caller sends a signal set to a task with an ASR that is both valid and enabled, then the signal set is caught and the ASR will execute the next time the task is dispatched to run.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_NUMBER**

The signal\_set parameter was 0.

#### **RTEMS\_INVALID\_ID**

There was no task associated with the identifier specified by id.

#### **RTEMS\_NOT\_DEFINED**

The target task had no valid ASR installed.

#### NOTES:

Sending a signal set to a task has no effect on that task's state. If a signal set is sent to a blocked task, then the task will remain blocked and the signals will be processed when the task becomes the running task.

Sending a signal set to a global task which does not reside on the local node will generate a request telling the remote node to send the signal set to the specified task.

#### <span id="page-442-0"></span>CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- When the directive operates on a local object, the directive will not cause the calling task to be preempted.
- When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply. This will preempt the calling task.

17.4. Directives 415

CHAPTER

# **EIGHTEEN**

# <span id="page-444-0"></span>PARTITION MANAGER

# <span id="page-445-0"></span>18.1 Introduction

The Partition Manager provides facilities to dynamically allocate memory in fixed-size units. The directives provided by the Partition Manager are:

- *[rtems\\_partition\\_create\(\)](#page-449-0)* (page 422) Creates a partition.
- *[rtems\\_partition\\_ident\(\)](#page-452-0)* (page 425) Identifies a partition by the object name.
- *[rtems\\_partition\\_delete\(\)](#page-454-0)* (page 427) Deletes the partition.
- *[rtems\\_partition\\_get\\_buffer\(\)](#page-456-0)* (page 429) Tries to get a buffer from the partition.
- *[rtems\\_partition\\_return\\_buffer\(\)](#page-458-0)* (page 431) Returns the buffer to the partition.

# <span id="page-446-3"></span><span id="page-446-0"></span>18.2 Background

## <span id="page-446-1"></span>18.2.1 Partition Manager Definitions

A partition is a physically contiguous memory area divided into fixed-size buffers that can be dynamically allocated and deallocated.

Partitions are managed and maintained as a list of buffers. Buffers are obtained from the front of the partition's free buffer chain and returned to the rear of the same chain. When a buffer is on the free buffer chain, RTEMS uses two pointers of memory from each buffer as the free buffer chain. When a buffer is allocated, the entire buffer is available for application use. Therefore, modifying memory that is outside of an allocated buffer could destroy the free buffer chain or the contents of an adjacent allocated buffer.

## <span id="page-446-2"></span>18.2.2 Building a Partition Attribute Set

In general, an attribute set is built by a bitwise OR of the desired attribute components. The set of valid partition attributes is provided in the following table:

| RTEMS_LOCAL  | local partition (default) |
|--------------|---------------------------|
| RTEMS_GLOBAL | global partition          |

Attribute values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each attribute appears exactly once in the component list. An attribute listed as a default is not required to appear in the attribute list, although it is a good programming practice to specify default attributes. If all defaults are desired, the attribute RTEMS\_DEFAULT\_ATTRIBUTES should be specified on this call. The attribute\_set parameter should be RTEMS\_GLOBAL to indicate that the partition is to be known globally.

18.2. Background 419

# <span id="page-447-0"></span>18.3 Operations

## <span id="page-447-1"></span>18.3.1 Creating a Partition

The rtems\_partition\_create directive creates a partition with a user-specified name. The partition's name, starting address, length and buffer size are all specified to the rtems\_partition\_create directive. RTEMS allocates a Partition Control Block (PTCB) from the PTCB free list. This data structure is used by RTEMS to manage the newly created partition. The number of buffers in the partition is calculated based upon the specified partition length and buffer size. If successful,the unique partition ID is returned to the calling task.

## <span id="page-447-2"></span>18.3.2 Obtaining Partition IDs

When a partition is created, RTEMS generates a unique partition ID and assigned it to the created partition until it is deleted. The partition ID may be obtained by either of two methods. First, as the result of an invocation of the rtems\_partition\_create directive, the partition ID is stored in a user provided location. Second, the partition ID may be obtained later using the rtems\_partition\_ident directive. The partition ID is used by other partition manager directives to access this partition.

## <span id="page-447-3"></span>18.3.3 Acquiring a Buffer

A buffer can be obtained by calling the rtems\_partition\_get\_buffer directive. If a buffer is available, then it is returned immediately with a successful return code. Otherwise, an unsuccessful return code is returned immediately to the caller. Tasks cannot block to wait for a buffer to become available.

## <span id="page-447-4"></span>18.3.4 Releasing a Buffer

Buffers are returned to a partition's free buffer chain with the rtems\_partition\_return\_buffer directive. This directive returns an error status code if the returned buffer was not previously allocated from this partition.

## <span id="page-447-5"></span>18.3.5 Deleting a Partition

The rtems\_partition\_delete directive allows a partition to be removed and returned to RTEMS. When a partition is deleted, the PTCB for that partition is returned to the PTCB free list. A partition with buffers still allocated cannot be deleted. Any task attempting to do so will be returned an error status code.

# <span id="page-448-0"></span>18.4 Directives

This section details the directives of the Partition Manager. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

18.4. Directives 421

## <span id="page-449-1"></span><span id="page-449-0"></span>18.4.1 rtems\_partition\_create()

Creates a partition.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_partition_create(
2 rtems_name name,
3 void *starting_address,
4 uintptr_t length,
5 size_t buffer_size,
6 rtems_attribute attribute_set,
7 rtems_id *id
8 );
```

#### PARAMETERS:

#### **name**

This parameter is the object name of the partition.

#### **starting\_address**

This parameter is the starting address of the buffer area used by the partition.

#### **length**

This parameter is the length in bytes of the buffer area used by the partition.

#### **buffer\_size**

This parameter is the size in bytes of a buffer managed by the partition.

## **attribute\_set**

This parameter is the attribute set of the partition.

**id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the identifier of the created partition will be stored in this object.

#### DESCRIPTION:

This directive creates a partition of fixed size buffers from a physically contiguous memory space which starts at starting\_address and is length bytes in size. Each allocated buffer is to be of buffer\_size in bytes. The partition has the user-defined object name specified in name. The assigned object identifier is returned in id. This identifier is used to access the partition with other partition related directives.

The **attribute set** specified in attribute\_set is built through a *bitwise or* of the attribute constants described below. Not all combinations of attributes are allowed. Some attributes are mutually exclusive. If mutually exclusive attributes are combined, the behaviour is undefined. Attributes not mentioned below are not evaluated by this directive and have no effect. Default attributes can be selected by using the RTEMS\_DEFAULT\_ATTRIBUTES constant.

The partition has a local or global **scope** in a multiprocessing network (this attribute does not refer to SMP systems). The scope is selected by the mutually exclusive RTEMS\_LOCAL and RTEMS\_GLOBAL attributes.

â€¢ A **local scope** is the default and can be emphasized through the use of the RTEMS\_LOCAL attribute. A local partition can be only used by the node which created it.

â€¢ A **global scope** is established if the RTEMS\_GLOBAL attribute is set. The memory space used for the partition must reside in shared memory. Setting the global attribute in a single node system has no effect.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_NAME**

The name parameter was invalid.

## **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_SIZE**

The length parameter was 0.

#### **RTEMS\_INVALID\_SIZE**

The buffer\_size parameter was 0.

#### **RTEMS\_INVALID\_SIZE**

The length parameter was less than the buffer\_size parameter.

#### **RTEMS\_INVALID\_SIZE**

The buffer\_size parameter was not an integral multiple of the pointer size.

#### **RTEMS\_INVALID\_SIZE**

The buffer\_size parameter was less than two times the pointer size.

#### **RTEMS\_INVALID\_ADDRESS**

The starting\_address parameter was not on a pointer size boundary.

#### **RTEMS\_TOO\_MANY**

There was no inactive object available to create a partition. The number of partitions available to the application is configured through the *[CONFIGURE\\_MAXIMUM\\_PARTITIONS](#page-645-0)* (page 618) application configuration option.

#### **RTEMS\_TOO\_MANY**

In multiprocessing configurations, there was no inactive global object available to create a global semaphore. The number of global objects available to the application is configured through the *[CONFIGURE\\_MP\\_MAXIMUM\\_GLOBAL\\_OBJECTS](#page-765-0)* (page 738) application configuration option.

## NOTES:

The partition buffer area specified by the starting\_address must be properly aligned. It must be possible to directly store target architecture pointers and also the user data. For example, if the user data contains some long double or vector data types, the partition buffer area and the buffer size must take the alignment of these types into account which is usually larger than the pointer alignment. A cache line alignment may be also a factor. Use RTEMS\_PARTITION\_ALIGNMENT to specify the minimum alignment of a partition buffer type.

The buffer\_size parameter must be an integral multiple of the pointer size on the target architecture. Additionally, buffer\_size must be large enough to hold two pointers on the target architecture. This is required for RTEMS to manage the buffers when they are free.

18.4. Directives 423

For control and maintenance of the partition, RTEMS allocates a *[PTCB](#page-1071-3)* from the local PTCB free pool and initializes it. Memory from the partition buffer area is not used by RTEMS to store the PTCB.

The PTCB for a global partition is allocated on the local node. Partitions should not be made global unless remote tasks must interact with the partition. This is to avoid the overhead incurred by the creation of a global partition. When a global partition is created, the partition's name and identifier must be transmitted to every node in the system for insertion in the local copy of the global object table.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- When the directive operates on a global object, the directive sends a message to remote nodes. This may preempt the calling task.
- The number of partitions available to the application is configured through the *[CONFIG-](#page-645-0)[URE\\_MAXIMUM\\_PARTITIONS](#page-645-0)* (page 618) application configuration option.
- Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace.
- The number of global objects available to the application is configured through the *[CON-](#page-765-0)[FIGURE\\_MP\\_MAXIMUM\\_GLOBAL\\_OBJECTS](#page-765-0)* (page 738) application configuration option.

## <span id="page-452-1"></span><span id="page-452-0"></span>18.4.2 rtems\_partition\_ident()

Identifies a partition by the object name.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_partition_ident(
2 rtems_name name,
3 uint32_t node,
4 rtems_id *id
5 );
```

#### PARAMETERS:

#### **name**

This parameter is the object name to look up.

#### **node**

This parameter is the node or node set to search for a matching object.

**id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the object identifier of an object with the specified name will be stored in this object.

#### DESCRIPTION:

This directive obtains a partition identifier associated with the partition name specified in name.

The node to search is specified in node. It shall be

- a valid node number,
- the constant RTEMS\_SEARCH\_ALL\_NODES to search in all nodes,
- the constant RTEMS\_SEARCH\_LOCAL\_NODE to search in the local node only, or
- the constant RTEMS\_SEARCH\_OTHER\_NODES to search in all nodes except the local node.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

## **RTEMS\_INVALID\_NAME**

The name parameter was 0.

#### **RTEMS\_INVALID\_NAME**

There was no object with the specified name on the specified nodes.

#### **RTEMS\_INVALID\_NODE**

In multiprocessing configurations, the specified node was invalid.

18.4. Directives 425

### NOTES:

If the partition name is not unique, then the partition identifier will match the first partition with that name in the search order. However, this partition identifier is not guaranteed to correspond to the desired partition.

The objects are searched from lowest to the highest index. If node is RTEMS\_SEARCH\_ALL\_NODES, all nodes are searched with the local node being searched first. All other nodes are searched from lowest to the highest node number.

If node is a valid node number which does not represent the local node, then only the partitions exported by the designated node are searched.

This directive does not generate activity on remote nodes. It accesses only the local copy of the global object table.

The partition identifier is used with other partition related directives to access the partition.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-454-1"></span><span id="page-454-0"></span>18.4.3 rtems\_partition\_delete()

Deletes the partition.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_partition_delete( rtems_id id );
```

### PARAMETERS:

#### **id**

This parameter is the partition identifier.

#### DESCRIPTION:

This directive deletes the partition specified by id.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no partition associated with the identifier specified by id.

## **RTEMS\_ILLEGAL\_ON\_REMOTE\_OBJECT**

The partition resided on a remote node.

## **RTEMS\_RESOURCE\_IN\_USE**

There were buffers of the partition still in use.

## NOTES:

The partition cannot be deleted if any of its buffers are still allocated.

The *[PTCB](#page-1071-3)* for the deleted partition is reclaimed by RTEMS.

When a global partition is deleted, the partition identifier must be transmitted to every node in the system for deletion from the local copy of the global object table.

The partition must reside on the local node, even if the partition was created with the RTEMS\_GLOBAL attribute.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- When the directive operates on a global object, the directive sends a message to remote nodes. This may preempt the calling task.
- The calling task does not have to be the task that created the object. Any local task that knows the object identifier can delete the object.

18.4. Directives 427

â€¢ Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace.

## <span id="page-456-1"></span><span id="page-456-0"></span>18.4.4 rtems\_partition\_get\_buffer()

Tries to get a buffer from the partition.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_partition_get_buffer( rtems_id id, void **buffer );
```

#### PARAMETERS:

## **id**

This parameter is the partition identifier.

#### **buffer**

This parameter is the pointer to a void pointer object. When the directive call is successful, the pointer to the allocated buffer will be stored in this object.

#### DESCRIPTION:

This directive allows a buffer to be obtained from the partition specified by id. The address of the allocated buffer is returned through the buffer parameter.

#### RETURN VALUES:

### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no partition associated with the identifier specified by id.

#### **RTEMS\_INVALID\_ADDRESS**

The buffer parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_UNSATISFIED**

There was no free buffer available to allocate and return.

#### NOTES:

The buffer start alignment is determined by the memory area and buffer size used to create the partition.

A task cannot wait on a buffer to become available.

Getting a buffer from a global partition which does not reside on the local node will generate a request telling the remote node to allocate a buffer from the partition.

## CONSTRAINTS:

The following constraints apply to this directive:

- When the directive operates on a local object, the directive may be called from within interrupt context.
- The directive may be called from within task context.
- When the directive operates on a local object, the directive will not cause the calling task to be preempted.

18.4. Directives 429

â€¢ When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply. This will preempt the calling task.

## <span id="page-458-1"></span><span id="page-458-0"></span>18.4.5 rtems\_partition\_return\_buffer()

Returns the buffer to the partition.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_partition_return_buffer( rtems_id id, void *buffer );
```

#### PARAMETERS:

## **id**

This parameter is the partition identifier.

#### **buffer**

This parameter is the pointer to the buffer to return.

#### DESCRIPTION:

This directive returns the buffer specified by buffer to the partition specified by id.

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no partition associated with the identifier specified by id.

## **RTEMS\_INVALID\_ADDRESS**

The buffer referenced by buffer was not in the partition.

## NOTES:

Returning a buffer multiple times is an error. It will corrupt the internal state of the partition.

## CONSTRAINTS:

The following constraints apply to this directive:

- When the directive operates on a local object, the directive may be called from within interrupt context.
- The directive may be called from within task context.
- When the directive operates on a local object, the directive will not cause the calling task to be preempted.
- When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply. This will preempt the calling task.

18.4. Directives 431

CHAPTER

# **NINETEEN**

# <span id="page-460-0"></span>REGION MANAGER

# <span id="page-461-0"></span>19.1 Introduction

The Region Manager provides facilities to dynamically allocate memory in variable sized units. The directives provided by the Region Manager are:

- *[rtems\\_region\\_create\(\)](#page-467-0)* (page 440) Creates a region.
- *[rtems\\_region\\_ident\(\)](#page-469-0)* (page 442) Identifies a region by the object name.
- *[rtems\\_region\\_delete\(\)](#page-470-0)* (page 443) Deletes the region.
- *[rtems\\_region\\_extend\(\)](#page-471-0)* (page 444) Extends the region.
- *[rtems\\_region\\_get\\_segment\(\)](#page-473-0)* (page 446) Gets a segment from the region.
- *[rtems\\_region\\_return\\_segment\(\)](#page-475-0)* (page 448) Returns the segment to the region.
- *[rtems\\_region\\_resize\\_segment\(\)](#page-476-0)* (page 449) Changes the size of the segment.
- *[rtems\\_region\\_get\\_information\(\)](#page-478-0)* (page 451) Gets the region information.
- *[rtems\\_region\\_get\\_free\\_information\(\)](#page-479-0)* (page 452) Gets the region free information.
- *[rtems\\_region\\_get\\_segment\\_size\(\)](#page-481-0)* (page 454) Gets the size of the region segment.

# <span id="page-462-4"></span><span id="page-462-0"></span>19.2 Background

## <span id="page-462-1"></span>19.2.1 Region Manager Definitions

A region makes up a physically contiguous memory space with user-defined boundaries from which variable-sized segments are dynamically allocated and deallocated. A segment is a variable size section of memory which is allocated in multiples of a user-defined page size. This page size is required to be a multiple of four greater than or equal to four. For example, if a request for a 350-byte segment is made in a region with 256-byte pages, then a 512-byte segment is allocated.

Regions are organized as doubly linked chains of variable sized memory blocks. Memory requests are allocated using a first-fit algorithm. If available, the requester receives the number of bytes requested (rounded up to the next page size). RTEMS requires some overhead from the region's memory for each segment that is allocated. Therefore, an application should only modify the memory of a segment that has been obtained from the region. The application should NOT modify the memory outside of any obtained segments and within the region's boundaries while the region is currently active in the system.

Upon return to the region, the free block is coalesced with its neighbors (if free) on both sides to produce the largest possible unused block.

## <span id="page-462-2"></span>19.2.2 Building an Attribute Set

In general, an attribute set is built by a bitwise OR of the desired attribute components. The set of valid region attributes is provided in the following table:

| RTEMS_FIFO     | tasks wait by FIFO (default) |
|----------------|------------------------------|
| RTEMS_PRIORITY | tasks wait by priority       |

Attribute values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each attribute appears exactly once in the component list. An attribute listed as a default is not required to appear in the attribute list, although it is a good programming practice to specify default attributes. If all defaults are desired, the attribute RTEMS\_DEFAULT\_ATTRIBUTES should be specified on this call.

This example demonstrates the attribute\_set parameter needed to create a region with the task priority waiting queue discipline. The attribute\_set parameter to the rtems\_region\_create directive should be RTEMS\_PRIORITY.

## <span id="page-462-3"></span>19.2.3 Building an Option Set

In general, an option is built by a bitwise OR of the desired option components. The set of valid options for the rtems\_region\_get\_segment directive are listed in the following table:

| RTEMS_WAIT    | task will wait for segment (default) |
|---------------|--------------------------------------|
| RTEMS_NO_WAIT | task should not wait                 |

Option values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each option appears exactly once in the component list. An option listed as a default is not required to appear in the option list, although it is a

19.2. Background 435

good programming practice to specify default options. If all defaults are desired, the option RTEMS\_DEFAULT\_OPTIONS should be specified on this call.

This example demonstrates the option parameter needed to poll for a segment. The option parameter passed to the rtems\_region\_get\_segment directive should be RTEMS\_NO\_WAIT.

# <span id="page-464-0"></span>19.3 Operations

## <span id="page-464-1"></span>19.3.1 Creating a Region

The rtems\_region\_create directive creates a region with the user-defined name. The user may select FIFO or task priority as the method for placing waiting tasks in the task wait queue. RTEMS allocates a Region Control Block (RNCB) from the RNCB free list to maintain the newly created region. RTEMS also generates a unique region ID which is returned to the calling task.

It is not possible to calculate the exact number of bytes available to the user since RTEMS requires overhead for each segment allocated. For example, a region with one segment that is the size of the entire region has more available bytes than a region with two segments that collectively are the size of the entire region. This is because the region with one segment requires only the overhead for one segment, while the other region requires the overhead for two segments.

Due to automatic coalescing, the number of segments in the region dynamically changes. Therefore, the total overhead required by RTEMS dynamically changes.

## <span id="page-464-2"></span>19.3.2 Obtaining Region IDs

When a region is created, RTEMS generates a unique region ID and assigns it to the created region until it is deleted. The region ID may be obtained by either of two methods. First, as the result of an invocation of the rtems\_region\_create directive, the region ID is stored in a user provided location. Second, the region ID may be obtained later using the rtems\_region\_ident directive. The region ID is used by other region manager directives to access this region.

## <span id="page-464-3"></span>19.3.3 Adding Memory to a Region

The rtems\_region\_extend directive may be used to add memory to an existing region. The caller specifies the size in bytes and starting address of the memory being added.

## <span id="page-464-4"></span>19.3.4 Acquiring a Segment

The rtems\_region\_get\_segment directive attempts to acquire a segment from a specified region. If the region has enough available free memory, then a segment is returned successfully to the caller. When the segment cannot be allocated, one of the following situations applies:

- By default, the calling task will wait forever to acquire the segment.
- Specifying the RTEMS\_NO\_WAIT option forces an immediate return with an error status code.
- Specifying a timeout limits the interval the task will wait before returning with an error status code.

If the task waits for the segment, then it is placed in the region's task wait queue in either FIFO or task priority order. All tasks waiting on a region are returned an error when the message queue is deleted.

## <span id="page-464-5"></span>19.3.5 Releasing a Segment

When a segment is returned to a region by the rtems\_region\_return\_segment directive, it is merged with its unallocated neighbors to form the largest possible segment. The first task on the wait queue is examined to determine if its segment request can now be satisfied. If so, it is given a segment and unblocked. This process is repeated until the first task's segment request cannot be satisfied.

19.3. Operations 437

## <span id="page-465-0"></span>19.3.6 Obtaining the Size of a Segment

The rtems\_region\_get\_segment\_size directive returns the size in bytes of the specified segment. The size returned includes any "extra" memory included in the segment because of rounding up to a page size boundary.

# <span id="page-465-1"></span>19.3.7 Changing the Size of a Segment

The rtems\_region\_resize\_segment directive is used to change the size in bytes of the specified segment. The size may be increased or decreased. When increasing the size of a segment, it is possible that the request cannot be satisfied. This directive provides functionality similar to the realloc() function in the Standard C Library.

## <span id="page-465-2"></span>19.3.8 Deleting a Region

A region can be removed from the system and returned to RTEMS with the rtems\_region\_delete directive. When a region is deleted, its control block is returned to the RNCB free list. A region with segments still allocated is not allowed to be deleted. Any task attempting to do so will be returned an error. As a result of this directive, all tasks blocked waiting to obtain a segment from the region will be readied and returned a status code which indicates that the region was deleted.

# <span id="page-466-0"></span>19.4 Directives

This section details the directives of the Region Manager. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

19.4. Directives 439

## <span id="page-467-1"></span><span id="page-467-0"></span>19.4.1 rtems\_region\_create()

Creates a region.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_region_create(
2 rtems_name name,
3 void *starting_address,
4 uintptr_t length,
5 uintptr_t page_size,
6 rtems_attribute attribute_set,
7 rtems_id *id
8 );
```

#### PARAMETERS:

#### **name**

This parameter is the object name of the region.

#### **starting\_address**

This parameter is the starting address of the memory area managed by the region.

#### **length**

This parameter is the length in bytes of the memory area managed by the region.

#### **page\_size**

This parameter is the alignment of the starting address and length of each allocated segment of the region.

#### **attribute\_set**

This parameter is the attribute set of the region.

#### **id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the identifier of the created region will be stored in this object.

#### DESCRIPTION:

This directive creates a region which resides on the local node. The region has the user-defined object name specified in name. The assigned object identifier is returned in id. This identifier is used to access the region with other region related directives.

The region manages the **contiguous memory area** which starts at starting\_address and is length bytes long. The memory area shall be large enough to contain some internal region administration data.

The **starting address** and **length of segments** allocated from the region will be an integral multiple of page\_size. The specified page size will be aligned to an implementation-dependent minimum alignment if necessary.

The **attribute set** specified in attribute\_set is built through a *bitwise or* of the attribute constants described below. Not all combinations of attributes are allowed. Some attributes are mutually exclusive. If mutually exclusive attributes are combined, the behaviour is undefined. Attributes not mentioned below are not evaluated by this directive and have no effect. Default attributes can be selected by using the RTEMS\_DEFAULT\_ATTRIBUTES constant.

The **task wait queue discipline** is selected by the mutually exclusive RTEMS\_FIFO and RTEMS\_PRIORITY attributes. The discipline defines the order in which tasks wait for allocatable segments on a currently empty region.

- The **FIFO discipline** is the default and can be emphasized through use of the RTEMS\_FIFO attribute.
- The **priority discipline** is selected by the RTEMS\_PRIORITY attribute.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_NAME**

The name parameter was invalid.

#### **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ADDRESS**

The starting\_address parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_TOO\_MANY**

There was no inactive object available to create a region. The number of regions available to the application is configured through the *[CONFIGURE\\_MAXIMUM\\_REGIONS](#page-648-0)* (page 621) application configuration option.

#### **RTEMS\_INVALID\_SIZE**

The page\_size parameter was invalid.

#### **RTEMS\_INVALID\_SIZE**

The memory area specified in starting\_address and length was too small.

#### NOTES:

For control and maintenance of the region, RTEMS allocates a *[RNCB](#page-1073-2)* from the local RNCB free pool and initializes it.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- The number of regions available to the application is configured through the *[CONFIG-](#page-648-0)[URE\\_MAXIMUM\\_REGIONS](#page-648-0)* (page 621) application configuration option.
- Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace.

19.4. Directives 441

## <span id="page-469-1"></span><span id="page-469-0"></span>19.4.2 rtems\_region\_ident()

Identifies a region by the object name.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_region_ident( rtems_name name, rtems_id *id );
```

#### PARAMETERS:

#### **name**

This parameter is the object name to look up.

#### **id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the object identifier of an object with the specified name will be stored in this object.

#### DESCRIPTION:

This directive obtains a region identifier associated with the region name specified in name.

#### RETURN VALUES:

### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_NAME**

The name parameter was 0.

#### **RTEMS\_INVALID\_NAME**

There was no object with the specified name on the local node.

#### NOTES:

If the region name is not unique, then the region identifier will match the first region with that name in the search order. However, this region identifier is not guaranteed to correspond to the desired region.

The objects are searched from lowest to the highest index. Only the local node is searched.

The region identifier is used with other region related directives to access the region.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-470-1"></span><span id="page-470-0"></span>19.4.3 rtems\_region\_delete()

Deletes the region.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_region_delete( rtems_id id );
```

#### PARAMETERS:

## **id**

This parameter is the region identifier.

#### DESCRIPTION:

This directive deletes the region specified by id.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no region associated with the identifier specified by id.

## **RTEMS\_RESOURCE\_IN\_USE**

There were segments of the region still in use.

## NOTES:

The region cannot be deleted if any of its segments are still allocated.

The *[RNCB](#page-1073-2)* for the deleted region is reclaimed by RTEMS.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- The calling task does not have to be the task that created the object. Any local task that knows the object identifier can delete the object.
- Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace.

19.4. Directives 443

## <span id="page-471-1"></span><span id="page-471-0"></span>19.4.4 rtems\_region\_extend()

Extends the region.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_region_extend(
2 rtems_id id,
3 void *starting_address,
4 uintptr_t length
5 );
```

#### PARAMETERS:

#### **id**

This parameter is the region identifier.

#### **starting\_address**

This parameter is the starting address of the memory area to extend the region.

#### **length**

This parameter is the length in bytes of the memory area to extend the region.

#### DESCRIPTION:

This directive adds the memory area which starts at starting\_address for length bytes to the region specified by id.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The starting\_address parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no region associated with the identifier specified by id.

#### **RTEMS\_INVALID\_ADDRESS**

The memory area specified by starting\_address and length was insufficient to extend the heap.

#### NOTES:

There are no alignment requirements for the memory area. The memory area must be big enough to contain some maintenance blocks. It must not overlap parts of the current heap memory areas. Disconnected memory areas added to the heap will lead to used blocks which cover the gaps. Extending with an inappropriate memory area will corrupt the heap resulting in undefined behaviour.

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

19.4. Directives 445

## <span id="page-473-1"></span><span id="page-473-0"></span>19.4.5 rtems\_region\_get\_segment()

Gets a segment from the region.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_region_get_segment(
2 rtems_id id,
3 uintptr_t size,
4 rtems_option option_set,
5 rtems_interval timeout,
6 void **segment
7 );
```

## PARAMETERS:

#### **id**

This parameter is the region identifier.

#### **size**

This parameter is the size in bytes of the segment to allocate.

## **option\_set**

This parameter is the option set.

#### **timeout**

This parameter is the timeout in *[clock ticks](#page-1062-1)* if the RTEMS\_WAIT option is set. Use RTEMS\_NO\_TIMEOUT to wait potentially forever.

#### **segment**

This parameter is the pointer to a void pointer object. When the directive call is successful, the begin address of the allocated segment will be stored in this object.

## DESCRIPTION:

This directive gets a segment from the region specified by id.

The **option set** specified in option\_set is built through a *bitwise or* of the option constants described below. Not all combinations of options are allowed. Some options are mutually exclusive. If mutually exclusive options are combined, the behaviour is undefined. Options not mentioned below are not evaluated by this directive and have no effect. Default options can be selected by using the RTEMS\_DEFAULT\_OPTIONS constant.

The calling task can **wait** or **try to get** a segment from the region according to the mutually exclusive RTEMS\_WAIT and RTEMS\_NO\_WAIT options.

- **Waiting to get** a segment from the region is the default and can be emphasized through the use of the RTEMS\_WAIT option. The timeout parameter defines how long the calling task is willing to wait. Use RTEMS\_NO\_TIMEOUT to wait potentially forever, otherwise set a timeout interval in clock ticks.
- **Trying to get** a segment from the region is selected by the RTEMS\_NO\_WAIT option. If this option is defined, then the timeout parameter is ignored. When a segment from the region cannot be immediately allocated, then the RTEMS\_UNSATISFIED status is returned.

With either RTEMS\_WAIT or RTEMS\_NO\_WAIT if there is a segment of the requested size is available, then it is returned in segment and this directive returns immediately with the RTEMS\_SUCCESSFUL status code.

If the calling task chooses to return immediately and the region has no segment of the requested size available, then the directive returns immediately with the RTEMS\_UNSATISFIED status code. If the calling task chooses to wait for a segment, then the calling task is placed on the region wait queue and blocked. If the region was created with the RTEMS\_PRIORITY option specified, then the calling task is inserted into the wait queue according to its priority. But, if the region was created with the RTEMS\_FIFO option specified, then the calling task is placed at the rear of the wait queue.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The segment parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_SIZE**

The size parameter was zero.

#### **RTEMS\_INVALID\_ID**

There was no region associated with the identifier specified by id.

## **RTEMS\_INVALID\_SIZE**

The size parameter exceeded the maximum segment size which is possible for the region.

#### **RTEMS\_UNSATISFIED**

The region had no segment of the requested size immediately available.

#### **RTEMS\_TIMEOUT**

The timeout happened while the calling task was waiting to get a segment from the region.

#### NOTES:

The actual length of the allocated segment may be larger than the requested size because a segment size is always a multiple of the region's page size.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- When the request cannot be immediately satisfied and the RTEMS\_WAIT option is set, the calling task blocks at some point during the directive call.
- The timeout functionality of the directive requires a *[clock tick](#page-1062-1)*.

19.4. Directives 447

## <span id="page-475-1"></span><span id="page-475-0"></span>19.4.6 rtems\_region\_return\_segment()

Returns the segment to the region.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_region_return_segment( rtems_id id, void *segment );
```

### PARAMETERS:

## **id**

This parameter is the region identifier.

#### **segment**

This parameter is the begin address of the segment to return.

#### DESCRIPTION:

This directive returns the segment specified by segment to the region specified by id. The returned segment is merged with its neighbors to form the largest possible segment. The first task on the wait queue is examined to determine if its segment request can now be satisfied. If so, it is given a segment and unblocked. This process is repeated until the first task's segment request cannot be satisfied.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no region associated with the identifier specified by id.

#### **RTEMS\_INVALID\_ADDRESS**

The segment was not within the region.

#### NOTES:

This directive will cause the calling task to be preempted if one or more local tasks are waiting for a segment and the following conditions exist:

- A waiting task has a higher priority than the calling task.
- The size of the segment required by the waiting task is less than or equal to the size of the segment returned.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may unblock a task. This may cause the calling task to be preempted.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

<span id="page-476-1"></span><span id="page-476-0"></span>Changes the size of the segment.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_region_resize_segment(
2 rtems_id id,
3 void *segment,
4 uintptr_t size,
5 uintptr_t *old_size
6 );
```

#### PARAMETERS:

#### **id**

This parameter is the region identifier.

#### **segment**

This parameter is the begin address of the segment to resize.

#### **size**

This parameter is the requested new size of the segment.

#### **old\_size**

This parameter is the pointer to an [uintptr\\_t](https://en.cppreference.com/w/c/types/integer) object. When the directive call is successful, the old size of the segment will be stored in this object.

#### DESCRIPTION:

This directive is used to increase or decrease the size of the segment of the region specified by id. When increasing the size of a segment, it is possible that there is no memory available contiguous to the segment. In this case, the request is unsatisfied.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The old\_size parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no region associated with the identifier specified by id.

#### **RTEMS\_INVALID\_ADDRESS**

The segment was not within the region.

#### **RTEMS\_UNSATISFIED**

The region was unable to resize the segment.

19.4. Directives 449

#### NOTES:

If an attempt to increase the size of a segment fails, then the application may want to allocate a new segment of the desired size, copy the contents of the original segment to the new, larger segment and then return the original segment.

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

## <span id="page-478-1"></span><span id="page-478-0"></span>19.4.8 rtems\_region\_get\_information()

Gets the region information.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_region_get_information(
2 rtems_id id,
3 Heap_Information_block *the_info
4 );
```

#### PARAMETERS:

#### **id**

This parameter is the region identifier.

#### **the\_info**

This parameter is the pointer to a Heap\_Information\_block object. When the directive call is successful, the information of the region will be stored in this object.

#### DESCRIPTION:

This directive is used to obtain information about the used and free memory in the region specified by id. This is a snapshot at the time of the call. The information will be returned in the structure pointed to by the\_info.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The the\_info parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

## **RTEMS\_INVALID\_ID**

There was no region associated with the identifier specified by id.

## NOTES:

This is primarily intended as a mechanism to obtain diagnostic information. This directive performs an O(n) scan of the free and an O(n) scan of the used blocks in the region to calculate the information provided. Given that the execution time is driven by the number of used and free blocks, it can take a non-deterministic time to execute.

To get only the free information of the region use *[rtems\\_region\\_get\\_free\\_information\(\)](#page-479-0)* (page 452).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

19.4. Directives 451

## <span id="page-479-1"></span><span id="page-479-0"></span>19.4.9 rtems\_region\_get\_free\_information()

Gets the region free information.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_region_get_free_information(
2 rtems_id id,
3 Heap_Information_block *the_info
4 );
```

#### PARAMETERS:

#### **id**

This parameter is the region identifier.

#### **the\_info**

This parameter is the pointer to a Heap\_Information\_block object. When the directive call is successful, the free information of the region will be stored in this object.

#### DESCRIPTION:

This directive is used to obtain information about the free memory in the region specified by id. This is a snapshot at the time of the call. The information will be returned in the structure pointed to by the\_info.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The the\_info parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

## **RTEMS\_INVALID\_ID**

There was no region associated with the identifier specified by id.

## NOTES:

This directive uses the same structure to return information as the *[rtems\\_region\\_get\\_information\(\)](#page-478-0)* (page 451) directive but does not fill in the used information.

This is primarily intended as a mechanism to obtain diagnostic information. This directive performs an O(n) scan of the free blocks in the region to calculate the information provided. Given that the execution time is driven by the number of used and free blocks, it can take a non-deterministic time to execute. Typically, there are many used blocks and a much smaller number of free blocks making a call to this directive less expensive than a call to *[rtems\\_region\\_get\\_information\(\)](#page-478-0)* (page 451).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.

â€¢ The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

19.4. Directives 453

## <span id="page-481-1"></span><span id="page-481-0"></span>19.4.10 rtems\_region\_get\_segment\_size()

Gets the size of the region segment.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_region_get_segment_size(
2 rtems_id id,
3 void *segment,
4 uintptr_t *size
5 );
```

#### PARAMETERS:

#### **id**

This parameter is the region identifier.

#### **segment**

This parameter is the begin address of the segment.

#### **size**

This parameter is the pointer to a [uintptr\\_t](https://en.cppreference.com/w/c/types/integer) object. When the directive call is successful, the size of the segment in bytes will be stored in this object.

#### DESCRIPTION:

This directive obtains the size in bytes of the segment specified by segment of the region specified by id in size.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ADDRESS**

The segment parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ADDRESS**

The size parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no region associated with the identifier specified by id.

#### **RTEMS\_INVALID\_ADDRESS**

The segment was not within the region.

#### NOTES:

The actual length of the allocated segment may be larger than the requested size because a segment size is always a multiple of the region's page size.

### <span id="page-482-0"></span>CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

19.4. Directives 455

CHAPTER

**TWENTY**

# <span id="page-484-0"></span>DUAL-PORTED MEMORY MANAGER

# <span id="page-485-1"></span><span id="page-485-0"></span>20.1 Introduction

The Dual-Ported Memory Manager provides a mechanism for converting addresses between internal and external representations for multiple dual-ported memory areas (DPMA). The directives provided by the Dual-Ported Memory Manager are:

- *[rtems\\_port\\_create\(\)](#page-489-0)* (page 462) Creates a port.
- *[rtems\\_port\\_ident\(\)](#page-491-0)* (page 464) Identifies a port by the object name.
- *[rtems\\_port\\_delete\(\)](#page-492-0)* (page 465) Deletes the port.
- *[rtems\\_port\\_external\\_to\\_internal\(\)](#page-493-0)* (page 466) Converts the external address to the internal address.
- *[rtems\\_port\\_internal\\_to\\_external\(\)](#page-494-0)* (page 467) Converts the internal address to the external address.

# <span id="page-486-0"></span>20.2 Background

A dual-ported memory area (DPMA) is an contiguous block of RAM owned by a particular processor but which can be accessed by other processors in the system. The owner accesses the memory using internal addresses, while other processors must use external addresses. RTEMS defines a port as a particular mapping of internal and external addresses.

There are two system configurations in which dual-ported memory is commonly found. The first is tightly-coupled multiprocessor computer systems where the dual-ported memory is shared between all nodes and is used for inter-node communication. The second configuration is computer systems with intelligent peripheral controllers. These controllers typically utilize the DPMA for high-performance data transfers.

20.2. Background 459

# <span id="page-487-0"></span>20.3 Operations

## <span id="page-487-1"></span>20.3.1 Creating a Port

The rtems\_port\_create directive creates a port into a DPMA with the user-defined name. The user specifies the association between internal and external representations for the port being created. RTEMS allocates a Dual-Ported Memory Control Block (DPCB) from the DPCB free list to maintain the newly created DPMA. RTEMS also generates a unique dual-ported memory port ID which is returned to the calling task. RTEMS does not initialize the dual-ported memory area or access any memory within it.

## <span id="page-487-2"></span>20.3.2 Obtaining Port IDs

When a port is created, RTEMS generates a unique port ID and assigns it to the created port until it is deleted. The port ID may be obtained by either of two methods. First, as the result of an invocation of the``rtems\_port\_create`` directive, the task ID is stored in a user provided location. Second, the port ID may be obtained later using the rtems\_port\_ident directive. The port ID is used by other dual-ported memory manager directives to access this port.

## <span id="page-487-3"></span>20.3.3 Converting an Address

The rtems\_port\_external\_to\_internal directive is used to convert an address from external to internal representation for the specified port. The rtems\_port\_internal\_to\_external directive is used to convert an address from internal to external representation for the specified port. If an attempt is made to convert an address which lies outside the specified DPMA, then the address to be converted will be returned.

## <span id="page-487-4"></span>20.3.4 Deleting a DPMA Port

A port can be removed from the system and returned to RTEMS with the rtems\_port\_delete directive. When a port is deleted, its control block is returned to the DPCB free list.

# <span id="page-488-0"></span>20.4 Directives

This section details the directives of the Dual-Ported Memory Manager. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

20.4. Directives 461

## <span id="page-489-1"></span><span id="page-489-0"></span>20.4.1 rtems\_port\_create()

Creates a port.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_port_create(
2 rtems_name name,
3 void *internal_start,
4 void *external_start,
5 uint32_t length,
6 rtems_id *id
7 );
```

#### PARAMETERS:

#### **name**

This parameter is the object name of the port.

#### **internal\_start**

This parameter is the internal start address of the memory area.

## **external\_start**

This parameter is the external start address of the memory area.

## **length**

This parameter is the length in bytes of the memory area.

## **id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the identifier of the created port will be stored in this object.

## DESCRIPTION:

This directive creates a port which resides on the local node. The port has the user-defined object name specified in name. The assigned object identifier is returned in id. This identifier is used to access the port with other dual-ported memory port related directives.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_NAME**

The name parameter was invalid.

#### **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ADDRESS**

The internal\_start parameter was not properly aligned.

#### **RTEMS\_INVALID\_ADDRESS**

The external\_start parameter was not properly aligned.

#### **RTEMS\_TOO\_MANY**

There was no inactive object available to create a port. The number of port available to the

#### NOTES:

The internal\_start and external\_start parameters must be on a boundary defined by the target processor architecture.

For control and maintenance of the port, RTEMS allocates a *[DPCB](#page-1063-1)* from the local DPCB free pool and initializes it.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- The number of ports available to the application is configured through the *[CONFIG-](#page-647-0)[URE\\_MAXIMUM\\_PORTS](#page-647-0)* (page 620) application configuration option.
- Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace.

20.4. Directives 463

## <span id="page-491-1"></span><span id="page-491-0"></span>20.4.2 rtems\_port\_ident()

Identifies a port by the object name.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_port_ident( rtems_name name, rtems_id *id );
```

#### PARAMETERS:

#### **name**

This parameter is the object name to look up.

#### **id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the object identifier of an object with the specified name will be stored in this object.

#### DESCRIPTION:

This directive obtains a port identifier associated with the port name specified in name.

#### RETURN VALUES:

### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_NAME**

The name parameter was 0.

#### **RTEMS\_INVALID\_NAME**

There was no object with the specified name on the local node.

#### NOTES:

If the port name is not unique, then the port identifier will match the first port with that name in the search order. However, this port identifier is not guaranteed to correspond to the desired port.

The objects are searched from lowest to the highest index. Only the local node is searched.

The port identifier is used with other dual-ported memory related directives to access the port.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-492-1"></span><span id="page-492-0"></span>20.4.3 rtems\_port\_delete()

Deletes the port.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_port_delete( rtems_id id );
```

#### PARAMETERS:

## **id**

This parameter is the port identifier.

#### DESCRIPTION:

This directive deletes the port specified by id.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no port associated with the identifier specified by id.

#### NOTES:

The *[DPCB](#page-1063-1)* for the deleted port is reclaimed by RTEMS.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- The calling task does not have to be the task that created the object. Any local task that knows the object identifier can delete the object.
- Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace.

20.4. Directives 465

## <span id="page-493-1"></span><span id="page-493-0"></span>20.4.4 rtems\_port\_external\_to\_internal()

Converts the external address to the internal address.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_port_external_to_internal(
2 rtems_id id,
3 void *external,
4 void **internal
5 );
```

#### PARAMETERS:

#### **id**

This parameter is the port identifier.

#### **external**

This parameter is the external address to convert.

#### **internal**

This parameter is the pointer to a void pointer object. When the directive call is successful, the external address associated with the internal address will be stored in this object.

#### DESCRIPTION:

This directive converts a dual-ported memory address from external to internal representation for the specified port. If the given external address is invalid for the specified port, then the internal address is set to the given external address.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_NAME**

The id parameter was invalid.

#### **RTEMS\_INVALID\_ADDRESS**

The internal parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

## <span id="page-494-1"></span><span id="page-494-0"></span>20.4.5 rtems\_port\_internal\_to\_external()

Converts the internal address to the external address.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_port_internal_to_external(
2 rtems_id id,
3 void *internal,
4 void **external
5 );
```

#### PARAMETERS:

#### **id**

This parameter is the port identifier.

#### **internal**

This parameter is the internal address to convert.

#### **external**

This parameter is the pointer to a void pointer object. When the directive call is successful, the external address associated with the internal address will be stored in this object.

#### DESCRIPTION:

This directive converts a dual-ported memory address from internal to external representation so that it can be passed to owner of the DPMA represented by the specified port. If the given internal address is an invalid dual-ported address, then the external address is set to the given internal address.

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_NAME**

The id parameter was invalid.

#### **RTEMS\_INVALID\_ADDRESS**

The external parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive will not cause the calling task to be preempted.

20.4. Directives 467

CHAPTER

# **TWENTYONE**

# <span id="page-496-0"></span>I/O MANAGER

# <span id="page-497-0"></span>21.1 Introduction

The Input/Output (I/O) Manager provides a well-defined mechanism for accessing device drivers and a structured methodology for organizing device drivers. The directives provided by the I/O Manager are:

- *[rtems\\_io\\_register\\_driver\(\)](#page-503-0)* (page 476) Registers and initializes the device with the specified device driver address table and device major number in the Device Driver Table.
- *[rtems\\_io\\_unregister\\_driver\(\)](#page-505-0)* (page 478) Removes a device driver specified by the device major number from the Device Driver Table.
- *[rtems\\_io\\_initialize\(\)](#page-506-0)* (page 479) Initializes the device specified by the device major and minor numbers.
- *[rtems\\_io\\_register\\_name\(\)](#page-507-0)* (page 480) Registers the device specified by the device major and minor numbers in the file system under the specified name.
- *[rtems\\_io\\_open\(\)](#page-508-0)* (page 481) Opens the device specified by the device major and minor numbers.
- *[rtems\\_io\\_close\(\)](#page-509-0)* (page 482) Closes the device specified by the device major and minor numbers.
- *[rtems\\_io\\_read\(\)](#page-510-0)* (page 483) Reads from the device specified by the device major and minor numbers.
- *[rtems\\_io\\_write\(\)](#page-511-0)* (page 484) Writes to the device specified by the device major and minor numbers.
- *[rtems\\_io\\_control\(\)](#page-512-0)* (page 485) Controls the device specified by the device major and minor numbers.

# <span id="page-498-5"></span><span id="page-498-0"></span>21.2 Background

## <span id="page-498-1"></span>21.2.1 Device Driver Table

Each application utilizing the RTEMS I/O manager must specify the address of a Device Driver Table in its Configuration Table. This table contains each device driver's entry points that is to be initialised by RTEMS during initialization. Each device driver may contain the following entry points:

- Initialization
- Open
- Close
- Read
- Write
- Control

If the device driver does not support a particular entry point, then that entry in the Configuration Table should be NULL. RTEMS will return RTEMS\_SUCCESSFUL as the executive's and zero (0) as the device driver's return code for these device driver entry points.

Applications can register and unregister drivers with the RTEMS I/O manager avoiding the need to have all drivers statically defined and linked into this table.

The confdefs.h entry CONFIGURE\_MAXIMUM\_DRIVERS configures the number of driver slots available to the application.

## <span id="page-498-2"></span>21.2.2 Major and Minor Device Numbers

Each call to the I/O manager must provide a device's major and minor numbers as arguments. The major number is the index of the requested driver's entry points in the Device Driver Table, and is used to select a specific device driver. The exact usage of the minor number is driver specific, but is commonly used to distinguish between a number of devices controlled by the same driver.

The data types rtems\_device\_major\_number and rtems\_device\_minor\_number are used to manipulate device major and minor numbers, respectively.

## <span id="page-498-3"></span>21.2.3 Device Names

The I/O Manager provides facilities to associate a name with a particular device. Directives are provided to register the name of a device and to look up the major/minor number pair associated with a device name.

## <span id="page-498-4"></span>21.2.4 Device Driver Environment

Application developers, as well as device driver developers, must be aware of the following regarding the RTEMS I/O Manager:

- A device driver routine executes in the context of the invoking task. Thus if the driver blocks, the invoking task blocks.
- The device driver is free to change the modes of the invoking task, although the driver should restore them to their original values.

21.2. Background 471

- <span id="page-499-3"></span>â€¢ Device drivers may be invoked from ISRs.
- Only local device drivers are accessible through the I/O manager.
- A device driver routine may invoke all other RTEMS directives, including I/O directives, on both local and global objects.

Although the RTEMS I/O manager provides a framework for device drivers, it makes no assumptions regarding the construction or operation of a device driver.

## <span id="page-499-0"></span>21.2.5 Runtime Driver Registration

Board support package and application developers can select wether a device driver is statically entered into the default device table or registered at runtime.

Dynamic registration helps applications where:

- The BSP and kernel libraries are common to a range of applications for a specific target platform. An application may be built upon a common library with all drivers. The application selects and registers the drivers. Uniform driver name lookup protects the application.
- The type and range of drivers may vary as the application probes a bus during initialization.
- Support for hot swap bus system such as Compact PCI.
- Support for runtime loadable driver modules.

## <span id="page-499-1"></span>21.2.6 Device Driver Interface

When an application invokes an I/O manager directive, RTEMS determines which device driver entry point must be invoked. The information passed by the application to RTEMS is then passed to the correct device driver entry point. RTEMS will invoke each device driver entry point assuming it is compatible with the following prototype:

```
1 rtems_device_driver io_entry(
2 rtems_device_major_number major,
3 rtems_device_minor_number minor,
4 void *argument_block
5 );
```

The format and contents of the parameter block are device driver and entry point dependent.

It is recommended that a device driver avoid generating error codes which conflict with those used by application components. A common technique used to generate driver specific error codes is to make the most significant part of the status indicate a driver specific code.

## <span id="page-499-2"></span>21.2.7 Device Driver Initialization

RTEMS automatically initializes all device drivers when multitasking is initiated via the rtems\_initialize\_executive directive. RTEMS initializes the device drivers by invoking each device driver initialization entry point with the following parameters:

#### **major**

the major device number for this device driver.

#### **minor**

zero.

#### **argument\_block**

will point to the Configuration Table.

The returned status will be ignored by RTEMS. If the driver cannot successfully initialize the device, then it should invoke the fatal\_error\_occurred directive.

21.2. Background 473

# <span id="page-501-0"></span>21.3 Operations

## <span id="page-501-1"></span>21.3.1 Register and Lookup Name

The rtems\_io\_register directive associates a name with the specified device (i.e. major/minor number pair). Device names are typically registered as part of the device driver initialization sequence. The rtems\_io\_lookup directive is used to determine the major/minor number pair associated with the specified device name. The use of these directives frees the application from being dependent on the arbitrary assignment of major numbers in a particular application. No device naming conventions are dictated by RTEMS.

## <span id="page-501-2"></span>21.3.2 Accessing an Device Driver

The I/O manager provides directives which enable the application program to utilize device drivers in a standard manner. There is a direct correlation between the RTEMS I/O manager directives rtems\_io\_initialize, rtems\_io\_open, rtems\_io\_close, rtems\_io\_read, rtems\_io\_write, and rtems\_io\_control and the underlying device driver entry points.

# <span id="page-502-0"></span>21.4 Directives

This section details the directives of the I/O Manager. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

21.4. Directives 475

## <span id="page-503-1"></span><span id="page-503-0"></span>21.4.1 rtems\_io\_register\_driver()

Registers and initializes the device with the specified device driver address table and device major number in the Device Driver Table.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_io_register_driver(
2 rtems_device_major_number major,
3 const rtems_driver_address_table *driver_table,
4 rtems_device_major_number *registered_major
5 );
```

#### PARAMETERS:

#### **major**

This parameter is the device major number. Use a value of zero to let the system obtain a device major number automatically.

#### **driver\_table**

This parameter is the device driver address table.

#### **registered\_major**

This parameter is the pointer to an *[rtems\\_device\\_major\\_number](#page-66-3)* (page 39) object. When the directive call is successful, the device major number of the registered device will be stored in this object.

#### RETURN VALUES:

### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ADDRESS**

The device major number of the device was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ADDRESS**

The device driver address table was empty.

#### **RTEMS\_INVALID\_NUMBER**

The device major number of the device was out of range, see *[CONFIG-](#page-640-0)[URE\\_MAXIMUM\\_DRIVERS](#page-640-0)* (page 613).

#### **RTEMS\_TOO\_MANY**

The system was unable to obtain a device major number.

# **RTEMS\_RESOURCE\_IN\_USE**

The device major number was already in use.

#### **RTEMS\_CALLED\_FROM\_ISR**

The directive was called from interrupt context.

Other status codes may be returned by *[rtems\\_io\\_initialize\(\)](#page-506-0)* (page 479).

### NOTES:

If the device major number equals zero a device major number will be obtained. The device major number of the registered driver will be returned.

After a successful registration, the *[rtems\\_io\\_initialize\(\)](#page-506-0)* (page 479) directive will be called to initialize the device.

21.4. Directives 477

## <span id="page-505-1"></span><span id="page-505-0"></span>21.4.2 rtems\_io\_unregister\_driver()

Removes a device driver specified by the device major number from the Device Driver Table.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_io_unregister_driver(
2 rtems_device_major_number major
3 );
```

#### PARAMETERS:

#### **major**

This parameter is the major number of the device.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_UNSATISFIED**

The device major number was invalid.

## **RTEMS\_CALLED\_FROM\_ISR**

The directive was called from interrupt context.

## NOTES:

Currently no specific checks are made and the driver is not closed.

## <span id="page-506-1"></span><span id="page-506-0"></span>21.4.3 rtems\_io\_initialize()

Initializes the device specified by the device major and minor numbers.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_io_initialize(
2 rtems_device_major_number major,
3 rtems_device_minor_number minor,
4 void *argument
5 );
```

#### PARAMETERS:

#### **major**

This parameter is the major number of the device.

#### **minor**

This parameter is the minor number of the device.

#### **argument**

This parameter is the argument passed to the device driver initialization entry.

## DESCRIPTION:

This directive calls the device driver initialization entry registered in the Device Driver Table for the specified device major number.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_NUMBER**

The device major number was invalid.

Other status codes may be returned by the device driver initialization entry.

## NOTES:

This directive is automatically invoked for each device driver defined by the application configuration during the system initialization and via the *[rtems\\_io\\_register\\_driver\(\)](#page-503-0)* (page 476) directive.

A device driver initialization entry is responsible for initializing all hardware and data structures associated with a device. If necessary, it can allocate memory to be used during other operations.

21.4. Directives 479

## <span id="page-507-1"></span><span id="page-507-0"></span>21.4.4 rtems\_io\_register\_name()

Registers the device specified by the device major and minor numbers in the file system under the specified name.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_io_register_name(
2 const char *device_name,
3 rtems_device_major_number major,
4 rtems_device_minor_number minor
5 );
```

#### PARAMETERS:

#### **device\_name**

This parameter is the device name in the file system.

#### **major**

This parameter is the device major number.

#### **minor**

This parameter is the device minor number.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_TOO\_MANY**

The name was already in use or other errors occurred.

#### NOTES:

The device is registered as a character device.

## <span id="page-508-1"></span><span id="page-508-0"></span>21.4.5 rtems\_io\_open()

Opens the device specified by the device major and minor numbers.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_io_open(
2 rtems_device_major_number major,
3 rtems_device_minor_number minor,
4 void *argument
5 );
```

#### PARAMETERS:

#### **major**

This parameter is the major number of the device.

#### **minor**

This parameter is the minor number of the device.

#### **argument**

This parameter is the argument passed to the device driver close entry.

## DESCRIPTION:

This directive calls the device driver open entry registered in the Device Driver Table for the specified device major number.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_NUMBER**

The device major number was invalid.

Other status codes may be returned by the device driver open entry.

## NOTES:

The open entry point is commonly used by device drivers to provide exclusive access to a device.

21.4. Directives 481

## <span id="page-509-1"></span><span id="page-509-0"></span>21.4.6 rtems\_io\_close()

Closes the device specified by the device major and minor numbers.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_io_close(
2 rtems_device_major_number major,
3 rtems_device_minor_number minor,
4 void *argument
5 );
```

#### PARAMETERS:

#### **major**

This parameter is the major number of the device.

#### **minor**

This parameter is the minor number of the device.

#### **argument**

This parameter is the argument passed to the device driver close entry.

#### DESCRIPTION:

This directive calls the device driver close entry registered in the Device Driver Table for the specified device major number.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_NUMBER**

The device major number was invalid.

Other status codes may be returned by the device driver close entry.

## NOTES:

The close entry point is commonly used by device drivers to relinquish exclusive access to a device.

## <span id="page-510-1"></span><span id="page-510-0"></span>21.4.7 rtems\_io\_read()

Reads from the device specified by the device major and minor numbers.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_io_read(
2 rtems_device_major_number major,
3 rtems_device_minor_number minor,
4 void *argument
5 );
```

#### PARAMETERS:

#### **major**

This parameter is the major number of the device.

#### **minor**

This parameter is the minor number of the device.

#### **argument**

This parameter is the argument passed to the device driver read entry.

## DESCRIPTION:

This directive calls the device driver read entry registered in the Device Driver Table for the specified device major number.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_NUMBER**

The device major number was invalid.

Other status codes may be returned by the device driver read entry.

## NOTES:

Read operations typically require a buffer address as part of the argument parameter block. The contents of this buffer will be replaced with data from the device.

21.4. Directives 483

## <span id="page-511-1"></span><span id="page-511-0"></span>21.4.8 rtems\_io\_write()

Writes to the device specified by the device major and minor numbers.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_io_write(
2 rtems_device_major_number major,
3 rtems_device_minor_number minor,
4 void *argument
5 );
```

#### PARAMETERS:

#### **major**

This parameter is the major number of the device.

#### **minor**

This parameter is the minor number of the device.

#### **argument**

This parameter is the argument passed to the device driver write entry.

## DESCRIPTION:

This directive calls the device driver write entry registered in the Device Driver Table for the specified device major number.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_NUMBER**

The device major number was invalid.

Other status codes may be returned by the device driver write entry.

## NOTES:

Write operations typically require a buffer address as part of the argument parameter block. The contents of this buffer will be sent to the device.

## <span id="page-512-1"></span><span id="page-512-0"></span>21.4.9 rtems\_io\_control()

Controls the device specified by the device major and minor numbers.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_io_control(
2 rtems_device_major_number major,
3 rtems_device_minor_number minor,
4 void *argument
5 );
```

#### PARAMETERS:

#### **major**

This parameter is the major number of the device.

#### **minor**

This parameter is the minor number of the device.

#### **argument**

This parameter is the argument passed to the device driver I/O control entry.

#### DESCRIPTION:

This directive calls the device driver I/O control entry registered in the Device Driver Table for the specified device major number.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_NUMBER**

The device major number was invalid.

Other status codes may be returned by the device driver I/O control entry.

## NOTES:

The exact functionality of the driver entry called by this directive is driver dependent. It should not be assumed that the control entries of two device drivers are compatible. For example, an RS-232 driver I/O control operation may change the baud of a serial line, while an I/O control operation for a floppy disk driver may cause a seek operation.

21.4. Directives 485

CHAPTER

# **TWENTYTWO**

# <span id="page-514-0"></span>KERNEL CHARACTER I/O SUPPORT

# <span id="page-515-0"></span>22.1 Introduction

The kernel character input/output support is an extension of the *[I/O Manager](#page-496-0)* (page 469) to output characters to the kernel character output device and receive characters from the kernel character input device using a polled and non-blocking implementation.

The directives may be used to print debug and test information. The kernel character input/output support should work even if no Console Driver is configured, see *[CONFIG-](#page-626-0)[URE\\_APPLICATION\\_NEEDS\\_CONSOLE\\_DRIVER](#page-626-0)* (page 599). The kernel character input and output device is provided by the *[BSP](#page-1061-0)*. Applications may change the device. The directives provided by the Kernel Character I/O Support are:

- *[rtems\\_putc\(\)](#page-517-0)* (page 490) Outputs the character to the kernel character output device.
- *[rtems\\_put\\_char\(\)](#page-518-0)* (page 491) Puts the character using *[rtems\\_putc\(\)](#page-517-0)* (page 490)
- *[putk\(\)](#page-519-0)* (page 492) Outputs the characters of the string and a newline character to the kernel character output device.
- *[printk\(\)](#page-520-0)* (page 493) Outputs the characters defined by the format string and the arguments to the kernel character output device.
- *[vprintk\(\)](#page-521-0)* (page 494) Outputs the characters defined by the format string and the variable argument list to the kernel character output device.
- *[rtems\\_printk\\_printer\(\)](#page-522-0)* (page 495) Outputs the characters defined by the format string and the variable argument list to the kernel character output device.
- *[getchark\(\)](#page-523-0)* (page 496) Tries to dequeue a character from the kernel character input device.

# <span id="page-516-0"></span>22.2 Directives

This section details the directives of the Kernel Character I/O Support. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

22.2. Directives 489

## <span id="page-517-1"></span><span id="page-517-0"></span>22.2.1 rtems\_putc()

Outputs the character to the kernel character output device.

## CALLING SEQUENCE:

```
1 void rtems_putc( char c );
```

### PARAMETERS:

**c**

This parameter is the character to output.

#### DESCRIPTION:

The directive outputs the character specified by c to the kernel character output device using the polled character output implementation provided by BSP\_output\_char. The directive performs a character translation from NL to CR followed by NR.

If the kernel character output device is concurrently accessed, then interleaved output may occur.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-518-1"></span><span id="page-518-0"></span>22.2.2 rtems\_put\_char()

Puts the character using *[rtems\\_putc\(\)](#page-517-0)* (page 490)

#### CALLING SEQUENCE:

```
1 void rtems_put_char( int c, void *unused );
```

### PARAMETERS:

**c**

This parameter is the character to output.

#### **unused**

This parameter is an unused argument.

#### NOTES:

The directive is provided to support the RTEMS Testing Framework.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

22.2. Directives 491

## <span id="page-519-1"></span><span id="page-519-0"></span>22.2.3 putk()

Outputs the characters of the string and a newline character to the kernel character output device.

#### CALLING SEQUENCE:

```
1 int putk( const char *s );
```

#### PARAMETERS:

**s**

This parameter is the string to output.

#### RETURN VALUES:

Returns the number of characters output to the kernel character output device.

## NOTES:

The directive may be used to print debug and test information. It uses *[rtems\\_putc\(\)](#page-517-0)* (page 490) to output the characters. This directive performs a character translation from NL to CR followed by NR.

If the kernel character output device is concurrently accessed, then interleaved output may occur.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-520-1"></span><span id="page-520-0"></span>22.2.4 printk()

Outputs the characters defined by the format string and the arguments to the kernel character output device.

#### CALLING SEQUENCE:

```
1 int printk( const char *fmt, ... );
```

#### PARAMETERS:

#### **fmt**

This parameter is a printf()-style format string.

**...**

This parameter is a list of optional parameters required by the format string.

## RETURN VALUES:

Returns the number of characters output to the kernel character output device.

## NOTES:

The directive may be used to print debug and test information. It uses *[rtems\\_putc\(\)](#page-517-0)* (page 490) to output the characters. This directive performs a character translation from NL to CR followed by NR.

If the kernel character output device is concurrently accessed, then interleaved output may occur.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- Formatting of floating point numbers is not supported.

22.2. Directives 493

## <span id="page-521-1"></span><span id="page-521-0"></span>22.2.5 vprintk()

Outputs the characters defined by the format string and the variable argument list to the kernel character output device.

### CALLING SEQUENCE:

```
1 int vprintk( const char *fmt, va_list ap );
```

#### PARAMETERS:

#### **fmt**

This parameter is a printf()-style format string.

**ap**

This parameter is the variable argument list required by the format string.

## RETURN VALUES:

Returns the number of characters output to the kernel character output device.

#### NOTES:

The directive may be used to print debug and test information. It uses *[rtems\\_putc\(\)](#page-517-0)* (page 490) to output the characters. This directive performs a character translation from NL to CR followed by NR.

If the kernel character output device is concurrently accessed, then interleaved output may occur.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- Formatting of floating point numbers is not supported.

## <span id="page-522-1"></span><span id="page-522-0"></span>22.2.6 rtems\_printk\_printer()

Outputs the characters defined by the format string and the variable argument list to the kernel character output device.

#### CALLING SEQUENCE:

```
1 int rtems_printk_printer( void *unused, const char *fmt, va_list ap );
```

#### PARAMETERS:

#### **unused**

This parameter is an unused argument.

#### **fmt**

This parameter is a printf()-style format string.

**ap**

This parameter is the variable argument list required by the format string.

#### RETURN VALUES:

Returns the number of characters output to the kernel character output device.

#### NOTES:

The directive may be used to print debug and test information. It uses *[rtems\\_putc\(\)](#page-517-0)* (page 490) to output the characters. This directive performs a character translation from NL to CR followed by NR.

If the kernel character output device is concurrently accessed, then interleaved output may occur.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.
- Formatting of floating point numbers is not supported.

22.2. Directives 495

## <span id="page-523-1"></span><span id="page-523-0"></span>22.2.7 getchark()

Tries to dequeue a character from the kernel character input device.

## CALLING SEQUENCE:

```
1 int getchark( void );
```

#### DESCRIPTION:

The directive tries to dequeue a character from the kernel character input device using the polled character input implementation referenced by BSP\_poll\_char if it is available.

#### RETURN VALUES:

**-1** The BSP\_poll\_char pointer was equal to [NULL.](https://en.cppreference.com/w/c/types/NULL)

**-1**

There was no character enqueued on the kernel character input device.

Returns the character least recently enqueued on the kernel character input device as an unsigned character value.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

CHAPTER

# **TWENTYTHREE**

# <span id="page-524-0"></span>CACHE MANAGER

# <span id="page-525-0"></span>23.1 Introduction

The Cache Manager provides functions to perform maintenance operations for data and instruction caches.

The actual actions of the Cache Manager operations depend on the hardware and the implementation provided by the CPU architecture port or a board support package. Cache implementations tend to be highly hardware dependent. The directives provided by the Cache Manager are:

- *[rtems\\_cache\\_flush\\_multiple\\_data\\_lines\(\)](#page-527-0)* (page 500) Flushes the data cache lines covering the memory area.
- *[rtems\\_cache\\_invalidate\\_multiple\\_data\\_lines\(\)](#page-528-0)* (page 501) Invalidates the data cache lines covering the memory area.
- *[rtems\\_cache\\_invalidate\\_multiple\\_instruction\\_lines\(\)](#page-529-0)* (page 502) Invalidates the instruction cache lines covering the memory area.
- *[rtems\\_cache\\_instruction\\_sync\\_after\\_code\\_change\(\)](#page-530-0)* (page 503) Ensures necessary synchronization required after code changes.
- *[rtems\\_cache\\_get\\_maximal\\_line\\_size\(\)](#page-531-0)* (page 504) Gets the maximal cache line size in bytes of all caches (data, instruction, or unified).
- *[rtems\\_cache\\_get\\_data\\_line\\_size\(\)](#page-532-0)* (page 505) Gets the data cache line size in bytes.
- *[rtems\\_cache\\_get\\_instruction\\_line\\_size\(\)](#page-533-0)* (page 506) Gets the instruction cache line size in bytes.
- *[rtems\\_cache\\_get\\_data\\_cache\\_size\(\)](#page-534-0)* (page 507) Gets the data cache size in bytes for the cache level.
- *[rtems\\_cache\\_get\\_instruction\\_cache\\_size\(\)](#page-535-0)* (page 508) Gets the instruction cache size in bytes for the cache level.
- *[rtems\\_cache\\_flush\\_entire\\_data\(\)](#page-536-0)* (page 509) Flushes the entire data cache.
- *[rtems\\_cache\\_invalidate\\_entire\\_data\(\)](#page-537-0)* (page 510) Invalidates the entire data cache.
- *[rtems\\_cache\\_invalidate\\_entire\\_instruction\(\)](#page-538-0)* (page 511) Invalidates the entire instruction cache.
- *[rtems\\_cache\\_enable\\_data\(\)](#page-539-0)* (page 512) Enables the data cache.
- *[rtems\\_cache\\_disable\\_data\(\)](#page-540-0)* (page 513) Disables the data cache.
- *[rtems\\_cache\\_enable\\_instruction\(\)](#page-541-0)* (page 514) Enables the instruction cache.
- *[rtems\\_cache\\_disable\\_instruction\(\)](#page-542-0)* (page 515) Disables the instruction cache.
- *[rtems\\_cache\\_aligned\\_malloc\(\)](#page-543-0)* (page 516) Allocates memory from the C Program Heap which begins at a cache line boundary.

# <span id="page-526-0"></span>23.2 Directives

This section details the directives of the Cache Manager. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

23.2. Directives 499

## <span id="page-527-1"></span><span id="page-527-0"></span>23.2.1 rtems\_cache\_flush\_multiple\_data\_lines()

Flushes the data cache lines covering the memory area.

#### CALLING SEQUENCE:

```
1 void rtems_cache_flush_multiple_data_lines( const void *begin, size_t size );
```

### PARAMETERS:

#### **begin**

This parameter is the begin address of the memory area to flush.

#### **size**

This parameter is the size in bytes of the memory area to flush.

#### DESCRIPTION:

Dirty data cache lines covering the area are transfered to memory. Depending on the cache implementation this may mark the lines as invalid.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-528-1"></span><span id="page-528-0"></span>23.2.2 rtems\_cache\_invalidate\_multiple\_data\_lines()

Invalidates the data cache lines covering the memory area.

#### CALLING SEQUENCE:

```
1 void rtems_cache_invalidate_multiple_data_lines(
2 const void *begin,
3 size_t size
4 );
```

#### PARAMETERS:

#### **begin**

This parameter is the begin address of the memory area to invalidate.

#### **size**

This parameter is the size in bytes of the memory area to invalidate.

## DESCRIPTION:

The cache lines covering the area are marked as invalid. A later read access in the area will load the data from memory.

#### NOTES:

In case the area is not aligned on cache line boundaries, then this operation may destroy unrelated data.

On some systems, the cache lines may be flushed before they are invalidated.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

23.2. Directives 501

## <span id="page-529-1"></span><span id="page-529-0"></span>23.2.3 rtems\_cache\_invalidate\_multiple\_instruction\_lines()

Invalidates the instruction cache lines covering the memory area.

#### CALLING SEQUENCE:

```
1 void rtems_cache_invalidate_multiple_instruction_lines(
2 const void *begin,
3 size_t size
4 );
```

#### PARAMETERS:

#### **begin**

This parameter is the begin address of the memory area to invalidate.

#### **size**

This parameter is the size in bytes of the memory area to invalidate.

#### DESCRIPTION:

The cache lines covering the area are marked as invalid. A later instruction fetch from the area will result in a load from memory.

#### NOTES:

In SMP configurations, on processors without instruction cache snooping, this operation will invalidate the instruction cache lines on all processors.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-530-1"></span><span id="page-530-0"></span>23.2.4 rtems\_cache\_instruction\_sync\_after\_code\_change()

Ensures necessary synchronization required after code changes.

#### CALLING SEQUENCE:

```
1 void rtems_cache_instruction_sync_after_code_change(
2 const void *begin,
3 size_t size
4 );
```

#### PARAMETERS:

#### **begin**

This parameter is the begin address of the code area to synchronize.

#### **size**

This parameter is the size in bytes of the code area to synchronize.

#### NOTES:

When code is loaded or modified, then most systems require synchronization instructions to update the instruction caches so that the loaded or modified code is fetched. For example, systems with separate data and instruction caches or systems without instruction cache snooping. The directives should be used by run time loader for example.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

23.2. Directives 503

## <span id="page-531-1"></span><span id="page-531-0"></span>23.2.5 rtems\_cache\_get\_maximal\_line\_size()

Gets the maximal cache line size in bytes of all caches (data, instruction, or unified).

#### CALLING SEQUENCE:

```
1 size_t rtems_cache_get_maximal_line_size( void );
```

### RETURN VALUES:

**0**

There is no cache present.

Returns the maximal cache line size in bytes of all caches (data, instruction, or unified).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-532-1"></span><span id="page-532-0"></span>23.2.6 rtems\_cache\_get\_data\_line\_size()

Gets the data cache line size in bytes.

## CALLING SEQUENCE:

```
1 size_t rtems_cache_get_data_line_size( void );
```

#### RETURN VALUES:

**0**

There is no data cache present.

Returns the data cache line size in bytes. For multi-level caches this is the maximum of the cache line sizes of all levels.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

23.2. Directives 505

## <span id="page-533-1"></span><span id="page-533-0"></span>23.2.7 rtems\_cache\_get\_instruction\_line\_size()

Gets the instruction cache line size in bytes.

## CALLING SEQUENCE:

```
1 size_t rtems_cache_get_instruction_line_size( void );
```

### RETURN VALUES:

**0**

There is no instruction cache present.

Returns the instruction cache line size in bytes. For multi-level caches this is the maximum of the cache line sizes of all levels.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

<span id="page-534-1"></span><span id="page-534-0"></span>Gets the data cache size in bytes for the cache level.

## CALLING SEQUENCE:

```
1 size_t rtems_cache_get_data_cache_size( uint32_t level );
```

#### PARAMETERS:

## **level**

This parameter is the requested data cache level. The cache level zero specifies the entire data cache.

#### RETURN VALUES:

**0**

There is no data cache present at the requested cache level.

Returns the data cache size in bytes of the requested cache level.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

23.2. Directives 507

## <span id="page-535-1"></span><span id="page-535-0"></span>23.2.9 rtems\_cache\_get\_instruction\_cache\_size()

Gets the instruction cache size in bytes for the cache level.

#### CALLING SEQUENCE:

```
1 size_t rtems_cache_get_instruction_cache_size( uint32_t level );
```

#### PARAMETERS:

## **level**

This parameter is the requested instruction cache level. The cache level zero specifies the entire instruction cache.

#### RETURN VALUES:

**0**

There is no instruction cache present at the requested cache level.

Returns the instruction cache size in bytes of the requested cache level.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

<span id="page-536-1"></span><span id="page-536-0"></span>23.2.10 rtems\_cache\_flush\_entire\_data()

Flushes the entire data cache.

## CALLING SEQUENCE:

```
1 void rtems_cache_flush_entire_data( void );
```

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

23.2. Directives 509

<span id="page-537-1"></span><span id="page-537-0"></span>23.2.11 rtems\_cache\_invalidate\_entire\_data()

Invalidates the entire data cache.

## CALLING SEQUENCE:

```
1 void rtems_cache_invalidate_entire_data( void );
```

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

<span id="page-538-1"></span><span id="page-538-0"></span>23.2.12 rtems\_cache\_invalidate\_entire\_instruction()

Invalidates the entire instruction cache.

#### CALLING SEQUENCE:

```
1 void rtems_cache_invalidate_entire_instruction( void );
```

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

23.2. Directives 511

<span id="page-539-1"></span><span id="page-539-0"></span>23.2.13 rtems\_cache\_enable\_data()

Enables the data cache.

## CALLING SEQUENCE:

```
1 void rtems_cache_enable_data( void );
```

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

<span id="page-540-1"></span><span id="page-540-0"></span>23.2.14 rtems\_cache\_disable\_data()

Disables the data cache.

## CALLING SEQUENCE:

```
1 void rtems_cache_disable_data( void );
```

#### NOTES:

On some *[targets](#page-1076-0)* or configurations, calling this directive may cause a fatal error with a fatal source of *[INTERNAL\\_ERROR\\_CORE](#page-547-0)* (page 520) and fatal code of *[INTER-](#page-548-0)[NAL\\_ERROR\\_CANNOT\\_DISABLE\\_DATA\\_CACHE](#page-548-0)* (page 521). The data cache may be necessary to provide *[atomic operations](#page-1060-3)*. In SMP configurations, the data cache may be required to ensure data coherency. See the BSP documentation in the *RTEMS User Manual* for more information.

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

23.2. Directives 513

<span id="page-541-1"></span><span id="page-541-0"></span>23.2.15 rtems\_cache\_enable\_instruction()

Enables the instruction cache.

#### CALLING SEQUENCE:

```
1 void rtems_cache_enable_instruction( void );
```

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-542-1"></span><span id="page-542-0"></span>23.2.16 rtems\_cache\_disable\_instruction()

Disables the instruction cache.

## CALLING SEQUENCE:

```
1 void rtems_cache_disable_instruction( void );
```

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

23.2. Directives 515

## <span id="page-543-1"></span><span id="page-543-0"></span>23.2.17 rtems\_cache\_aligned\_malloc()

Allocates memory from the C Program Heap which begins at a cache line boundary.

#### CALLING SEQUENCE:

```
1 void *rtems_cache_aligned_malloc( size_t size );
```

#### PARAMETERS:

## **size**

This parameter is the size in bytes of the memory area to allocate.

#### RETURN VALUES:

#### **[NULL](https://en.cppreference.com/w/c/types/NULL)**

There is not enough memory available to satisfy the allocation request.

Returns the begin address of the allocated memory. The begin address is on a cache line boundary.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

CHAPTER

# **TWENTYFOUR**

# <span id="page-544-0"></span>FATAL ERROR MANAGER

# <span id="page-545-0"></span>24.1 Introduction

The Fatal Error Manager processes all fatal or irrecoverable errors and other sources of system termination (for example after exit()). Fatal errors are identified by the fatal source and code pair. The directives provided by the Fatal Error Manager are:

- *[rtems\\_fatal\(\)](#page-555-0)* (page 528) Invokes the fatal error handler.
- *[rtems\\_panic\(\)](#page-556-0)* (page 529) Prints the message and invokes the fatal error handler.
- *[rtems\\_shutdown\\_executive\(\)](#page-557-0)* (page 530) Invokes the fatal error handler.
- *[rtems\\_exception\\_frame\\_print\(\)](#page-558-0)* (page 531) Prints the exception frame.
- *[rtems\\_fatal\\_source\\_text\(\)](#page-559-0)* (page 532) Returns a descriptive text for the fatal source.
- *[rtems\\_internal\\_error\\_text\(\)](#page-560-0)* (page 533) Returns a descriptive text for the internal error code.
- *[rtems\\_fatal\\_error\\_occurred\(\)](#page-561-0)* (page 534) Invokes the fatal error handler.

# <span id="page-546-3"></span><span id="page-546-0"></span>24.2 Background

## <span id="page-546-1"></span>24.2.1 Overview

The fatal error manager is called upon detection of an irrecoverable error condition by either RTEMS or the application software. Fatal errors are also used in case it is difficult or impossible to return an error condition by other means, e.g. a return value of a directive call. Fatal errors can be detected from various sources, for example

- the executive (RTEMS),
- support libraries,
- user system code,
- user application code, and
- processor interrupts and exceptions (data abort, instruction prefetch errors, ECC errors, spurious interrupts, etc.).

RTEMS automatically invokes the fatal error manager upon detection of an error it considers to be fatal. Similarly, the user should invoke the fatal error manager upon detection of a fatal error.

Each *[user extensions](#page-1078-2)* set may include a fatal error handler. The fatal error handler in the *[initial](#page-1067-1) [extension sets](#page-1067-1)* can be used to provide access to debuggers and monitors which may be present on the target hardware. If any user-supplied fatal error handlers are installed, the fatal error manager will invoke them. Usually, the board support package provides a fatal error extension which resets the board. If no user handlers are configured or if all the user handler return control to the fatal error manager, then the CPU port provided idle loop executes.

## <span id="page-546-2"></span>24.2.2 System Termination Procedure

The \_Terminate() handler is invoked to terminate the system. It is called by all services which determine that a system termination is required. For example, it is called by all higher level directives which announce a fatal error, see *[Announcing a Fatal Error](#page-553-1)* (page 526).

The first action of the system termination handler is to disable maskable interrupts. This ensures that interrupts on this processor do not interfere with the system termination procedure. This reduces the likelihood to end up in a recursive system termination procedure.

The second action of the system termination handler is to call the fatal extensions of the *[user](#page-1078-2) [extensions](#page-1078-2)*.

The fatal extensions are called with three parameters:

- the *[fatal source](#page-547-0)* (page 520),
- a legacy parameter which is always set to false, and
- an error code with a fatal source dependent content.

The fatal extensions of the *[initial extension sets](#page-1067-1)* are invoked first. For them, the following execution environment is required

- a valid stack pointer and enough stack space,
- a valid code memory, and
- valid read-only data.

24.2. Background 519

In uniprocessor configurations, the read-write data (including .bss segment) is not required. In SMP configurations, however, the read-write data must have been initialized to determine the state of the other processors and request them to shut-down if necessary. The board support package (BSP) may install an initial extension that performs a system reset. See the BSP documentation in the *RTEMS User Manual* for more information how the system reset is done. The BSP provided fatal extension can be disabled by the *[CONFIGURE\\_DISABLE\\_BSP\\_SETTINGS](#page-597-0)* (page 570) application configuration option. It is recommended to provide an applicationspecific fatal extension using the *[CONFIGURE\\_INITIAL\\_EXTENSIONS](#page-602-0)* (page 575) application configuration option.

In certain error conditions, it may be unreliable to carry out the following steps of the termination procedure since the read-write data may be corrupt. One of the fatal extensions of the initial extension set should reset the system to stop the system termination procedure.

After invoking the fatal extensions of the initial extension sets, the fatal extensions of the *[dy](#page-1063-2)[namic extension sets](#page-1063-2)* are invoked. For this procedure valid read-write data is required.

The last action of the system termination handler is to execute the CPU port provided idle loop with maskable interrupts disabled. Please note, that properly configured applications should not reach this point.

## <span id="page-547-0"></span>24.2.3 Fatal Sources

The following fatal sources are defined for RTEMS via the rtems\_fatal\_source enumeration. Each symbolic name has the corresponding numeric fatal source in parenthesis.

## **INTERNAL\_ERROR\_CORE (0)**

Errors of the core operating system. See *[Internal Error Codes](#page-548-0)* (page 521).

#### **INTERNAL\_ERROR\_RTEMS\_API (1)**

Errors of the Classic API.

### **INTERNAL\_ERROR\_POSIX\_API (2)**

Errors of the POSIX API.

#### **RTEMS\_FATAL\_SOURCE\_BDBUF (3)**

Fatal source for the block device cache. See rtems\_bdbuf\_fatal\_code.

#### **RTEMS\_FATAL\_SOURCE\_APPLICATION (4)**

Fatal source for application-specific errors. The fatal code is application-specific.

#### **RTEMS\_FATAL\_SOURCE\_EXIT (5)**

Fatal source of exit(). The fatal code is the exit() status code.

#### **RTEMS\_FATAL\_SOURCE\_BSP (6)**

Fatal source for BSP errors. The fatal codes are defined in <bsp/fatal.h>. Examples are interrupt and exception initialization. See bsp\_fatal\_code and bsp\_fatal().

#### **RTEMS\_FATAL\_SOURCE\_ASSERT (7)**

Fatal source of assert(). The fatal code is the pointer value of the assert context. See rtems\_assert\_context.

## **RTEMS\_FATAL\_SOURCE\_STACK\_CHECKER (8)**

Fatal source of the stack checker. The fatal code is the object name of the executing task.

## **RTEMS\_FATAL\_SOURCE\_EXCEPTION (9)**

Fatal source of the exceptions. The fatal code is the pointer value of the exception frame pointer. See rtems\_exception\_frame and rtems\_exception\_frame\_print.

### **RTEMS\_FATAL\_SOURCE\_SMP (10)**

Fatal source of SMP domain. See SMP\_Fatal\_code.

## **RTEMS\_FATAL\_SOURCE\_PANIC (11)**

Fatal source of rtems\_panic(), see rtems\_panic.

#### **RTEMS\_FATAL\_SOURCE\_INVALID\_HEAP\_FREE (12)**

Fatal source for invalid C program heap frees via free(). The fatal code is the bad pointer.

## **RTEMS\_FATAL\_SOURCE\_HEAP (13)**

Fatal source for heap errors. The fatal code is the address to a heap error context. See Heap\_Error\_context.

## <span id="page-548-0"></span>24.2.4 Internal Error Codes

The following error codes are defined for the INTERNAL\_ERROR\_CORE fatal source. Each symbolic name has the corresponding numeric error code in parenthesis.

#### **INTERNAL\_ERROR\_TOO\_LITTLE\_WORKSPACE (2)**

There is not enough memory for the workspace. This fatal error may occur during system initialization. It is an application configuration error.

## **INTERNAL\_ERROR\_THREAD\_EXITTED (5)**

A non-POSIX thread entry function returned. This is an API usage error.

An example code to provoke this fatal error is:

```
1 rtems_task task( rtems_task_argument arg )
2 {
3 /* Classic API tasks must not return */
4 }
5
6 void create_bad_task( void )
7 {
8 rtems_status_code sc;
9 rtems_id task_id;
10
11 sc = rtems_task_create(
12 rtems_build_name('T', 'A', 'S', 'K'),
13 1,
14 RTEMS_MINIMUM_STACK_SIZE,
15 RTEMS_DEFAULT_MODES,
16 RTEMS_DEFAULT_ATTRIBUTES,
17 &task_id
18 );
19 assert( sc == RTEMS_SUCCESSFUL );
20
21 sc = rtems_task_start( task_id, task, 0 );
22 assert( sc == RTEMS_SUCCESSFUL );
23 }
```

## **INTERNAL\_ERROR\_INCONSISTENT\_MP\_INFORMATION (6)**

This fatal error can only occur on MPCI configurations. The MPCI nodes or global objects configuration is inconsistent. This fatal error may occur during system initialization. It is an application configuration error.

24.2. Background 521

### **INTERNAL\_ERROR\_INVALID\_NODE (7)**

This fatal error can only occur on MPCI configurations. The own MPCI node number is invalid. This fatal error may occur during system initialization. It is an application configuration error.

#### **INTERNAL\_ERROR\_NO\_MPCI (8)**

This fatal error can only occur on MPCI configurations. There is no MPCI configuration table. This fatal error may occur during system initialization. It is an application configuration error.

#### **INTERNAL\_ERROR\_BAD\_PACKET (9)**

This fatal error can only occur on MPCI configurations. The MPCI server thread received a bad packet.

#### **INTERNAL\_ERROR\_OUT\_OF\_PACKETS (10)**

This fatal error can only occur on MPCI configurations. The MPCI packet pool is empty. It is an application configuration error.

#### **INTERNAL\_ERROR\_OUT\_OF\_GLOBAL\_OBJECTS (11)**

This fatal error can only occur on MPCI configurations. The MPCI global objects pool is empty. It is an application configuration error.

## **INTERNAL\_ERROR\_OUT\_OF\_PROXIES (12)**

This fatal error can only occur on MPCI configurations. The MPCI thread proxy pool is empty. It is an application configuration error.

## **INTERNAL\_ERROR\_INVALID\_GLOBAL\_ID (13)**

This fatal error can only occur on MPCI configurations. The system cannot find the global object for a specific object identifier. In case this happens, then this is probably an operating system bug.

#### **INTERNAL\_ERROR\_NO\_MEMORY\_FOR\_HEAP (23)**

There is not enough memory for the C program heap. This fatal error may occur during system initialization. It is an application configuration error.

#### **INTERNAL\_ERROR\_CPU\_ISR\_INSTALL\_VECTOR (24)**

The use of \_CPU\_ISR\_install\_vector() is illegal on this system.

#### **INTERNAL\_ERROR\_RESOURCE\_IN\_USE (25)**

This fatal error can only occur on debug configurations. It happens in case a thread which owns mutexes is deleted. Mutexes owned by a deleted thread are in an inconsistent state.

## **INTERNAL\_ERROR\_RTEMS\_INIT\_TASK\_ENTRY\_IS\_NULL (26)**

An RTEMS initialization task entry function is NULL. This fatal error may occur during system initialization. It is an application configuration error.

#### **INTERNAL\_ERROR\_THREAD\_QUEUE\_DEADLOCK (28)**

A deadlock was detected during a thread queue enqueue operation.

#### **INTERNAL\_ERROR\_THREAD\_QUEUE\_ENQUEUE\_STICKY\_FROM\_BAD\_STATE (29)**

This fatal error can only happen in SMP configurations. It is not allowed to obtain MrsP semaphores in a context with thread dispatching disabled, for example interrupt context.

An example code to provoke this fatal error is:

```
1 rtems_timer_service_routine bad( rtems_id timer_id, void *arg )
2 {
3 rtems_id *sem_id;
4
                                                                       (continues on next page)
```

(continued from previous page)

```
5 sem_id = arg;
6
7 rtems_semaphore_obtain( *sem_id, RTEMS_WAIT, RTEMS_NO_TIMEOUT );
8 assert( 0 );
9 }
10
11 rtems_task fire_bad_timer( rtems_task_argument arg )
12 {
13 rtems_status_code sc;
14 rtems_id sem_id;
15 rtems_id timer_id;
16
17 sc = rtems_semaphore_create(
18 rtems_build_name('M', 'R', 'S', 'P'),
19 1,
20 RTEMS_MULTIPROCESSOR_RESOURCE_SHARING
21 | RTEMS_BINARY_SEMAPHORE,
22 1,
23 &sem_id
24 );
25 assert( sc == RTEMS_SUCCESSFUL );
26
27 sc = rtems_timer_create(
28 rtems_build_name( 'E', 'V', 'I', 'L' ),
29 &timer_id
30 );
31 assert( sc == RTEMS_SUCCESSFUL );
32
33 sc = rtems_semaphore_obtain( sem_id, RTEMS_WAIT, RTEMS_NO_TIMEOUT );
34 assert( sc == RTEMS_SUCCESSFUL );
35
36 sc = rtems_timer_fire_after( timer_id, 1, bad, &sem_id );
37 assert( sc == RTEMS_SUCCESSFUL );
38
39 rtems_task_wake_after( 2 );
40 assert( 0 );
41 }
```

#### **INTERNAL\_ERROR\_BAD\_THREAD\_DISPATCH\_DISABLE\_LEVEL (30)**

It is illegal to call blocking operating system services with thread dispatching disabled, for example in interrupt context.

An example code to provoke this fatal error is:

```
1 void bad( rtems_id id, void *arg )
2 {
3 rtems_task_wake_after( RTEMS_YIELD_PROCESSOR );
4 assert( 0 );
5 }
6
                                                                      (continues on next page)
```

24.2. Background 523

(continued from previous page)

```
7 void fire_bad_timer( void )
8 {
9 rtems_status_code sc;
10 rtems_id id;
11
12 sc = rtems_timer_create(
13 rtems_build_name( 'E', 'V', 'I', 'L' ),
14 &id
15 );
16 assert( sc == RTEMS_SUCCESSFUL );
17
18 sc = rtems_timer_fire_after( id, 1, bad, NULL );
19 assert( sc == RTEMS_SUCCESSFUL );
20
21 rtems_task_wake_after( 2 );
22 assert( 0 );
23 }
```

#### **INTERNAL\_ERROR\_BAD\_THREAD\_DISPATCH\_ENVIRONMENT (31)**

In SMP configurations, it is a fatal error to call blocking operating system with interrupts disabled, since this prevents delivery of inter-processor interrupts. This could lead to executing threads which are not allowed to execute resulting in undefined system behaviour.

Some CPU ports, for example the ARM Cortex-M port, have a similar problem, since the interrupt state is not a part of the thread context.

This fatal error is detected in the operating system core function \_Thread\_Do\_dispatch() responsible to carry out a thread dispatch.

An example code to provoke this fatal error is:

```
1 void bad( void )
2 {
3 rtems_interrupt_level level;
4
5 rtems_interrupt_local_disable( level );
6 rtems_task_suspend( RTEMS_SELF );
7 rtems_interrupt_local_enable( level );
8 }
```

#### **INTERNAL\_ERROR\_RTEMS\_INIT\_TASK\_CREATE\_FAILED (32)**

The creation of the RTEMS initialization task failed. This fatal error may occur during system initialization. It is an application configuration error.

## **INTERNAL\_ERROR\_POSIX\_INIT\_THREAD\_CREATE\_FAILED (33)**

The creation of the POSIX initialization thread failed. This fatal error may occur during system initialization. It is an application configuration error.

#### **INTERNAL\_ERROR\_LIBIO\_STDOUT\_FD\_OPEN\_FAILED (36)**

Open of the standard output file descriptor failed or resulted in an unexpected file descriptor number. This fatal error may occur during system initialization. It is an application configuration error.

## **INTERNAL\_ERROR\_LIBIO\_STDERR\_FD\_OPEN\_FAILED (37)**

Open of the standard error file descriptor failed or resulted in an unexpected file descriptor number. This fatal error may occur during system initialization. It is an application configuration error.

#### **INTERNAL\_ERROR\_ILLEGAL\_USE\_OF\_FLOATING\_POINT\_UNIT (38)**

The floating point unit was used illegally, for example in interrupt context on some architectures.

#### **INTERNAL\_ERROR\_ARC4RANDOM\_GETENTROPY\_FAIL (39)**

A getentropy() system call failed in one of the [ARC4RANDOM\(3\)](https://man.openbsd.org/arc4random.3) functions. This fatal error can only be fixed with a different implementation of getentropy().

## **INTERNAL\_ERROR\_NO\_MEMORY\_FOR\_PER\_CPU\_DATA (40)**

This fatal error may happen during workspace initialization. There is not enough memory available to populate the per-CPU data areas, see [<rtems/score/percpudata.h>.](https://gitlab.rtems.org/rtems/rtos/rtems/-/blob/main/cpukit/include/rtems/score/percpudata.h)

#### **INTERNAL\_ERROR\_TOO\_LARGE\_TLS\_SIZE (41)**

This fatal error may happen during system initialization. The actual thread-local storage (TLS) size of the application exceeds the configured maximum, see *[CONFIG-](#page-607-0)[URE\\_MAXIMUM\\_THREAD\\_LOCAL\\_STORAGE\\_SIZE](#page-607-0)* (page 580). You can get the thread-local storage size of an application using the RTEMS tool rtems-execinfo.

## **INTERNAL\_ERROR\_RTEMS\_INIT\_TASK\_CONSTRUCT\_FAILED (42)**

The construction of the RTEMS initialization task failed. This fatal error may occur during system initialization. It is an application configuration error.

## **INTERNAL\_ERROR\_IDLE\_THREAD\_CREATE\_FAILED (43)**

The creation of an IDLE task failed. This fatal error may occur during system initialization. It happens if a task create extension fails for an IDLE task.

## **INTERNAL\_ERROR\_NO\_MEMORY\_FOR\_IDLE\_TASK\_STORAGE (44)**

There was not enough memory available to allocate an IDLE task stack. This fatal error may occur during system initialization. It is an application configuration error.

#### **INTERNAL\_ERROR\_IDLE\_THREAD\_STACK\_TOO\_SMALL (45)**

The task stack size of an IDLE task would have been less than the configured stack size for IDLE tasks, see *[CONFIGURE\\_IDLE\\_TASK\\_STACK\\_SIZE](#page-738-0)* (page 711). This fatal error may occur during system initialization. It is an application configuration error.

## **INTERNAL\_ERROR\_CANNOT\_DISABLE\_DATA\_CACHE (46)**

This fatal error may be caused by *[rtems\\_cache\\_disable\\_data\(\)](#page-540-0)* (page 513) if the data cache cannot be disabled for a particular *[target](#page-1076-0)* or configuration. The data cache may be necessary to provide *[atomic operations](#page-1060-3)*. In SMP configurations, the data cache may be required to ensure data coherency. See the BSP documentation in the *RTEMS User Manual* for more information.

24.2. Background 525

# <span id="page-553-0"></span>24.3 Operations

## <span id="page-553-1"></span>24.3.1 Announcing a Fatal Error

A fatal error can be announced by calling for example *[rtems\\_fatal\(\)](#page-555-0)* (page 528), *[rtems\\_shutdown\\_executive\(\)](#page-557-0)* (page 530), *[rtems\\_panic\(\)](#page-556-0)* (page 529), *[rtems\\_fatal\\_error\\_occurred\(\)](#page-561-0)* (page 534), or exit().

# <span id="page-554-0"></span>24.4 Directives

This section details the directives of the Fatal Error Manager. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

24.4. Directives 527

## <span id="page-555-1"></span><span id="page-555-0"></span>24.4.1 rtems\_fatal()

Invokes the fatal error handler.

#### CALLING SEQUENCE:

```
1 void rtems_fatal(
2 rtems_fatal_source fatal_source,
3 rtems_fatal_code fatal_code
4 );
```

#### PARAMETERS:

#### **fatal\_source**

This parameter is the fatal source.

#### **fatal\_code**

This parameter is the fatal code.

#### DESCRIPTION:

This directive processes fatal errors. The fatal source is set to the value of the fatal\_source parameter. The fatal code is set to the value of the fatal\_code parameter.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not return to the caller.
- The directive invokes the fatal error extensions in *[extension forward order](#page-1065-0)*.
- The directive does not invoke handlers registered by atexit() or on\_exit().
- The directive may terminate the system.

## <span id="page-556-1"></span><span id="page-556-0"></span>24.4.2 rtems\_panic()

Prints the message and invokes the fatal error handler.

## CALLING SEQUENCE:

```
1 void rtems_panic( const char *fmt, ... );
```

#### PARAMETERS:

## **fmt**

This parameter is the message format.

**...**

This parameter is a list of optional parameters required by the message format.

#### DESCRIPTION:

This directive prints a message via *[printk\(\)](#page-520-0)* (page 493) specified by the fmt parameter and optional parameters and then invokes the fatal error handler. The fatal source is set to RTEMS\_FATAL\_SOURCE\_PANIC. The fatal code is set to the value of the fmt parameter value.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not return to the caller.
- The directive invokes the fatal error extensions in *[extension forward order](#page-1065-0)*.
- The directive does not invoke handlers registered by atexit() or on\_exit().
- The directive may terminate the system.

24.4. Directives 529

## <span id="page-557-1"></span><span id="page-557-0"></span>24.4.3 rtems\_shutdown\_executive()

Invokes the fatal error handler.

## CALLING SEQUENCE:

```
1 void rtems_shutdown_executive( uint32_t fatal_code );
```

#### PARAMETERS:

#### **fatal\_code**

This parameter is the fatal code.

## DESCRIPTION:

This directive processes fatal errors. The fatal source is set to RTEMS\_FATAL\_SOURCE\_EXIT. The fatal code is set to the value of the fatal\_code parameter.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not return to the caller.
- The directive invokes the fatal error extensions in *[extension forward order](#page-1065-0)*.
- The directive does not invoke handlers registered by atexit() or on\_exit().
- The directive may terminate the system.

## <span id="page-558-1"></span><span id="page-558-0"></span>24.4.4 rtems\_exception\_frame\_print()

Prints the exception frame.

## CALLING SEQUENCE:

```
1 void rtems_exception_frame_print( const rtems_exception_frame *frame );
```

#### PARAMETERS:

## **frame**

This parameter is the reference to the exception frame to print.

#### DESCRIPTION:

The exception frame is printed in an architecture-dependent format using *[printk\(\)](#page-520-0)* (page 493).

24.4. Directives 531

## <span id="page-559-1"></span><span id="page-559-0"></span>24.4.5 rtems\_fatal\_source\_text()

Returns a descriptive text for the fatal source.

## CALLING SEQUENCE:

```
1 const char *rtems_fatal_source_text( rtems_fatal_source fatal_source );
```

### PARAMETERS:

#### **fatal\_source**

This parameter is the fatal source.

#### RETURN VALUES:

**"?"**

The fatal\_source parameter value was not a fatal source.

Returns a descriptive text for the fatal source. The text for the fatal source is the enumerator constant name.

## CONSTRAINTS:

The following constraints apply to this directive:

â€¢ The directive may be called from within any runtime context.

## <span id="page-560-1"></span><span id="page-560-0"></span>24.4.6 rtems\_internal\_error\_text()

Returns a descriptive text for the internal error code.

## CALLING SEQUENCE:

```
1 const char *rtems_internal_error_text( rtems_fatal_code internal_error_code );
```

#### PARAMETERS:

#### **internal\_error\_code**

This parameter is the internal error code.

#### RETURN VALUES:

**"?"**

The internal\_error\_code parameter value was not an internal error code.

Returns a descriptive text for the internal error code. The text for the internal error code is the enumerator constant name.

## CONSTRAINTS:

The following constraints apply to this directive:

â€¢ The directive may be called from within any runtime context.

24.4. Directives 533

## <span id="page-561-1"></span><span id="page-561-0"></span>24.4.7 rtems\_fatal\_error\_occurred()

Invokes the fatal error handler.

#### CALLING SEQUENCE:

```
1 void rtems_fatal_error_occurred( uint32_t fatal_code );
```

#### PARAMETERS:

#### **fatal\_code**

This parameter is the fatal code.

#### DESCRIPTION:

This directive processes fatal errors. The fatal source is set to INTERNAL\_ERROR\_RTEMS\_API. The fatal code is set to the value of the fatal\_code parameter.

## NOTES:

This directive is deprecated and should not be used in new code. It is recommended to not use this directive since error locations cannot be uniquely identified. A recommended alternative directive is *[rtems\\_fatal\(\)](#page-555-0)* (page 528).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not return to the caller.
- The directive invokes the fatal error extensions in *[extension forward order](#page-1065-0)*.
- The directive does not invoke handlers registered by atexit() or on\_exit().
- The directive may terminate the system.

CHAPTER

# **TWENTYFIVE**

# <span id="page-562-0"></span>BOARD SUPPORT PACKAGES

# <span id="page-563-0"></span>25.1 Introduction

A board support package (BSP) is a collection of user-provided facilities which interface RTEMS and an application with a specific hardware platform. These facilities may include hardware initialization, device drivers, user extensions, and a Multiprocessor Communications Interface (MPCI). However, a minimal BSP need only support processor reset and initialization and, if needed, a clock tick.

# <span id="page-564-0"></span>25.2 Reset and Initialization

An RTEMS based application is initiated or re-initiated when the processor is reset. This initialization code is responsible for preparing the target platform for the RTEMS application. Although the exact actions performed by the initialization code are highly processor and target dependent, the logical functionality of these actions are similar across a variety of processors and target platforms.

Normally, the BSP and some of the application initialization is intertwined in the RTEMS initialization sequence controlled by the shared function boot\_card().

The reset application initialization code is executed first when the processor is reset. All of the hardware must be initialized to a quiescent state by this software before initializing RTEMS. When in quiescent state, devices do not generate any interrupts or require any servicing by the application. Some of the hardware components may be initialized in this code as well as any application initialization that does not involve calls to RTEMS directives.

The processor's Interrupt Vector Table which will be used by the application may need to be set to the required value by the reset application initialization code. Because interrupts are enabled automatically by RTEMS as part of the context switch to the first task, the Interrupt Vector Table MUST be set before this directive is invoked to ensure correct interrupt vectoring. The processor's Interrupt Vector Table must be accessible by RTEMS as it will be modified by the when installing user Interrupt Service Routines (ISRs) On some CPUs, RTEMS installs it's own Interrupt Vector Table as part of initialization and thus these requirements are met automatically. The reset code which is executed before the call to any RTEMS initialization routines has the following requirements:

- Must not make any blocking RTEMS directive calls.
- If the processor supports multiple privilege levels, must leave the processor in the most privileged, or supervisory, state.
- Must allocate a stack of sufficient size to execute the initialization and shutdown of the system. This stack area will NOT be used by any task once the system is initialized. This stack is often reserved via the linker script or in the assembly language start up file.
- Must initialize the stack pointer for the initialization process to that allocated.
- Must initialize the processor's Interrupt Vector Table.
- Must disable all maskable interrupts.
- If the processor supports a separate interrupt stack, must allocate the interrupt stack and initialize the interrupt stack pointer.

At the end of the initialization sequence, RTEMS does not return to the BSP initialization code, but instead context switches to the highest priority task to begin application execution. This task is typically a User Initialization Task which is responsible for performing both local and global application initialization which is dependent on RTEMS facilities. It is also responsible for initializing any higher level RTEMS services the application uses such as networking and blocking device drivers.

## <span id="page-565-0"></span>25.2.1 Interrupt Stack Requirements

The worst-case stack usage by interrupt service routines must be taken into account when designing an application. If the processor supports interrupt nesting, the stack usage must include the deepest nest level. The worst-case stack usage must account for the following requirements:

- Processor's interrupt stack frame
- Processor's subroutine call stack frame
- RTEMS system calls
- Registers saved on stack
- Application subroutine calls

The size of the interrupt stack must be greater than or equal to the confugured minimum stack size.

## <span id="page-565-1"></span>25.2.2 Processors with a Separate Interrupt Stack

Some processors support a separate stack for interrupts. When an interrupt is vectored and the interrupt is not nested, the processor will automatically switch from the current stack to the interrupt stack. The size of this stack is based solely on the worst-case stack usage by interrupt service routines.

The dedicated interrupt stack for the entire application on some architectures is supplied and initialized by the reset and initialization code of the user's Board Support Package. Whether allocated and initialized by the BSP or RTEMS, since all ISRs use this stack, the stack size must take into account the worst case stack usage by any combination of nested ISRs.

## <span id="page-565-2"></span>25.2.3 Processors Without a Separate Interrupt Stack

Some processors do not support a separate stack for interrupts. In this case, without special assistance every task's stack must include enough space to handle the task's worst-case stack usage as well as the worst-case interrupt stack usage. This is necessary because the worst-case interrupt nesting could occur while any task is executing.

On many processors without dedicated hardware managed interrupt stacks, RTEMS manages a dedicated interrupt stack in software. If this capability is supported on a CPU, then it is logically equivalent to the processor supporting a separate interrupt stack in hardware.

# <span id="page-566-0"></span>25.3 Device Drivers

Device drivers consist of control software for special peripheral devices and provide a logical interface for the application developer. The RTEMS I/O manager provides directives which allow applications to access these device drivers in a consistent fashion. A Board Support Package may include device drivers to access the hardware on the target platform. These devices typically include serial and parallel ports, counter/timer peripherals, real-time clocks, disk interfaces, and network controllers.

For more information on device drivers, refer to the I/O Manager chapter.

## <span id="page-566-1"></span>25.3.1 Clock Tick Device Driver

Most RTEMS applications will include a clock tick device driver which invokes a clock tick directive at regular intervals. The clock tick is necessary if the application is to utilize timeslicing, the clock manager, the timer manager, the rate monotonic manager, or the timeout option on blocking directives.

The clock tick is usually provided as an interrupt from a counter/timer or a real-time clock device. When a counter/timer is used to provide the clock tick, the device is typically programmed to operate in continuous mode. This mode selection causes the device to automatically reload the initial count and continue the countdown without programmer intervention. This reduces the overhead required to manipulate the counter/timer in the clock tick ISR and increases the accuracy of tick occurrences. The initial count can be based on the microseconds\_per\_tick field in the RTEMS Configuration Table. An alternate approach is to set the initial count for a fixed time period (such as one millisecond) and have the ISR invoke a clock tick directive on the configured microseconds\_per\_tick boundaries. Obviously, this can induce some error if the configured microseconds\_per\_tick is not evenly divisible by the chosen clock interrupt quantum.

It is important to note that the interval between clock ticks directly impacts the granularity of RTEMS timing operations. In addition, the frequency of clock ticks is an important factor in the overall level of system overhead. A high clock tick frequency results in less processor time being available for task execution due to the increased number of clock tick ISRs.

25.3. Device Drivers 539

# <span id="page-567-0"></span>25.4 User Extensions

RTEMS allows the application developer to augment selected features by invoking user-supplied extension routines when the following system events occur:

- Task creation
- Task initiation
- Task reinitiation
- Task deletion
- Task context switch
- Post task context switch
- Task begin
- Task exits
- Fatal error detection

User extensions can be used to implement a wide variety of functions including execution profiling, non-standard coprocessor support, debug support, and error detection and recovery. For example, the context of a non-standard numeric coprocessor may be maintained via the user extensions. In this example, the task creation and deletion extensions are responsible for allocating and deallocating the context area, the task initiation and reinitiation extensions would be responsible for priming the context area, and the task context switch extension would save and restore the context of the device.

For more information on user extensions, refer to *[User Extensions Manager](#page-570-0)* (page 543).

# <span id="page-568-0"></span>25.5 Multiprocessor Communications Interface (MPCI)

RTEMS requires that an MPCI layer be provided when a multiple node application is developed. This MPCI layer must provide an efficient and reliable communications mechanism between the multiple nodes. Tasks on different nodes communicate and synchronize with one another via the MPCI. Each MPCI layer must be tailored to support the architecture of the target platform.

For more information on the MPCI, refer to the Multiprocessing Manager chapter.

# <span id="page-568-1"></span>25.5.1 Tightly-Coupled Systems

A tightly-coupled system is a multiprocessor configuration in which the processors communicate solely via shared global memory. The MPCI can simply place the RTEMS packets in the shared memory space. The two primary considerations when designing an MPCI for a tightly-coupled system are data consistency and informing another node of a packet.

The data consistency problem may be solved using atomic "test and set" operations to provide a "lock" in the shared memory. It is important to minimize the length of time any particular processor locks a shared data structure.

The problem of informing another node of a packet can be addressed using one of two techniques. The first technique is to use an interprocessor interrupt capability to cause an interrupt on the receiving node. This technique requires that special support hardware be provided by either the processor itself or the target platform. The second technique is to have a node poll for arrival of packets. The drawback to this technique is the overhead associated with polling.

## <span id="page-568-2"></span>25.5.2 Loosely-Coupled Systems

A loosely-coupled system is a multiprocessor configuration in which the processors communicate via some type of communications link which is not shared global memory. The MPCI sends the RTEMS packets across the communications link to the destination node. The characteristics of the communications link vary widely and have a significant impact on the MPCI layer. For example, the bandwidth of the communications link has an obvious impact on the maximum MPCI throughput.

The characteristics of a shared network, such as Ethernet, lend themselves to supporting an MPCI layer. These networks provide both the point-to-point and broadcast capabilities which are expected by RTEMS.

## <span id="page-568-3"></span>25.5.3 Systems with Mixed Coupling

A mixed-coupling system is a multiprocessor configuration in which the processors communicate via both shared memory and communications links. A unique characteristic of mixedcoupling systems is that a node may not have access to all communication methods. There may be multiple shared memory areas and communication links. Therefore, one of the primary functions of the MPCI layer is to efficiently route RTEMS packets between nodes. This routing may be based on numerous algorithms. In addition, the router may provide alternate communications paths in the event of an overload or a partial failure.

## <span id="page-568-4"></span>25.5.4 Heterogeneous Systems

Designing an MPCI layer for a heterogeneous system requires special considerations by the developer. RTEMS is designed to eliminate many of the problems associated with sharing data in a heterogeneous environment. The MPCI layer need only address the representation of thirtytwo (32) bit unsigned quantities.

<span id="page-569-0"></span>For more information on supporting a heterogeneous system, refer the Supporting Heterogeneous Environments in the Multiprocessing Manager chapter.

CHAPTER

# **TWENTYSIX**

# <span id="page-570-0"></span>USER EXTENSIONS MANAGER

# <span id="page-571-0"></span>26.1 Introduction

The User Extensions Manager allows the application developer to augment the executive by allowing them to supply extension routines which are invoked at critical system events. The directives provided by the User Extensions Manager are:

- *[rtems\\_extension\\_create\(\)](#page-579-0)* (page 552) Creates an extension set.
- *[rtems\\_extension\\_delete\(\)](#page-581-0)* (page 554) Deletes the extension set.
- *[rtems\\_extension\\_ident\(\)](#page-582-0)* (page 555) Identifies an extension set by the object name.

# <span id="page-572-3"></span><span id="page-572-0"></span>26.2 Background

User extensions (call-back functions) are invoked by the system when the following events occur

- thread creation,
- thread start,
- thread restart,
- thread switch,
- thread begin,
- thread exitted (return from thread entry function),
- thread termination,
- thread deletion, and
- fatal error detection (system termination).

The user extensions have event-specific arguments, invocation orders and execution contexts. Extension sets can be installed at run-time via rtems\_extension\_create() (dynamic extension sets) or at link-time via the application configuration option *[CONFIGURE\\_INITIAL\\_EXTENSIONS](#page-602-0)* (page 575) (initial extension sets).

The execution context of user extensions varies. Some user extensions are invoked with ownership of the allocator mutex. The allocator mutex protects dynamic memory allocations and object creation/deletion. Some user extensions are invoked with thread dispatching disabled. The fatal error extension is invoked in an arbitrary context.

## <span id="page-572-1"></span>26.2.1 Extension Sets

User extensions are maintained as a set. All user extensions are optional and may be NULL. Together a set of these user extensions typically performs a specific functionality such as performance monitoring or debugger support. The extension set is defined via the following structure.

```
1 typedef struct {
2 rtems_task_create_extension thread_create;
3 rtems_task_start_extension thread_start;
4 rtems_task_restart_extension thread_restart;
5 rtems_task_delete_extension thread_delete;
6 rtems_task_switch_extension thread_switch;
7 rtems_task_begin_extension thread_begin;
8 rtems_task_exitted_extension thread_exitted;
9 rtems_fatal_extension fatal;
10 rtems_task_terminate_extension thread_terminate;
11 } rtems_extensions_table;
```

## <span id="page-572-2"></span>26.2.2 TCB Extension Area

There is no system-provided storage for the initial extension sets.

The task control block (TCB) contains a pointer for each dynamic extension set. The pointer is initialized to NULL during thread initialization before the thread create extension is invoked. The pointer may be used by the dynamic extension set to maintain thread-specific data.

26.2. Background 545

<span id="page-573-1"></span>The TCB extension is an array of pointers in the TCB. The index into the table can be obtained from the extension identifier returned when the extension object is created:

```
1 index = rtems_object_id_get_index( extension_id );
```

The number of pointers in the area is the same as the number of dynamic user extension sets configured. This allows an application to augment the TCB with user-defined information. For example, an application could implement task profiling by storing timing statistics in the TCB's extended memory area. When a task context switch is being executed, the thread switch extension could read a real-time clock to calculate how long the task being swapped out has run as well as timestamp the starting time for the task being swapped in.

If used, the extended memory area for the TCB should be allocated and the TCB extension pointer should be set at the time the task is created or started by either the thread create or thread start extension. The application is responsible for managing this extended memory area for the TCBs. The memory may be reinitialized by the thread restart extension and should be deallocated by the thread delete extension when the task is deleted. Since the TCB extension buffers would most likely be of a fixed size, the RTEMS partition manager could be used to manage the application's extended memory area. The application could create a partition of fixed size TCB extension buffers and use the partition manager's allocation and deallocation directives to obtain and release the extension buffers.

## <span id="page-573-0"></span>26.2.3 Order of Invocation

The user extensions are invoked in either *[extension forward order](#page-1065-0)* or *[extension reverse order](#page-1065-1)*. By invoking the user extensions in these orders, extensions can be built upon one another. At the following system events, the user extensions are invoked in forward order

- thread creation,
- thread start,
- thread restart,
- thread switch,
- thread begin,
- thread exitted (return from thread entry function), and
- fatal error detection.

At the following system events, the user extensions are invoked in reverse order:

- thread termination, and
- thread deletion.

At these system events, the user extensions are invoked in reverse order to insure that if an extension set is built upon another, the more complicated user extension is invoked before the user extension it is built upon. An example is use of the thread delete extension by the Standard C Library. Extension sets which are installed after the Standard C Library will operate correctly even if they utilize the C Library because the C Library's thread delete extension is invoked after that of the other thread delete extensions.

## <span id="page-574-3"></span><span id="page-574-0"></span>26.2.4 Thread Create Extension

The thread create extension is invoked during thread creation, for example via rtems\_task\_create() or pthread\_create(). The thread create extension is defined as follows.

```
1 typedef bool ( *rtems_task_create_extension )(
2 rtems_tcb *executing,
3 rtems_tcb *created
4 );
```

The executing is a pointer to the TCB of the currently executing thread. The created is a pointer to the TCB of the created thread. The created thread is completely initialized with respect to the operating system.

The executing thread is the owner of the allocator mutex except during creation of the idle threads. Since the allocator mutex allows nesting the normal memory allocation routines can be used.

A thread create extension will frequently attempt to allocate resources. If this allocation fails, then the thread create extension must return false and the entire thread create operation will fail, otherwise it must return true.

The thread create extension is invoked in forward order with thread dispatching enabled (except during system initialization).

## <span id="page-574-1"></span>26.2.5 Thread Start Extension

The thread start extension is invoked during a thread start, for example via rtems\_task\_start() or pthread\_create(). The thread start extension is defined as follows.

```
1 typedef void ( *rtems_task_start_extension )(
2 rtems_tcb *executing,
3 rtems_tcb *started
4 );
```

The executing is a pointer to the TCB of the currently executing thread. The started is a pointer to the TCB of the started thread. It is invoked after the environment of the started thread has been loaded and the started thread has been made ready. So, in SMP configurations, the thread may already run on another processor before the thread start extension is actually invoked. Thread switch and thread begin extensions may run before or in parallel with the thread start extension in SMP configurations.

The thread start extension is invoked in forward order with thread dispatching disabled.

## <span id="page-574-2"></span>26.2.6 Thread Restart Extension

The thread restart extension is invoked during a thread restart, for example via rtems\_task\_restart(). The thread restart extension is defined as follows.

```
1 typedef void ( *rtems_task_restart_extension )(
2 rtems_tcb *executing,
3 rtems_tcb *restarted
4 );
```

26.2. Background 547

<span id="page-575-2"></span>Both executing and restarted are pointers the TCB of the currently executing thread. It is invoked in the context of the executing thread right before the execution context is reloaded. The thread stack reflects the previous execution context.

The thread restart extension is invoked in forward order with thread dispatching enabled (except during system initialization). The thread life is protected. Thread restart and delete requests issued by thread restart extensions lead to recursion. The POSIX cleanup handlers, POSIX key destructors and thread-local object destructors run in this context.

## <span id="page-575-0"></span>26.2.7 Thread Switch Extension

The thread switch extension is defined as follows.

```
1 typedef void ( *rtems_task_switch_extension )(
2 rtems_tcb *executing,
3 rtems_tcb *heir
4 );
```

The invocation conditions of the thread switch extension depend on whether RTEMS was configured for uniprocessor or SMP systems. A user must pay attention to the differences to correctly implement a thread switch extension.

In uniprocessor configurations, the thread switch extension is invoked before the context switch from the currently executing thread to the heir thread. The executing is a pointer to the TCB of the currently executing thread. The heir is a pointer to the TCB of the heir thread. The context switch initiated through the multitasking start is not covered by the thread switch extension.

In SMP configurations, the thread switch extension is invoked after the context switch to the new executing thread (previous heir thread). The executing is a pointer to the TCB of the previously executing thread. Despite the name, this is not the currently executing thread. The heir is a pointer to the TCB of the newly executing thread. This is the currently executing thread. The context switches initiated through the multitasking start are covered by the thread switch extension. The reason for the differences to uniprocessor configurations is that the context switch may update the heir thread of the processor, see *[Thread Dispatch Details](#page-896-1)* (page 869). The thread switch extensions are invoked with disabled interrupts and with ownership of a perprocessor SMP lock. Thread switch extensions may run in parallel on multiple processors. It is recommended to use thread-local or per-processor data structures for thread switch extensions. A global SMP lock should be avoided for performance reasons.

The thread switch extension is invoked in forward order with thread dispatching disabled.

## <span id="page-575-1"></span>26.2.8 Thread Begin Extension

The thread begin extension is invoked during a thread begin before the thread entry function is called. The thread begin extension is defined as follows.

```
1 typedef void ( *rtems_task_begin_extension )(
2 rtems_tcb *executing
3 );
```

The executing is a pointer to the TCB of the currently executing thread. The thread begin extension executes in a normal thread context and may allocate resources for the executing thread. In particular, it has access to thread-local storage of the executing thread.

<span id="page-576-3"></span>The thread begin extension is invoked in forward order with thread dispatching enabled. The thread switch extension may be called multiple times for this thread before or during the thread begin extension is invoked.

## <span id="page-576-0"></span>26.2.9 Thread Exitted Extension

The thread exitted extension is invoked once the thread entry function returns. The thread exitted extension is defined as follows.

```
1 typedef void ( *rtems_task_exitted_extension )(
2 rtems_tcb *executing
3 );
```

The executing is a pointer to the TCB of the currently executing thread.

This extension is invoked in forward order with thread dispatching enabled.

## <span id="page-576-1"></span>26.2.10 Thread Termination Extension

The thread termination extension is invoked in case a termination request is recognized by the currently executing thread. Termination requests may result due to calls of rtems\_task\_delete(), pthread\_exit(), or pthread\_cancel(). The thread termination extension is defined as follows.

```
1 typedef void ( *rtems_task_terminate_extension )(
2 rtems_tcb *executing
3 );
```

The executing is a pointer to the TCB of the currently executing thread.

It is invoked in the context of the terminated thread right before the thread dispatch to the heir thread. The POSIX cleanup handlers, POSIX key destructors and thread-local object destructors run in this context. Depending on the order, the thread termination extension has access to thread-local storage and thread-specific data of POSIX keys.

The thread terminate extension is invoked in reverse order with thread dispatching enabled. The thread life is protected. Thread restart and delete requests issued by thread terminate extensions lead to recursion.

## <span id="page-576-2"></span>26.2.11 Thread Delete Extension

The thread delete extension is invoked in case a zombie thread is killed. A thread becomes a zombie thread after it terminated. The thread delete extension is defined as follows.

```
1 typedef void ( *rtems_task_delete_extension )(
2 rtems_tcb *executing,
3 rtems_tcb *deleted
4 );
```

The executing is a pointer to the TCB of the currently executing thread. The deleted is a pointer to the TCB of the deleted thread. The executing and deleted pointers are never equal.

The executing thread is the owner of the allocator mutex. Since the allocator mutex allows nesting the normal memory allocation routines can be used.

The thread delete extension is invoked in reverse order with thread dispatching enabled.

26.2. Background 549

<span id="page-577-1"></span>Please note that a thread delete extension is not immediately invoked with a call to rtems\_task\_delete() or similar. The thread must first terminate and this may take some time. The thread delete extension is invoked by rtems\_task\_create() or similar as a result of a lazy garbage collection of zombie threads.

## <span id="page-577-0"></span>26.2.12 Fatal Error Extension

The fatal error extension is invoked during *[system termination](#page-546-2)* (page 519). The fatal error extension is defined as follows.

```
1 typedef void( *rtems_fatal_extension )(
2 rtems_fatal_source source,
3 bool always_set_to_false,
4 rtems_fatal_code code
5 );
```

The source parameter is the fatal source indicating the subsystem the fatal condition originated in. The always\_set\_to\_false parameter is always set to false and provided only for backward compatibility reasons. The code parameter is the fatal error code. This value must be interpreted with respect to the source.

The fatal error extension is invoked in forward order.

It is strongly advised to use initial extension sets to install a fatal error extension. Usually, the initial extension set of board support package provides a fatal error extension which resets the board. In this case, the dynamic fatal error extensions are not invoked.

# <span id="page-578-0"></span>26.3 Directives

This section details the directives of the User Extensions Manager. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

26.3. Directives 551

## <span id="page-579-1"></span><span id="page-579-0"></span>26.3.1 rtems\_extension\_create()

Creates an extension set.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_extension_create(
2 rtems_name name,
3 const rtems_extensions_table *extension_table,
4 rtems_id *id
5 );
```

#### PARAMETERS:

#### **name**

This parameter is the object name of the extension set.

#### **extension\_table**

This parameter is the table with the extensions to be used by the extension set.

**id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the identifier of the created extension set will be stored in this object.

#### DESCRIPTION:

This directive creates an extension set which resides on the local node. The extension set has the user-defined object name specified in name. The assigned object identifier is returned in id. This identifier is used to access the extension set with other extension set related directives.

The extension set is initialized using the extension table specified in extension\_table.

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_NAME**

The name parameter was invalid.

#### **RTEMS\_INVALID\_ADDRESS**

The extension\_table parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_TOO\_MANY**

There was no inactive object available to create an extension set. The number of extension sets available to the application is configured through the *[CONFIG-](#page-652-0)[URE\\_MAXIMUM\\_USER\\_EXTENSIONS](#page-652-0)* (page 625) application configuration option.

### NOTES:

The user-provided extension table is not used after the return of the directive.

Each extension of the extension table is optional and may be [NULL.](https://en.cppreference.com/w/c/types/NULL) All extensions except the task switch extension of the extension table are atomically and immediately installed. A task switch extension is separately installed after the other extensions. The extensions of the extension table are invoked upon the next system event supporting an extension.

An alternative to dynamically created extension sets are initial extensions, see *[CONFIG-](#page-602-0)[URE\\_INITIAL\\_EXTENSIONS](#page-602-0)* (page 575). Initial extensions are recommended for extension sets which provide a fatal error extension.

For control and maintenance of the extension set, RTEMS allocates a *[ESCB](#page-1064-1)* from the local ESCB free pool and initializes it.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- The number of extension sets available to the application is configured through the *[CON-](#page-652-0)[FIGURE\\_MAXIMUM\\_USER\\_EXTENSIONS](#page-652-0)* (page 625) application configuration option.

26.3. Directives 553

## <span id="page-581-1"></span><span id="page-581-0"></span>26.3.2 rtems\_extension\_delete()

Deletes the extension set.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_extension_delete( rtems_id id );
```

### PARAMETERS:

## **id**

This parameter is the extension set identifier.

#### DESCRIPTION:

This directive deletes the extension set specified by id.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ID**

There was no extension set associated with the identifier specified by id.

#### NOTES:

The *[ESCB](#page-1064-1)* for the deleted extension set is reclaimed by RTEMS.

# CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- The calling task does not have to be the task that created the object. Any local task that knows the object identifier can delete the object.

## <span id="page-582-1"></span><span id="page-582-0"></span>26.3.3 rtems\_extension\_ident()

Identifies an extension set by the object name.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_extension_ident( rtems_name name, rtems_id *id );
```

#### PARAMETERS:

#### **name**

This parameter is the object name to look up.

#### **id**

This parameter is the pointer to an *[rtems\\_id](#page-68-2)* (page 41) object. When the directive call is successful, the object identifier of an object with the specified name will be stored in this object.

#### DESCRIPTION:

This directive obtains an extension set identifier associated with the extension set name specified in name.

#### RETURN VALUES:

### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The id parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_NAME**

The name parameter was 0.

## **RTEMS\_INVALID\_NAME**

There was no object with the specified name on the local node.

#### NOTES:

If the extension set name is not unique, then the extension set identifier will match the first extension set with that name in the search order. However, this extension set identifier is not guaranteed to correspond to the desired extension set.

The objects are searched from lowest to the highest index. Only the local node is searched.

The extension set identifier is used with other extension related directives to access the extension set.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive will not cause the calling task to be preempted.

26.3. Directives 555

CHAPTER

# **TWENTYSEVEN**

# <span id="page-584-0"></span>CONFIGURING A SYSTEM

# <span id="page-585-0"></span>27.1 Introduction

The application configuration information group provides an API to get the configuration of an application.

RTEMS must be configured for an application. This configuration encompasses a variety of information including the length of each clock tick, the maximum number of each information RTEMS object that can be created, the application initialization tasks, the task scheduling algorithm to be used, and the device drivers in the application.

Although this information is contained in data structures that are used by RTEMS at system initialization time, the data structures themselves must not be generated by hand. RTEMS provides a set of macros system which provides a simple standard mechanism to automate the generation of these structures.

The RTEMS header file <rtems/confdefs.h> is at the core of the automatic generation of system configuration. It is based on the idea of setting macros which define configuration parameters of interest to the application and defaulting or calculating all others. This variety of macros can automatically produce all of the configuration data required for an RTEMS application. The term confdefs is shorthand for a *Configuration Defaults*.

As a general rule, application developers only specify values for the configuration parameters of interest to them. They define what resources or features they require. In most cases, when a parameter is not specified, it defaults to zero (0) instances, a standards compliant value, or disabled as appropriate. For example, by default there will be 256 task priority levels but this can be lowered by the application. This number of priority levels is required to be compliant with the RTEID/ORKID standards upon which the Classic API is based. There are similar cases where the default is selected to be compliant with the POSIX standard.

For each configuration parameter in the configuration tables, the macro corresponding to that field is discussed. The RTEMS Maintainers expect that all systems can be easily configured using the <rtems/confdefs.h> mechanism and that using this mechanism will avoid internal RTEMS configuration changes impacting applications.

Some application configuration settings and other system parameters can be queried by the application. The directives provided by the Application Configuration Information are:

- *[rtems\\_get\\_build\\_label\(\)](#page-773-0)* (page 746) Gets the RTEMS build label.
- *[rtems\\_get\\_copyright\\_notice\(\)](#page-774-0)* (page 747) Gets the RTEMS copyright notice.
- *[rtems\\_get\\_target\\_hash\(\)](#page-775-0)* (page 748) Gets the RTEMS target hash.
- *[rtems\\_get\\_version\\_string\(\)](#page-776-0)* (page 749) Gets the RTEMS version string.
- *[rtems\\_configuration\\_get\\_do\\_zero\\_of\\_workspace\(\)](#page-777-0)* (page 750) Indicates if the RTEMS Workspace is configured to be zeroed during system initialization for this application.
- *[rtems\\_configuration\\_get\\_idle\\_task\\_stack\\_size\(\)](#page-778-0)* (page 751) Gets the IDLE task stack size in bytes of this application.
- *[rtems\\_configuration\\_get\\_idle\\_task\(\)](#page-779-0)* (page 752) Gets the IDLE task body of this application.
- *[rtems\\_configuration\\_get\\_interrupt\\_stack\\_size\(\)](#page-780-0)* (page 753) Gets the interrupt stack size in bytes of this application.
- *[rtems\\_configuration\\_get\\_maximum\\_barriers\(\)](#page-781-0)* (page 754) Gets the resource number of *[Barrier Manager](#page-382-0)* (page 355) objects configured for this application.

- *[rtems\\_configuration\\_get\\_maximum\\_extensions\(\)](#page-782-0)* (page 755) Gets the resource number of *[User Extensions Manager](#page-570-0)* (page 543) objects configured for this application.
- *[rtems\\_configuration\\_get\\_maximum\\_message\\_queues\(\)](#page-783-0)* (page 756) Gets the resource number of *[Message Manager](#page-394-0)* (page 367) objects configured for this application.
- *[rtems\\_configuration\\_get\\_maximum\\_partitions\(\)](#page-784-0)* (page 757) Gets the resource number of *[Partition Manager](#page-444-0)* (page 417) objects configured for this application.
- *[rtems\\_configuration\\_get\\_maximum\\_periods\(\)](#page-785-0)* (page 758) Gets the resource number of *[Rate Monotonic Manager](#page-326-0)* (page 299) objects configured for this application.
- *[rtems\\_configuration\\_get\\_maximum\\_ports\(\)](#page-786-0)* (page 759) Gets the resource number of *[Dual-Ported Memory Manager](#page-484-0)* (page 457) objects configured for this application.
- *[rtems\\_configuration\\_get\\_maximum\\_processors\(\)](#page-787-0)* (page 760) Gets the maximum number of processors configured for this application.
- *[rtems\\_configuration\\_get\\_maximum\\_regions\(\)](#page-788-0)* (page 761) Gets the resource number of *[Region Manager](#page-460-0)* (page 433) objects configured for this application.
- *[rtems\\_configuration\\_get\\_maximum\\_semaphores\(\)](#page-789-0)* (page 762) Gets the resource number of *[Semaphore Manager](#page-354-0)* (page 327) objects configured for this application.
- *[rtems\\_configuration\\_get\\_maximum\\_tasks\(\)](#page-790-0)* (page 763) Gets the resource number of *[Task](#page-124-0) [Manager](#page-124-0)* (page 97) objects configured for this application.
- *[rtems\\_configuration\\_get\\_maximum\\_timers\(\)](#page-791-0)* (page 764) Gets the resource number of *[Timer Manager](#page-302-0)* (page 275) objects configured for this application.
- *[rtems\\_configuration\\_get\\_microseconds\\_per\\_tick\(\)](#page-792-0)* (page 765) Gets the number of microseconds per clock tick configured for this application.
- *[rtems\\_configuration\\_get\\_milliseconds\\_per\\_tick\(\)](#page-793-0)* (page 766) Gets the number of milliseconds per clock tick configured for this application.
- *[rtems\\_configuration\\_get\\_nanoseconds\\_per\\_tick\(\)](#page-794-0)* (page 767) Gets the number of microseconds per clock tick configured for this application.
- *[rtems\\_configuration\\_get\\_number\\_of\\_initial\\_extensions\(\)](#page-795-0)* (page 768) Gets the number of initial extensions configured for this application.
- *[rtems\\_configuration\\_get\\_stack\\_allocate\\_for\\_idle\\_hook\(\)](#page-796-0)* (page 769) Gets the task stack allocator allocate hook used to allocate the stack of each *[IDLE task](#page-1067-2)* configured for this application.
- *[rtems\\_configuration\\_get\\_stack\\_allocate\\_hook\(\)](#page-797-0)* (page 770) Gets the task stack allocator allocate hook configured for this application.
- *[rtems\\_configuration\\_get\\_stack\\_allocate\\_init\\_hook\(\)](#page-798-0)* (page 771) Gets the task stack allocator initialization hook configured for this application.
- *[rtems\\_configuration\\_get\\_stack\\_allocator\\_avoids\\_work\\_space\(\)](#page-799-0)* (page 772) Indicates if the task stack allocator is configured to avoid the RTEMS Workspace for this application.
- *[rtems\\_configuration\\_get\\_stack\\_free\\_hook\(\)](#page-800-0)* (page 773) Gets the task stack allocator free hook configured for this application.
- *[rtems\\_configuration\\_get\\_stack\\_space\\_size\(\)](#page-801-0)* (page 774) Gets the configured size in bytes of the memory space used to allocate thread stacks for this application.

27.1. Introduction 559

- *[rtems\\_configuration\\_get\\_ticks\\_per\\_timeslice\(\)](#page-802-0)* (page 775) Gets the clock ticks per timeslice configured for this application.
- *[rtems\\_configuration\\_get\\_unified\\_work\\_area\(\)](#page-803-0)* (page 776) Indicates if the RTEMS Workspace and C Program Heap are configured to be unified for this application.
- *[rtems\\_configuration\\_get\\_user\\_extension\\_table\(\)](#page-804-0)* (page 777) Gets the initial extensions table configured for this application.
- *[rtems\\_configuration\\_get\\_user\\_multiprocessing\\_table\(\)](#page-805-0)* (page 778) Gets the MPCI configuration table configured for this application.
- *[rtems\\_configuration\\_get\\_work\\_space\\_size\(\)](#page-806-0)* (page 779) Gets the RTEMS Workspace size in bytes configured for this application.
- *[rtems\\_configuration\\_get\\_rtems\\_api\\_configuration\(\)](#page-807-0)* (page 780) Gets the Classic API Configuration Table of this application.
- *[rtems\\_resource\\_is\\_unlimited\(\)](#page-808-0)* (page 781) Indicates if the resource is unlimited.
- *[rtems\\_resource\\_maximum\\_per\\_allocation\(\)](#page-809-0)* (page 782) Gets the maximum number per allocation of a resource number.
- *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) Augments the resource number so that it indicates an unlimited resource.

<span id="page-588-0"></span>The user should be aware that the defaults are intentionally set as low as possible. By default, no application resources are configured. The <rtems/confdefs.h> file ensures that at least one application task or thread is configured and that at least one of the initialization task/thread tables is configured.

# <span id="page-589-0"></span>27.3 Sizing the RTEMS Workspace

The RTEMS Workspace is a user-specified block of memory reserved for use by RTEMS. The application should NOT modify this memory. This area consists primarily of the RTEMS data structures whose exact size depends upon the values specified in the Configuration Table. In addition, task stacks and floating point context areas are dynamically allocated from the RTEMS Workspace.

The <rtems/confdefs.h> mechanism calculates the size of the RTEMS Workspace automatically. It assumes that all tasks are floating point and that all will be allocated the minimum stack space. This calculation includes the amount of memory that will be allocated for internal use by RTEMS. The automatic calculation may underestimate the workspace size truly needed by the application, in which case one can use the *[CONFIGURE\\_MEMORY\\_OVERHEAD](#page-609-0)* (page 582) macro to add a value to the estimate. See Specify Memory Overhead for more details.

The memory area for the RTEMS Workspace is determined by the BSP. In case the RTEMS Workspace is too large for the available memory, then a fatal run-time error occurs and the system terminates.

The file <rtems/confdefs.h> will calculate the value of the work\_space\_size parameter of the Configuration Table. There are many parameters the application developer can specify to help <rtems/confdefs.h> in its calculations. Correctly specifying the application requirements via parameters such as *[CONFIGURE\\_EXTRA\\_TASK\\_STACKS](#page-600-0)* (page 573) and *[CONFIG-](#page-650-0)[URE\\_MAXIMUM\\_TASKS](#page-650-0)* (page 623) is critical for production software.

For each class of objects, the allocation can operate in one of two ways. The default way has an ceiling on the maximum number of object instances which can concurrently exist in the system. Memory for all instances of that object class is reserved at system initialization. The second way allocates memory for an initial number of objects and increases the current allocation by a fixed increment when required. Both ways allocate space from inside the RTEMS Workspace.

See *[Unlimited Objects](#page-593-0)* (page 566) for more details about the second way, which allows for dynamic allocation of objects and therefore does not provide determinism. This mode is useful mostly for when the number of objects cannot be determined ahead of time or when porting software for which you do not know the object requirements.

The space needed for stacks and for RTEMS objects will vary from one version of RTEMS and from one target processor to another. Therefore it is safest to use <rtems/confdefs.h> and specify your application's requirements in terms of the numbers of objects and multiples of RTEMS\_MINIMUM\_STACK\_SIZE, as far as is possible. The automatic estimates of space required will in general change when:

- a configuration parameter is changed,
- task or interrupt stack sizes change,
- the floating point attribute of a task changes,
- task floating point attribute is altered,
- RTEMS is upgraded, or
- the target processor is changed.

Failure to provide enough space in the RTEMS Workspace may result in fatal run-time errors terminating the system.

# <span id="page-590-0"></span>27.4 Potential Issues with RTEMS Workspace Size Estimation

The <rtems/confdefs.h> file estimates the amount of memory required for the RTEMS Workspace. This estimate is only as accurate as the information given to <rtems/confdefs. h> and may be either too high or too low for a variety of reasons. Some of the reasons that <rtems/confdefs.h> may reserve too much memory for RTEMS are:

â€¢ All tasks/threads are assumed to be floating point.

Conversely, there are many more reasons that the resource estimate could be too low:

- Task/thread stacks greater than minimum size must be accounted for explicitly by developer.
- Memory for messages is not included.
- Device driver requirements are not included.
- Network stack requirements are not included.
- Requirements for add-on libraries are not included.

In general, <rtems/confdefs.h> is very accurate when given enough information. However, it is quite easy to use a library and forget to account for its resources.

# <span id="page-591-0"></span>27.5 Configuration Example

In the following example, the configuration information for a system with a single message queue, four (4) tasks, and a timeslice of fifty (50) milliseconds is as follows:

```
1 #include <bsp.h>
2 #define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
3 #define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
4 #define CONFIGURE_MICROSECONDS_PER_TICK 1000 /* 1 millisecond */
5 #define CONFIGURE_TICKS_PER_TIMESLICE 50 /* 50 milliseconds */
6 #define CONFIGURE_RTEMS_INIT_TASKS_TABLE
7 #define CONFIGURE_MAXIMUM_TASKS 4
8 #define CONFIGURE_MAXIMUM_MESSAGE_QUEUES 1
9 #define CONFIGURE_MESSAGE_BUFFER_MEMORY \
10 CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE(20, sizeof(struct USER_MESSAGE))
11 #define CONFIGURE_INIT
12 #include <rtems/confdefs.h>
```

In this example, only a few configuration parameters are specified. The impact of these are as follows:

- The example specified *[CONFIGURE\\_RTEMS\\_INIT\\_TASKS\\_TABLE](#page-663-0)* (page 636) but did not specify any additional parameters. This results in a configuration of an application which will begin execution of a single initialization task named Init which is non-preemptible and at priority one (1).
- By specifying *[CONFIGURE\\_APPLICATION\\_NEEDS\\_CLOCK\\_DRIVER](#page-625-0)* (page 598), this application is configured to have a clock tick device driver. Without a clock tick device driver, RTEMS has no way to know that time is passing and will be unable to support delays and wall time. Further configuration details about time are provided. Per *[CONFIG-](#page-612-0)[URE\\_MICROSECONDS\\_PER\\_TICK](#page-612-0)* (page 585) and *[CONFIGURE\\_TICKS\\_PER\\_TIMESLICE](#page-615-0)* (page 588), the user specified they wanted a clock tick to occur each millisecond, and that the length of a timeslice would be fifty (50) milliseconds.
- By specifying *[CONFIGURE\\_APPLICATION\\_NEEDS\\_CONSOLE\\_DRIVER](#page-626-0)* (page 599), the application will include a console device driver. Although the console device driver may support a combination of multiple serial ports and display and keyboard combinations, it is only required to provide a single device named /dev/console. This device will be used for Standard Input, Output and Error I/O Streams. Thus when *[CONFIG-](#page-626-0)[URE\\_APPLICATION\\_NEEDS\\_CONSOLE\\_DRIVER](#page-626-0)* (page 599) is specified, implicitly three (3) file descriptors are reserved for the Standard I/O Streams and those file descriptors are associated with /dev/console during initialization. All console devices are expected to support the POSIX\*termios\* interface.
- The example above specifies via *[CONFIGURE\\_MAXIMUM\\_TASKS](#page-650-0)* (page 623) that the application requires a maximum of four (4) simultaneously existing Classic API tasks. Similarly, by specifying *[CONFIGURE\\_MAXIMUM\\_MESSAGE\\_QUEUES](#page-644-0)* (page 617), there may be a maximum of only one (1) concurrently existent Classic API message queues.
- The most surprising configuration parameter in this example is the use of *[CONFIG-](#page-610-0)[URE\\_MESSAGE\\_BUFFER\\_MEMORY](#page-610-0)* (page 583). Message buffer memory is allocated from the RTEMS Workspace and must be accounted for. In this example, the single message queue will have up to twenty (20) messages of type struct USER\_MESSAGE.
- The *[CONFIGURE\\_INIT](#page-601-0)* (page 574) constant must be defined in order to make <rtems/

confdefs.h> instantiate the configuration data structures. This can only be defined in one source file per application that includes <rtems/confdefs.h> or the symbol table will be instantiated multiple times and linking errors produced.

This example illustrates that parameters have default values. Among other things, the application implicitly used the following defaults:

- All unspecified types of communications and synchronization objects in the Classic and POSIX Threads API have maximums of zero (0).
- The filesystem will be the default filesystem which is the In-Memory File System (IMFS).
- The application will have the default number of priority levels.
- The minimum task stack size will be that recommended by RTEMS for the target architecture.

# <span id="page-593-0"></span>27.6 Unlimited Objects

In real-time embedded systems the RAM is normally a limited, critical resource and dynamic allocation is avoided as much as possible to ensure predictable, deterministic execution times. For such cases, see *[Sizing the RTEMS Workspace](#page-589-0)* (page 562) for an overview of how to tune the size of the workspace. Frequently when users are porting software to RTEMS the precise resource requirements of the software is unknown. In these situations users do not need to control the size of the workspace very tightly because they just want to get the new software to run; later they can tune the workspace size as needed.

The following object classes in the Classic API can be configured in unlimited mode:

- Barriers
- Message Queues
- Partitions
- Periods
- Ports
- Regions
- Semaphores
- Tasks
- Timers

Additionally, the following object classes from the POSIX API can be configured in unlimited mode:

- Keys pthread\_key\_create()
- Key Value Pairs pthread\_setspecific()
- Message Queues mq\_open()
- Named Semaphores sem\_open()
- Shared Memory shm\_open()
- Threads pthread\_create()
- Timers timer\_create()

## . **Warning**

The following object classes can *not* be configured in unlimited mode:

- Drivers
- File Descriptors
- POSIX Queued Signals
- User Extensions

Due to the memory requirements of unlimited objects it is strongly recommended to use them only in combination with the unified work areas. See Separate or Unified Work Areas for more information on unified work areas.

The following example demonstrates how the two simple configuration defines for unlimited objects and unified works areas can replace many seperate configuration defines for supported object classes:

```
1 #define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
2 #define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
3 #define CONFIGURE_UNIFIED_WORK_AREAS
4 #define CONFIGURE_UNLIMITED_OBJECTS
5 #define CONFIGURE_RTEMS_INIT_TASKS_TABLE
6 #define CONFIGURE_INIT
7 #include <rtems/confdefs.h>
```

Users are cautioned that using unlimited objects is not recommended for production software unless the dynamic growth is absolutely required. It is generally considered a safer embedded systems programming practice to know the system limits rather than experience an out of memory error at an arbitrary and largely unpredictable time in the field.

## <span id="page-594-0"></span>27.6.1 Unlimited Objects by Class

When the number of objects is not known ahead of time, RTEMS provides an autoextending mode that can be enabled individually for each object type by using the macro *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783). This takes a value as a parameter, and is used to set the object maximum number field in an API Configuration table. The value is an allocation unit size. When RTEMS is required to grow the object table it is grown by this size. The kernel will return the object memory back to the RTEMS Workspace when an object is destroyed. The kernel will only return an allocated block of objects to the RTEMS Workspace if at least half the allocation size of free objects remain allocated. RTEMS always keeps one allocation block of objects allocated. Here is an example of using rtems\_resource\_unlimited():

```
1 #define CONFIGURE_MAXIMUM_TASKS rtems_resource_unlimited( 5 )
```

Object maximum specifications can be evaluated with the *[rtems\\_resource\\_is\\_unlimited\(\)](#page-808-0)* (page 781) and *[rtems\\_resource\\_maximum\\_per\\_allocation\(\)](#page-809-0)* (page 782) macros.

## <span id="page-594-1"></span>27.6.2 Unlimited Objects by Default

To ease the burden of developers who are porting new software RTEMS also provides the capability to make all object classes listed above operate in unlimited mode in a simple manner. The application developer is only responsible for enabling unlimited objects (*[CONFIGURE\\_UNLIMITED\\_OBJECTS](#page-618-0)* (page 591)) and specifying the allocation size (*[CONFIG-](#page-617-0)[URE\\_UNLIMITED\\_ALLOCATION\\_SIZE](#page-617-0)* (page 590)).

```
1 #define CONFIGURE_UNLIMITED_OBJECTS
2 #define CONFIGURE_UNLIMITED_ALLOCATION_SIZE 5
```

# <span id="page-595-0"></span>27.7 General System Configuration

This section describes general system configuration options.

## <span id="page-596-1"></span><span id="page-596-0"></span>27.7.1 CONFIGURE\_DIRTY\_MEMORY

#### CONSTANT:

CONFIGURE\_DIRTY\_MEMORY

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the memory areas used for the RTEMS Workspace and the C Program Heap are dirtied with a 0xCF byte pattern during system initialization.

## NOTES:

Dirtying memory can add significantly to system initialization time. It may assist in finding code that incorrectly assumes the contents of free memory areas is cleared to zero during system initialization. In case *[CONFIGURE\\_ZERO\\_WORKSPACE\\_AUTOMATICALLY](#page-620-0)* (page 593) is also defined, then the memory is first dirtied and then zeroed.

See also *[CONFIGURE\\_MALLOC\\_DIRTY](#page-604-0)* (page 577).

## <span id="page-597-1"></span><span id="page-597-0"></span>27.7.2 CONFIGURE\_DISABLE\_BSP\_SETTINGS

#### CONSTANT:

CONFIGURE\_DISABLE\_BSP\_SETTINGS

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the optional BSP provided settings listed below are disabled.

The optional BSP provided default values for the following application configuration options are disabled:

- *[CONFIGURE\\_IDLE\\_TASK\\_BODY](#page-736-0)* (page 709)
- *[CONFIGURE\\_IDLE\\_TASK\\_STACK\\_SIZE](#page-738-0)* (page 711)
- *[CONFIGURE\\_INTERRUPT\\_STACK\\_SIZE](#page-603-0)* (page 576)

The optional BSP provided initial extension set is disabled (see *[initial extension sets](#page-1067-1)*). The optional BSP provided prerequisite IO device drivers are disabled (see Device Driver Configuration). The optional BSP provided support for sbrk() is disabled.

This configuration option provides an all or nothing choice with respect to the optional BSP provided settings.

## <span id="page-598-1"></span><span id="page-598-0"></span>27.7.3 CONFIGURE\_DISABLE\_NEWLIB\_REENTRANCY

#### CONSTANT:

CONFIGURE\_DISABLE\_NEWLIB\_REENTRANCY

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the Newlib reentrancy support per thread is disabled and a global reentrancy structure is used.

## NOTES:

You can enable this option to reduce the size of the *[TCB](#page-1077-1)*. Use this option with care, since it can lead to race conditions and undefined system behaviour. For example, errno is no longer a thread-local variable if this option is enabled.

## <span id="page-599-1"></span><span id="page-599-0"></span>27.7.4 CONFIGURE\_EXECUTIVE\_RAM\_SIZE

#### CONSTANT:

CONFIGURE\_EXECUTIVE\_RAM\_SIZE

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

If this configuration option is undefined, then the RTEMS Workspace and task stack space size is calculated by <rtems/confdefs.h> based on the values configuration options.

## DESCRIPTION:

The value of this configuration option defines the RTEMS Workspace size in bytes.

## NOTES:

This is an advanced configuration option. Use it only if you know exactly what you are doing.

#### CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to [UINTPTR\\_MAX.](https://en.cppreference.com/w/c/types/integer)
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.

## <span id="page-600-1"></span><span id="page-600-0"></span>27.7.5 CONFIGURE\_EXTRA\_TASK\_STACKS

#### CONSTANT:

CONFIGURE\_EXTRA\_TASK\_STACKS

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the number of bytes the applications wishes to add to the task stack requirements calculated by <rtems/confdefs.h>.

#### NOTES:

This parameter is very important. If the application creates tasks with stacks larger then the minimum, then that memory is **not** accounted for by <rtems/confdefs.h>.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be small enough so that the task stack space calculation carried out by <rtems/confdefs.h> does not overflow an integer of type [uintptr\\_t.](https://en.cppreference.com/w/c/types/integer)

## <span id="page-601-1"></span><span id="page-601-0"></span>27.7.6 CONFIGURE\_INIT

CONSTANT:

CONFIGURE\_INIT

#### OPTION TYPE:

This configuration option is a boolean feature define.

#### DEFAULT CONFIGURATION:

There is no default configuration associated with this configuration option. If <rtems/confdefs. h> is included and this configuration option is not defined, then only white space is included.

## DESCRIPTION:

While this configuration option is defined, when the <rtems/confdefs.h> is included, the system settings defined by present application configuration options are statically allocated and initialized. All user provided application configuration options defined before the include of <rtems/confdefs.h> are evaluated. They define the actual system settings.

## <span id="page-602-1"></span><span id="page-602-0"></span>27.7.7 CONFIGURE\_INITIAL\_EXTENSIONS

#### CONSTANT:

CONFIGURE\_INITIAL\_EXTENSIONS

#### OPTION TYPE:

This configuration option is an initializer define.

#### DEFAULT VALUE:

The default value is the empty list.

#### DESCRIPTION:

The value of this configuration option is used to initialize the table of initial user extensions.

#### NOTES:

The value of this configuration option is placed before the entries of BSP\_INITIAL\_EXTENSION and after the entries of all other initial user extensions.

It is recommended that applications provide a fatal extension to customize the *[System Termina](#page-546-2)[tion Procedure](#page-546-2)* (page 519).

#### CONSTRAINTS:

The value of the configuration option shall be a list of initializers for structures of type *[rtems\\_extensions\\_table](#page-67-3)* (page 40).

## <span id="page-603-1"></span><span id="page-603-0"></span>27.7.8 CONFIGURE\_INTERRUPT\_STACK\_SIZE

#### CONSTANT:

CONFIGURE\_INTERRUPT\_STACK\_SIZE

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

If the *[CONFIGURE\\_DISABLE\\_BSP\\_SETTINGS](#page-597-0)* (page 570) configuration option is not defined and BSP\_INTERRUPT\_STACK\_SIZE is provided by the *[BSP](#page-1061-0)*, then the default value is defined by BSP\_INTERRUPT\_STACK\_SIZE, otherwise the default value is CPU\_STACK\_MINIMUM\_SIZE.

## DESCRIPTION:

The value of this configuration option defines the size of an interrupt stack in bytes.

## NOTES:

There is one interrupt stack available for each configured processor (*[CONFIG-](#page-606-0)[URE\\_MAXIMUM\\_PROCESSORS](#page-606-0)* (page 579)). The interrupt stack areas are statically allocated in a special linker section (.rtemsstack.interrupt). The placement of this linker section is BSP-specific.

Some BSPs use the interrupt stack as the initialization stack which is used to perform the sequential system initialization before the multithreading is started.

The interrupt stacks are covered by the stack checker, see *[CONFIG-](#page-614-0)[URE\\_STACK\\_CHECKER\\_ENABLED](#page-614-0)* (page 587). However, using a too small interrupt stack size may still result in undefined behaviour.

The interrupt stack size may depend on the interrupt priority settings, see also *[rtems\\_interrupt\\_set\\_priority\(\)](#page-229-0)* (page 202).

In releases before RTEMS 5.1 the default value was *[CONFIGURE\\_MINIMUM\\_TASK\\_STACK\\_SIZE](#page-613-0)* (page 586) instead of CPU\_STACK\_MINIMUM\_SIZE.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to a BSP-specific and application-specific minimum value.
- The value of the configuration option shall be small enough so that the interrupt stack area calculation carried out by <rtems/confdefs.h> does not overflow an integer of type [size\\_t.](https://en.cppreference.com/w/c/types/size_t)
- The value of the configuration option shall be aligned according to CPU\_INTERRUPT\_STACK\_ALIGNMENT.

## <span id="page-604-1"></span><span id="page-604-0"></span>27.7.9 CONFIGURE\_MALLOC\_DIRTY

#### CONSTANT:

CONFIGURE\_MALLOC\_DIRTY

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then each memory area returned by C Program Heap allocator functions such as malloc() is dirtied with a 0xCF byte pattern before it is handed over to the application.

#### NOTES:

The dirtying performed by this option is carried out for each successful memory allocation from the C Program Heap in contrast to *[CONFIGURE\\_DIRTY\\_MEMORY](#page-596-0)* (page 569) which dirties the memory only once during the system initialization.

## <span id="page-605-1"></span><span id="page-605-0"></span>27.7.10 CONFIGURE\_MAXIMUM\_FILE\_DESCRIPTORS

#### CONSTANT:

CONFIGURE\_MAXIMUM\_FILE\_DESCRIPTORS

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 3.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of file like objects that can be concurrently open.

## NOTES:

The default value of three file descriptors allows RTEMS to support standard input, output, and error I/O streams on /dev/console.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to [SIZE\\_MAX.](https://en.cppreference.com/w/c/types/limits)
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.

## <span id="page-606-1"></span><span id="page-606-0"></span>27.7.11 CONFIGURE\_MAXIMUM\_PROCESSORS

#### CONSTANT:

CONFIGURE\_MAXIMUM\_PROCESSORS

#### OPTION TYPE:

This configuration option is an integer define.

## DEFAULT VALUE:

The default value is 1.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of processors an application intends to use. The number of actually available processors depends on the hardware and may be less. It is recommended to use the smallest value suitable for the application in order to save memory. Each processor needs an IDLE task stack and interrupt stack for example.

## NOTES:

If there are more processors available than configured, the rest will be ignored.

This configuration option is only evaluated in SMP configurations of RTEMS (e.g. RTEMS was built with the SMP build configuration option enabled). In all other configurations it has no effect.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to one.
- The value of the configuration option shall be less than or equal to CPU\_MAXIMUM\_PROCESSORS.

## <span id="page-607-1"></span><span id="page-607-0"></span>27.7.12 CONFIGURE\_MAXIMUM\_THREAD\_LOCAL\_STORAGE\_SIZE

#### CONSTANT:

CONFIGURE\_MAXIMUM\_THREAD\_LOCAL\_STORAGE\_SIZE

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

If the value of this configuration option is greater than zero, then it defines the maximum threadlocal storage size, otherwise the thread-local storage size is defined by the linker depending on the thread-local storage objects used by the application in the statically-linked executable.

#### NOTES:

This configuration option can be used to reserve space for the dynamic linking of modules with thread-local storage objects.

If the thread-local storage size defined by the thread-local storage objects used by the application in the statically-linked executable is greater than a non-zero value of this configuration option, then a fatal error will occur during system initialization.

Use RTEMS\_ALIGN\_UP() and RTEMS\_TASK\_STORAGE\_ALIGNMENT to adjust the size to meet the minimum alignment requirement of a thread-local storage area.

The actual thread-local storage size is determined when the application executable is linked. The rtems-exeinfo command line tool included in the RTEMS Tools can be used to obtain the thread-local storage size and alignment of an application executable.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to [SIZE\\_MAX.](https://en.cppreference.com/w/c/types/limits)
- The value of the configuration option shall be an integral multiple of RTEMS\_TASK\_STORAGE\_ALIGNMENT.

## <span id="page-608-1"></span><span id="page-608-0"></span>27.7.13 CONFIGURE\_MAXIMUM\_THREAD\_NAME\_SIZE

#### CONSTANT:

CONFIGURE\_MAXIMUM\_THREAD\_NAME\_SIZE

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 16.

#### DESCRIPTION:

The value of this configuration option defines the maximum thread name size including the terminating NUL character.

## NOTES:

The default value was chosen for Linux compatibility, see [pthread\\_setname\\_np\(\).](http://man7.org/linux/man-pages/man3/pthread_setname_np.3.html)

The size of the thread control block is increased by the maximum thread name size.

This configuration option is available since RTEMS 5.1.

#### CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to [SIZE\\_MAX.](https://en.cppreference.com/w/c/types/limits)
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.

## <span id="page-609-1"></span><span id="page-609-0"></span>27.7.14 CONFIGURE\_MEMORY\_OVERHEAD

#### CONSTANT:

CONFIGURE\_MEMORY\_OVERHEAD

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the number of kilobytes the application wishes to add to the RTEMS Workspace size calculated by <rtems/confdefs.h>.

## NOTES:

This configuration option should only be used when it is suspected that a bug in <rtems/ confdefs.h> has resulted in an underestimation. Typically the memory allocation will be too low when an application does not account for all message queue buffers or task stacks, see *[CONFIGURE\\_MESSAGE\\_BUFFER\\_MEMORY](#page-610-0)* (page 583).

#### CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.
- The value of the configuration option shall be small enough so that the RTEMS Workspace size calculation carried out by <rtems/confdefs.h> does not overflow an integer of type [uintptr\\_t.](https://en.cppreference.com/w/c/types/integer)

## <span id="page-610-1"></span><span id="page-610-0"></span>27.7.15 CONFIGURE\_MESSAGE\_BUFFER\_MEMORY

#### CONSTANT:

CONFIGURE\_MESSAGE\_BUFFER\_MEMORY

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the number of bytes reserved for message queue buffers in the RTEMS Workspace.

## NOTES:

The configuration options *[CONFIGURE\\_MAXIMUM\\_MESSAGE\\_QUEUES](#page-644-0)* (page 617) and *[CON-](#page-667-0)[FIGURE\\_MAXIMUM\\_POSIX\\_MESSAGE\\_QUEUES](#page-667-0)* (page 640) define only how many message queues can be created by the application. The memory for the message buffers is configured by this option. For each message queue you have to reserve some memory for the message buffers. The size depends on the maximum number of pending messages and the maximum size of the messages of a message queue. Use the CONFIGURE\_MESSAGE\_BUFFERS\_FOR\_QUEUE() macro to specify the message buffer memory for each message queue and sum them up to define the value for CONFIGURE\_MAXIMUM\_MESSAGE\_QUEUES.

The interface for the CONFIGURE\_MESSAGE\_BUFFERS\_FOR\_QUEUE() help macro is as follows:

```
1 CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE( max_messages, max_msg_size )
```

Where max\_messages is the maximum number of pending messages and max\_msg\_size is the maximum size in bytes of the messages of the corresponding message queue. Both parameters shall be compile time constants. Not using this help macro (e.g. just using max\_messages \* max\_msg\_size) may result in an underestimate of the RTEMS Workspace size.

The following example illustrates how the CONFIGURE\_MESSAGE\_BUFFERS\_FOR\_QUEUE() help macro can be used to assist in calculating the message buffer memory required. In this example, there are two message queues used in this application. The first message queue has a maximum of 24 pending messages with the message structure defined by the type one\_message\_type. The other message queue has a maximum of 500 pending messages with the message structure defined by the type other\_message\_type.

```
1 #define CONFIGURE_MESSAGE_BUFFER_MEMORY ( \
2 CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE( \
3 24, \
4 sizeof( one_message_type ) \
5 ) \
6 + CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE( \
7 500, \
8 sizeof( other_message_type ) \
```

(continues on next page)

(continued from previous page)

![](_page_611_Picture_3.jpeg)

### CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.
- The value of the configuration option shall be small enough so that the RTEMS Workspace size calculation carried out by <rtems/confdefs.h> does not overflow an integer of type [uintptr\\_t.](https://en.cppreference.com/w/c/types/integer)

## <span id="page-612-1"></span><span id="page-612-0"></span>27.7.16 CONFIGURE\_MICROSECONDS\_PER\_TICK

#### CONSTANT:

CONFIGURE\_MICROSECONDS\_PER\_TICK

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 10000.

#### DESCRIPTION:

The value of this configuration option defines the length of time in microseconds between clock ticks (clock tick quantum).

When the clock tick quantum value is too low, the system will spend so much time processing clock ticks that it does not have processing time available to perform application work. In this case, the system will become unresponsive.

The lowest practical time quantum varies widely based upon the speed of the target hardware and the architectural overhead associated with interrupts. In general terms, you do not want to configure it lower than is needed for the application.

The clock tick quantum should be selected such that it all blocking and delay times in the application are evenly divisible by it. Otherwise, rounding errors will be introduced which may negatively impact the application.

#### NOTES:

This configuration option has no impact if the Clock Driver is not configured, see *[CONFIG-](#page-622-0)[URE\\_APPLICATION\\_DOES\\_NOT\\_NEED\\_CLOCK\\_DRIVER](#page-622-0)* (page 595).

There may be Clock Driver specific limits on the resolution or maximum value of a clock tick quantum.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to a value defined by the *[Clock Driver](#page-1062-3)*.
- The value of the configuration option shall be less than or equal to a value defined by the *[Clock Driver](#page-1062-3)*.
- The resulting clock ticks per second should be an integer.

## <span id="page-613-1"></span><span id="page-613-0"></span>27.7.17 CONFIGURE\_MINIMUM\_TASK\_STACK\_SIZE

#### CONSTANT:

CONFIGURE\_MINIMUM\_TASK\_STACK\_SIZE

#### OPTION TYPE:

This configuration option is an integer define.

## DEFAULT VALUE:

The default value is CPU\_STACK\_MINIMUM\_SIZE.

#### DESCRIPTION:

The value of this configuration option defines the minimum stack size in bytes for every user task or thread in the system.

## NOTES:

Adjusting this parameter should be done with caution. Examining the actual stack usage using the stack checker usage reporting facility is recommended (see also *[CONFIG-](#page-614-0)[URE\\_STACK\\_CHECKER\\_ENABLED](#page-614-0)* (page 587)).

This parameter can be used to lower the minimum from that recommended. This can be used in low memory systems to reduce memory consumption for stacks. However, this shall be done with caution as it could increase the possibility of a blown task stack.

This parameter can be used to increase the minimum from that recommended. This can be used in higher memory systems to reduce the risk of stack overflow without performing analysis on actual consumption.

By default, this configuration parameter defines also the minimum stack size of POSIX threads. This can be changed with the *[CONFIGURE\\_MINIMUM\\_POSIX\\_THREAD\\_STACK\\_SIZE](#page-673-0)* (page 646) configuration option.

In releases before RTEMS 5.1 the CONFIGURE\_MINIMUM\_TASK\_STACK\_SIZE was used to define the default value of *[CONFIGURE\\_INTERRUPT\\_STACK\\_SIZE](#page-603-0)* (page 576).

## CONSTRAINTS:

- The value of the configuration option shall be small enough so that the task stack space calculation carried out by <rtems/confdefs.h> does not overflow an integer of type [uintptr\\_t.](https://en.cppreference.com/w/c/types/integer)
- The value of the configuration option shall be greater than or equal to a BSP-specific and application-specific minimum value.

## <span id="page-614-1"></span><span id="page-614-0"></span>27.7.18 CONFIGURE\_STACK\_CHECKER\_ENABLED

#### CONSTANT:

CONFIGURE\_STACK\_CHECKER\_ENABLED

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the stack checker is enabled.

#### NOTES:

The stack checker performs run-time stack bounds checking. This increases the time required to create tasks as well as adding overhead to each context switch.

In 4.9 and older, this configuration option was named STACK\_CHECKER\_ON.

## <span id="page-615-1"></span><span id="page-615-0"></span>27.7.19 CONFIGURE\_TICKS\_PER\_TIMESLICE

#### CONSTANT:

CONFIGURE\_TICKS\_PER\_TIMESLICE

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 50.

#### DESCRIPTION:

The value of this configuration option defines the length of the timeslice quantum in ticks for each task.

## NOTES:

This configuration option has no impact if the Clock Driver is not configured, see *[CONFIG-](#page-622-0)[URE\\_APPLICATION\\_DOES\\_NOT\\_NEED\\_CLOCK\\_DRIVER](#page-622-0)* (page 595).

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to one.
- The value of the configuration option shall be less than or equal to [UINT32\\_MAX.](https://en.cppreference.com/w/c/types/integer)

## <span id="page-616-1"></span><span id="page-616-0"></span>27.7.20 CONFIGURE\_UNIFIED\_WORK\_AREAS

#### CONSTANT:

CONFIGURE\_UNIFIED\_WORK\_AREAS

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then there will be separate memory pools for the RTEMS Workspace and C Program Heap.

#### DESCRIPTION:

In case this configuration option is defined, then the RTEMS Workspace and the C Program Heap will be one pool of memory.

#### NOTES:

Having separate pools does have some advantages in the event a task blows a stack or writes outside its memory area. However, in low memory systems the overhead of the two pools plus the potential for unused memory in either pool is very undesirable.

In high memory environments, this is desirable when you want to use the *[Unlimited Objects](#page-593-0)* (page 566) option. You will be able to create objects until you run out of all available memory rather then just until you run out of RTEMS Workspace.

## <span id="page-617-1"></span><span id="page-617-0"></span>27.7.21 CONFIGURE\_UNLIMITED\_ALLOCATION\_SIZE

#### CONSTANT:

CONFIGURE\_UNLIMITED\_ALLOCATION\_SIZE

#### OPTION TYPE:

This configuration option is an integer define.

## DEFAULT VALUE:

The default value is 8.

#### DESCRIPTION:

If *[CONFIGURE\\_UNLIMITED\\_OBJECTS](#page-618-0)* (page 591) is defined, then the value of this configuration option defines the default objects maximum of all object classes supporting *[Unlimited Objects](#page-593-0)* (page 566) to rtems\_resource\_unlimited( CONFIGURE\_UNLIMITED\_ALLOCATION\_SIZE ).

## NOTES:

By allowing users to declare all resources as being unlimited the user can avoid identifying and limiting the resources used.

The object maximum of each class can be configured also individually using the *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) macro.

## CONSTRAINTS:

The value of the configuration option shall meet the constraints of all object classes to which it is applied.

## <span id="page-618-1"></span><span id="page-618-0"></span>27.7.22 CONFIGURE\_UNLIMITED\_OBJECTS

#### CONSTANT:

CONFIGURE\_UNLIMITED\_OBJECTS

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then unlimited objects are used by default.

#### NOTES:

When using unlimited objects, it is common practice to also specify *[CONFIG-](#page-616-0)[URE\\_UNIFIED\\_WORK\\_AREAS](#page-616-0)* (page 589) so the system operates with a single pool of memory for both RTEMS Workspace and C Program Heap.

This option does not override an explicit configuration for a particular object class by the user. See also *[CONFIGURE\\_UNLIMITED\\_ALLOCATION\\_SIZE](#page-617-0)* (page 590).

## <span id="page-619-1"></span><span id="page-619-0"></span>27.7.23 CONFIGURE\_VERBOSE\_SYSTEM\_INITIALIZATION

#### CONSTANT:

CONFIGURE\_VERBOSE\_SYSTEM\_INITIALIZATION

## OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the system initialization is verbose.

#### NOTES:

You may use this feature to debug system initialization issues. The *[printk\(\)](#page-520-0)* (page 493) function is used to print the information.

## <span id="page-620-1"></span><span id="page-620-0"></span>27.7.24 CONFIGURE\_ZERO\_WORKSPACE\_AUTOMATICALLY

#### CONSTANT:

CONFIGURE\_ZERO\_WORKSPACE\_AUTOMATICALLY

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the memory areas used for the RTEMS Workspace and the C Program Heap are zeroed with a 0x00 byte pattern during system initialization.

## NOTES:

Zeroing memory can add significantly to the system initialization time. It is not necessary for RTEMS but is often assumed by support libraries. In case *[CONFIGURE\\_DIRTY\\_MEMORY](#page-596-0)* (page 569) is also defined, then the memory is first dirtied and then zeroed.

# <span id="page-621-0"></span>27.8 Device Driver Configuration

This section describes configuration options related to the device drivers. Note that network device drivers are not covered by the following options.

## <span id="page-622-1"></span><span id="page-622-0"></span>27.8.1 CONFIGURE\_APPLICATION\_DOES\_NOT\_NEED\_CLOCK\_DRIVER

#### CONSTANT:

CONFIGURE\_APPLICATION\_DOES\_NOT\_NEED\_CLOCK\_DRIVER

#### OPTION TYPE:

This configuration option is a boolean feature define.

#### DEFAULT CONFIGURATION:

If this configuration option is undefined, then a Clock Driver may be initialized during system initialization.

#### DESCRIPTION:

In case this configuration option is defined, then **no** Clock Driver is initialized during system initialization.

#### NOTES:

This configuration parameter is intended to prevent the common user error of using the Hello World example as the baseline for an application and leaving out a clock tick source.

The application shall define exactly one of the following configuration options

- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_CLOCK\\_DRIVER](#page-625-0)* (page 598),
- CONFIGURE\_APPLICATION\_DOES\_NOT\_NEED\_CLOCK\_DRIVER, or
- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_TIMER\\_DRIVER](#page-634-0)* (page 607),

otherwise a compile time error in the configuration file will occur.

## <span id="page-623-1"></span><span id="page-623-0"></span>27.8.2 CONFIGURE\_APPLICATION\_EXTRA\_DRIVERS

#### CONSTANT:

CONFIGURE\_APPLICATION\_EXTRA\_DRIVERS

#### OPTION TYPE:

This configuration option is an initializer define.

## DEFAULT VALUE:

The default value is the empty list.

#### DESCRIPTION:

The value of this configuration option is used to initialize the Device Driver Table.

#### NOTES:

The value of this configuration option is placed after the entries of other device driver configuration options.

See *[CONFIGURE\\_APPLICATION\\_PREREQUISITE\\_DRIVERS](#page-637-0)* (page 610) for an alternative placement of application device driver initializers.

#### CONSTRAINTS:

The value of the configuration option shall be a list of initializers for structures of type *[rtems\\_driver\\_address\\_table](#page-67-0)* (page 40).

## <span id="page-624-1"></span><span id="page-624-0"></span>27.8.3 CONFIGURE\_APPLICATION\_NEEDS\_ATA\_DRIVER

#### CONSTANT:

CONFIGURE\_APPLICATION\_NEEDS\_ATA\_DRIVER

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the ATA Driver is initialized during system initialization.

## NOTES:

Most BSPs do not include support for an ATA Driver.

If this option is defined and the BSP does not have this device driver, then the user will get a link time error for an undefined symbol.

## <span id="page-625-1"></span><span id="page-625-0"></span>27.8.4 CONFIGURE\_APPLICATION\_NEEDS\_CLOCK\_DRIVER

#### CONSTANT:

CONFIGURE\_APPLICATION\_NEEDS\_CLOCK\_DRIVER

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the Clock Driver is initialized during system initialization.

## NOTES:

The Clock Driver is responsible for providing a regular interrupt which invokes a clock tick directive.

The application shall define exactly one of the following configuration options

- CONFIGURE\_APPLICATION\_NEEDS\_CLOCK\_DRIVER,
- *[CONFIGURE\\_APPLICATION\\_DOES\\_NOT\\_NEED\\_CLOCK\\_DRIVER](#page-622-0)* (page 595), or
- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_TIMER\\_DRIVER](#page-634-0)* (page 607),

otherwise a compile time error in the configuration file will occur.

## <span id="page-626-1"></span><span id="page-626-0"></span>27.8.5 CONFIGURE\_APPLICATION\_NEEDS\_CONSOLE\_DRIVER

#### CONSTANT:

CONFIGURE\_APPLICATION\_NEEDS\_CONSOLE\_DRIVER

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the Console Driver is initialized during system initialization.

## NOTES:

The Console Driver is responsible for providing the /dev/console device file. This device is used to initialize the standard input, output, and error file descriptors.

BSPs should be constructed in a manner that allows *[printk\(\)](#page-520-0)* (page 493) to work properly without the need for the Console Driver to be configured.

#### The

- CONFIGURE\_APPLICATION\_NEEDS\_CONSOLE\_DRIVER,
- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_SIMPLE\\_CONSOLE\\_DRIVER](#page-631-0)* (page 604), and
- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_SIMPLE\\_TASK\\_CONSOLE\\_DRIVER](#page-632-0)* (page 605)

configuration options are mutually exclusive.

## <span id="page-627-1"></span><span id="page-627-0"></span>27.8.6 CONFIGURE\_APPLICATION\_NEEDS\_FRAME\_BUFFER\_DRIVER

#### CONSTANT:

CONFIGURE\_APPLICATION\_NEEDS\_FRAME\_BUFFER\_DRIVER

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the Frame Buffer Driver is initialized during system initialization.

## NOTES:

Most BSPs do not include support for a Frame Buffer Driver. This is because many boards do not include the required hardware.

If this option is defined and the BSP does not have this device driver, then the user will get a link time error for an undefined symbol.

## <span id="page-628-1"></span><span id="page-628-0"></span>27.8.7 CONFIGURE\_APPLICATION\_NEEDS\_IDE\_DRIVER

#### CONSTANT:

CONFIGURE\_APPLICATION\_NEEDS\_IDE\_DRIVER

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the IDE Driver is initialized during system initialization.

## NOTES:

Most BSPs do not include support for an IDE Driver.

If this option is defined and the BSP does not have this device driver, then the user will get a link time error for an undefined symbol.

## <span id="page-629-1"></span><span id="page-629-0"></span>27.8.8 CONFIGURE\_APPLICATION\_NEEDS\_NULL\_DRIVER

#### CONSTANT:

CONFIGURE\_APPLICATION\_NEEDS\_NULL\_DRIVER

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the /dev/null Driver is initialized during system initialization.

## NOTES:

This device driver is supported by all BSPs.

## <span id="page-630-1"></span><span id="page-630-0"></span>27.8.9 CONFIGURE\_APPLICATION\_NEEDS\_RTC\_DRIVER

#### CONSTANT:

CONFIGURE\_APPLICATION\_NEEDS\_RTC\_DRIVER

#### OPTION TYPE:

This configuration option is a boolean feature define.

#### DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the Real-Time Clock Driver is initialized during system initialization.

## NOTES:

Most BSPs do not include support for a real-time clock (RTC). This is because many boards do not include the required hardware.

If this is defined and the BSP does not have this device driver, then the user will get a link time error for an undefined symbol.

## <span id="page-631-1"></span><span id="page-631-0"></span>27.8.10 CONFIGURE\_APPLICATION\_NEEDS\_SIMPLE\_CONSOLE\_DRIVER

#### CONSTANT:

CONFIGURE\_APPLICATION\_NEEDS\_SIMPLE\_CONSOLE\_DRIVER

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the Simple Console Driver is initialized during system initialization.

## NOTES:

This device driver is responsible for providing the /dev/console device file. This device is used to initialize the standard input, output, and error file descriptors.

This device driver reads via *[getchark\(\)](#page-523-0)* (page 496).

This device driver writes via *[rtems\\_putc\(\)](#page-517-0)* (page 490).

The Termios framework is not used. There is no support to change device settings, e.g. baud, stop bits, parity, etc.

#### The

- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_CONSOLE\\_DRIVER](#page-626-0)* (page 599),
- CONFIGURE\_APPLICATION\_NEEDS\_SIMPLE\_CONSOLE\_DRIVER, and
- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_SIMPLE\\_TASK\\_CONSOLE\\_DRIVER](#page-632-0)* (page 605)

configuration options are mutually exclusive.

## <span id="page-632-1"></span><span id="page-632-0"></span>27.8.11 CONFIGURE\_APPLICATION\_NEEDS\_SIMPLE\_TASK\_CONSOLE\_DRIVER

#### CONSTANT:

CONFIGURE\_APPLICATION\_NEEDS\_SIMPLE\_TASK\_CONSOLE\_DRIVER

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the Simple Task Console Driver is initialized during system initialization.

## NOTES:

This device driver is responsible for providing the /dev/console device file. This device is used to initialize the standard input, output, and error file descriptors.

This device driver reads via *[getchark\(\)](#page-523-0)* (page 496).

This device driver writes into a write buffer. The count of characters written into the write buffer is returned. It might be less than the requested count, in case the write buffer is full. The write is non-blocking and may be called from interrupt context. A dedicated task reads from the write buffer and outputs the characters via *[rtems\\_putc\(\)](#page-517-0)* (page 490). This task runs with the least important priority. The write buffer size is 2047 characters and it is not configurable.

Use fsync( STDOUT\_FILENO ) or fdatasync( STDOUT\_FILENO ) to drain the write buffer.

The Termios framework is not used. There is no support to change device settings, e.g. baud, stop bits, parity, etc.

## The

- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_CONSOLE\\_DRIVER](#page-626-0)* (page 599),
- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_SIMPLE\\_CONSOLE\\_DRIVER](#page-631-0)* (page 604), and
- CONFIGURE\_APPLICATION\_NEEDS\_SIMPLE\_TASK\_CONSOLE\_DRIVER

configuration options are mutually exclusive.

## <span id="page-633-1"></span><span id="page-633-0"></span>27.8.12 CONFIGURE\_APPLICATION\_NEEDS\_STUB\_DRIVER

#### CONSTANT:

CONFIGURE\_APPLICATION\_NEEDS\_STUB\_DRIVER

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the Stub Driver is initialized during system initialization.

## NOTES:

This device driver simply provides entry points that return successful and is primarily a test fixture. It is supported by all BSPs.

## <span id="page-634-1"></span><span id="page-634-0"></span>27.8.13 CONFIGURE\_APPLICATION\_NEEDS\_TIMER\_DRIVER

#### CONSTANT:

CONFIGURE\_APPLICATION\_NEEDS\_TIMER\_DRIVER

## OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the Benchmark Timer Driver is initialized during system initialization.

## NOTES:

The Benchmark Timer Driver is intended for the benchmark tests of the RTEMS Testsuite. Applications should not use this driver.

The application shall define exactly one of the following configuration options

- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_CLOCK\\_DRIVER](#page-625-0)* (page 598),
- *[CONFIGURE\\_APPLICATION\\_DOES\\_NOT\\_NEED\\_CLOCK\\_DRIVER](#page-622-0)* (page 595), or
- CONFIGURE\_APPLICATION\_NEEDS\_TIMER\_DRIVER,

otherwise a compile time error will occur.

## <span id="page-635-1"></span><span id="page-635-0"></span>27.8.14 CONFIGURE\_APPLICATION\_NEEDS\_WATCHDOG\_DRIVER

#### CONSTANT:

CONFIGURE\_APPLICATION\_NEEDS\_WATCHDOG\_DRIVER

#### OPTION TYPE:

This configuration option is a boolean feature define.

#### DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the Watchdog Driver is initialized during system initialization.

#### NOTES:

Most BSPs do not include support for a watchdog device driver. This is because many boards do not include the required hardware.

If this is defined and the BSP does not have this device driver, then the user will get a link time error for an undefined symbol.

## <span id="page-636-1"></span><span id="page-636-0"></span>27.8.15 CONFIGURE\_APPLICATION\_NEEDS\_ZERO\_DRIVER

#### CONSTANT:

CONFIGURE\_APPLICATION\_NEEDS\_ZERO\_DRIVER

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the /dev/zero Driver is initialized during system initialization.

## NOTES:

This device driver is supported by all BSPs.

## <span id="page-637-1"></span><span id="page-637-0"></span>27.8.16 CONFIGURE\_APPLICATION\_PREREQUISITE\_DRIVERS

#### CONSTANT:

CONFIGURE\_APPLICATION\_PREREQUISITE\_DRIVERS

#### OPTION TYPE:

This configuration option is an initializer define.

## DEFAULT VALUE:

The default value is the empty list.

#### DESCRIPTION:

The value of this configuration option is used to initialize the Device Driver Table.

#### NOTES:

The value of this configuration option is placed after the entries defined by CONFIGURE\_BSP\_PREREQUISITE\_DRIVERS and before all other device driver configuration options.

See *[CONFIGURE\\_APPLICATION\\_EXTRA\\_DRIVERS](#page-623-0)* (page 596) for an alternative placement of application device driver initializers.

#### CONSTRAINTS:

The value of the configuration option shall be a list of initializers for structures of type *[rtems\\_driver\\_address\\_table](#page-67-0)* (page 40).

## <span id="page-638-1"></span><span id="page-638-0"></span>27.8.17 CONFIGURE\_ATA\_DRIVER\_TASK\_PRIORITY

#### CONSTANT:

CONFIGURE\_ATA\_DRIVER\_TASK\_PRIORITY

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 140.

#### DESCRIPTION:

The value of this configuration option defines the ATA task priority.

#### NOTES:

This configuration option is only evaluated if the configuration option *[CONFIG-](#page-624-0)[URE\\_APPLICATION\\_NEEDS\\_ATA\\_DRIVER](#page-624-0)* (page 597) is defined.

## CONSTRAINTS:

The value of the configuration option shall be a valid Classic API task priority. The set of valid task priorities depends on the scheduler configuration.

## <span id="page-639-1"></span><span id="page-639-0"></span>27.8.18 CONFIGURE\_EXCEPTION\_TO\_SIGNAL\_MAPPING

#### CONSTANT:

CONFIGURE\_EXCEPTION\_TO\_SIGNAL\_MAPPING

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the machine exception to POSIX signal mapping is configured during system initialization.

## NOTES:

This device driver is responsible for setting up a mapping from machine exceptions to POSIX signals so that applications may consume them and alter task execution as necessary.

This is especially useful for applications written in Ada or C++.

## <span id="page-640-1"></span><span id="page-640-0"></span>27.8.19 CONFIGURE\_MAXIMUM\_DRIVERS

#### CONSTANT:

CONFIGURE\_MAXIMUM\_DRIVERS

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

This is computed by default, and is set to the number of statically configured device drivers configured using the following configuration options:

- *[CONFIGURE\\_APPLICATION\\_EXTRA\\_DRIVERS](#page-623-0)* (page 596)
- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_ATA\\_DRIVER](#page-624-0)* (page 597)
- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_CLOCK\\_DRIVER](#page-625-0)* (page 598)
- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_CONSOLE\\_DRIVER](#page-626-0)* (page 599)
- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_FRAME\\_BUFFER\\_DRIVER](#page-627-0)* (page 600)
- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_IDE\\_DRIVER](#page-628-0)* (page 601)
- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_LIBBLOCK](#page-715-0)* (page 688)
- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_NULL\\_DRIVER](#page-629-0)* (page 602)
- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_RTC\\_DRIVER](#page-630-0)* (page 603)
- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_SIMPLE\\_CONSOLE\\_DRIVER](#page-631-0)* (page 604)
- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_SIMPLE\\_TASK\\_CONSOLE\\_DRIVER](#page-632-0)* (page 605)
- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_STUB\\_DRIVER](#page-633-0)* (page 606)
- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_TIMER\\_DRIVER](#page-634-0)* (page 607)
- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_WATCHDOG\\_DRIVER](#page-635-0)* (page 608)
- *[CONFIGURE\\_APPLICATION\\_NEEDS\\_ZERO\\_DRIVER](#page-636-0)* (page 609)
- *[CONFIGURE\\_APPLICATION\\_PREREQUISITE\\_DRIVERS](#page-637-0)* (page 610)

If the *[CONFIGURE\\_DISABLE\\_BSP\\_SETTINGS](#page-597-0)* (page 570) configuration option is not defined and the *[BSP](#page-1061-0)* provides CONFIGURE\_BSP\_PREREQUISITE\_DRIVERS, then the BSP-provided prerequisite device drivers are also taken into account.

#### DESCRIPTION:

The value of this configuration option defines the number of device drivers.

#### NOTES:

If the application will dynamically install device drivers, then the configuration option value shall be larger than the number of statically configured device drivers.

### CONSTRAINTS:

- The value of the configuration option shall be less than or equal to [SIZE\\_MAX.](https://en.cppreference.com/w/c/types/limits)
- The value of the configuration option shall be greater than or equal than the number of statically configured device drivers.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.

# <span id="page-642-0"></span>27.9 Classic API Configuration

This section describes configuration options related to the Classic API.

## <span id="page-643-1"></span><span id="page-643-0"></span>27.9.1 CONFIGURE\_MAXIMUM\_BARRIERS

#### CONSTANT:

CONFIGURE\_MAXIMUM\_BARRIERS

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of Classic API Barriers that can be concurrently active.

## NOTES:

This object class can be configured in unlimited allocation mode, see *[Unlimited Objects](#page-593-0)* (page 566).

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to 65535.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.
- The value of the configuration option may be defined through *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) the enable unlimited objects for the object class, if the value passed to *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) satisfies all other constraints of the configuration option.

## <span id="page-644-1"></span><span id="page-644-0"></span>27.9.2 CONFIGURE\_MAXIMUM\_MESSAGE\_QUEUES

#### CONSTANT:

CONFIGURE\_MAXIMUM\_MESSAGE\_QUEUES

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of Classic API Message Queues that can be concurrently active.

## NOTES:

This object class can be configured in unlimited allocation mode, see *[Unlimited Objects](#page-593-0)* (page 566). You have to account for the memory used to store the messages of each message queue, see *[CONFIGURE\\_MESSAGE\\_BUFFER\\_MEMORY](#page-610-0)* (page 583).

#### CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to 65535.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.
- The value of the configuration option may be defined through *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) the enable unlimited objects for the object class, if the value passed to *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) satisfies all other constraints of the configuration option.

## <span id="page-645-1"></span><span id="page-645-0"></span>27.9.3 CONFIGURE\_MAXIMUM\_PARTITIONS

#### CONSTANT:

CONFIGURE\_MAXIMUM\_PARTITIONS

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of Classic API Partitions that can be concurrently active.

## NOTES:

This object class can be configured in unlimited allocation mode, see *[Unlimited Objects](#page-593-0)* (page 566).

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to 65535.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.
- The value of the configuration option may be defined through *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) the enable unlimited objects for the object class, if the value passed to *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) satisfies all other constraints of the configuration option.

## <span id="page-646-1"></span><span id="page-646-0"></span>27.9.4 CONFIGURE\_MAXIMUM\_PERIODS

#### CONSTANT:

CONFIGURE\_MAXIMUM\_PERIODS

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of Classic API Periods that can be concurrently active.

## NOTES:

This object class can be configured in unlimited allocation mode, see *[Unlimited Objects](#page-593-0)* (page 566).

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to 65535.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.
- The value of the configuration option may be defined through *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) the enable unlimited objects for the object class, if the value passed to *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) satisfies all other constraints of the configuration option.

## <span id="page-647-1"></span><span id="page-647-0"></span>27.9.5 CONFIGURE\_MAXIMUM\_PORTS

#### CONSTANT:

CONFIGURE\_MAXIMUM\_PORTS

#### OPTION TYPE:

This configuration option is an integer define.

## DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of Classic API Ports that can be concurrently active.

## NOTES:

This object class can be configured in unlimited allocation mode, see *[Unlimited Objects](#page-593-0)* (page 566).

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to 65535.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.
- The value of the configuration option may be defined through *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) the enable unlimited objects for the object class, if the value passed to *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) satisfies all other constraints of the configuration option.

## <span id="page-648-1"></span><span id="page-648-0"></span>27.9.6 CONFIGURE\_MAXIMUM\_REGIONS

#### CONSTANT:

CONFIGURE\_MAXIMUM\_REGIONS

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of Classic API Regions that can be concurrently active.

## NOTES:

This object class can be configured in unlimited allocation mode, see *[Unlimited Objects](#page-593-0)* (page 566).

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to 65535.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.
- The value of the configuration option may be defined through *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) the enable unlimited objects for the object class, if the value passed to *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) satisfies all other constraints of the configuration option.

## <span id="page-649-1"></span><span id="page-649-0"></span>27.9.7 CONFIGURE\_MAXIMUM\_SEMAPHORES

#### CONSTANT:

CONFIGURE\_MAXIMUM\_SEMAPHORES

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of Classic API Semaphore that can be concurrently active.

## NOTES:

This object class can be configured in unlimited allocation mode, see *[Unlimited Objects](#page-593-0)* (page 566).

In SMP configurations, the size of a Semaphore Control Block depends on the scheduler count (see *[Configuration Step 3 - Scheduler Table](#page-757-0)* (page 730)). The semaphores using the *[Multiproces](#page-57-0)[sor Resource Sharing Protocol \(MrsP\)](#page-57-0)* (page 30) need a ceiling priority per scheduler.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to 65535.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.
- The value of the configuration option may be defined through *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) the enable unlimited objects for the object class, if the value passed to *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) satisfies all other constraints of the configuration option.

## <span id="page-650-1"></span><span id="page-650-0"></span>27.9.8 CONFIGURE\_MAXIMUM\_TASKS

#### CONSTANT:

CONFIGURE\_MAXIMUM\_TASKS

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of Classic API Tasks that can be concurrently active.

## NOTES:

This object class can be configured in unlimited allocation mode, see *[Unlimited Objects](#page-593-0)* (page 566).

The calculations for the required memory in the RTEMS Workspace for tasks assume that each task has a minimum stack size and has floating point support enabled. The configuration option *[CONFIGURE\\_EXTRA\\_TASK\\_STACKS](#page-600-0)* (page 573) is used to specify task stack requirements *above* the minimum size required.

The maximum number of POSIX threads is specified by *[CONFIG-](#page-671-0)[URE\\_MAXIMUM\\_POSIX\\_THREADS](#page-671-0)* (page 644).

A future enhancement to <rtems/confdefs.h> could be to eliminate the assumption that all tasks have floating point enabled. This would require the addition of a new configuration parameter to specify the number of tasks which enable floating point support.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to 65535.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.
- The value of the configuration option shall be small enough so that the task stack space calculation carried out by <rtems/confdefs.h> does not overflow an integer of type [uintptr\\_t.](https://en.cppreference.com/w/c/types/integer)
- The value of the configuration option may be defined through *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) the enable unlimited objects for the object class, if the value passed to *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) satisfies all other constraints of the configuration option.

## <span id="page-651-1"></span><span id="page-651-0"></span>27.9.9 CONFIGURE\_MAXIMUM\_TIMERS

#### CONSTANT:

CONFIGURE\_MAXIMUM\_TIMERS

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of Classic API Timers that can be concurrently active.

## NOTES:

This object class can be configured in unlimited allocation mode, see *[Unlimited Objects](#page-593-0)* (page 566).

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to 65535.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.
- The value of the configuration option may be defined through *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) the enable unlimited objects for the object class, if the value passed to *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) satisfies all other constraints of the configuration option.

## <span id="page-652-1"></span><span id="page-652-0"></span>27.9.10 CONFIGURE\_MAXIMUM\_USER\_EXTENSIONS

#### CONSTANT:

CONFIGURE\_MAXIMUM\_USER\_EXTENSIONS

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of Classic API User Extensions that can be concurrently active.

## NOTES:

This object class cannot be configured in unlimited allocation mode.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to 65535.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.

## <span id="page-653-1"></span><span id="page-653-0"></span>27.9.11 CONFIGURE\_MINIMUM\_TASKS\_WITH\_USER\_PROVIDED\_STORAGE

#### CONSTANT:

CONFIGURE\_MINIMUM\_TASKS\_WITH\_USER\_PROVIDED\_STORAGE

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the minimum count of Classic API Tasks which are constructed by *[rtems\\_task\\_construct\(\)](#page-140-0)* (page 113).

## NOTES:

By default, the calculation for the required memory in the RTEMS Workspace for tasks assumes that all Classic API Tasks are created by *[rtems\\_task\\_create\(\)](#page-136-0)* (page 109). This configuration option can be used to reduce the required memory for the system-provided task storage areas since tasks constructed by *[rtems\\_task\\_construct\(\)](#page-140-0)* (page 113) use a user-provided task storage area.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to *[CONFIG-](#page-650-0)[URE\\_MAXIMUM\\_TASKS](#page-650-0)* (page 623).

# <span id="page-654-0"></span>27.10 Classic API Initialization Task Configuration

This section describes configuration options related to the Classic API initialization task.

## <span id="page-655-1"></span><span id="page-655-0"></span>27.10.1 CONFIGURE\_INIT\_TASK\_ARGUMENTS

#### CONSTANT:

CONFIGURE\_INIT\_TASK\_ARGUMENTS

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines task argument of the Classic API initialization task.

#### CONSTRAINTS:

The value of the configuration option shall be convertible to an integer of type *[rtems\\_task\\_argument](#page-81-1)* (page 54).

## <span id="page-656-1"></span><span id="page-656-0"></span>27.10.2 CONFIGURE\_INIT\_TASK\_ATTRIBUTES

#### CONSTANT:

CONFIGURE\_INIT\_TASK\_ATTRIBUTES

## OPTION TYPE:

This configuration option is an integer define.

## DEFAULT VALUE:

The default value is RTEMS\_DEFAULT\_ATTRIBUTES.

#### DESCRIPTION:

The value of this configuration option defines the task attributes of the Classic API initialization task.

## CONSTRAINTS:

The value of the configuration option shall be a valid task attribute set.

## <span id="page-657-1"></span><span id="page-657-0"></span>27.10.3 CONFIGURE\_INIT\_TASK\_CONSTRUCT\_STORAGE\_SIZE

#### CONSTANT:

CONFIGURE\_INIT\_TASK\_CONSTRUCT\_STORAGE\_SIZE

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

This configuration option has no default value. If it is not specified, then the Classic API initialization task will be created with the stack size defined by the *[CONFIG-](#page-662-0)[URE\\_INIT\\_TASK\\_STACK\\_SIZE](#page-662-0)* (page 635) configuration option.

## DESCRIPTION:

The value of this configuration option defines the task storage size of the Classic API initialization task.

#### NOTES:

If this configuration option is specified, then

- a task storage area of the specified size is statically allocated by <rtems/confdefs.h> for the Classic API initialization task,
- the Classic API initialization task is constructed by *[rtems\\_task\\_construct\(\)](#page-140-0)* (page 113) instead of using *[rtems\\_task\\_create\(\)](#page-136-0)* (page 109),
- the maximum thread-local storage size defined by *[CONFIG-](#page-607-0)[URE\\_MAXIMUM\\_THREAD\\_LOCAL\\_STORAGE\\_SIZE](#page-607-0)* (page 580) is used for the Classic API initialization task,
- the Classic API initialization task should be accounted for in *[CONFIG-](#page-653-0)[URE\\_MINIMUM\\_TASKS\\_WITH\\_USER\\_PROVIDED\\_STORAGE](#page-653-0)* (page 626), and
- the task storage area used for the Classic API initialization task is not reclaimed by the system if the task is deleted.

#### The

- *[CONFIGURE\\_INIT\\_TASK\\_STACK\\_SIZE](#page-662-0)* (page 635) and
- CONFIGURE\_INIT\_TASK\_CONSTRUCT\_STORAGE\_SIZE

configuration options are mutually exclusive.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to *[CONFIG-](#page-613-0)[URE\\_MINIMUM\\_TASK\\_STACK\\_SIZE](#page-613-0)* (page 586).
- The value of the configuration option shall be defined using *[RTEMS\\_TASK\\_STORAGE\\_SIZE\(\)](#page-171-0)* (page 144).

## <span id="page-658-1"></span><span id="page-658-0"></span>27.10.4 CONFIGURE\_INIT\_TASK\_ENTRY\_POINT

#### CONSTANT:

CONFIGURE\_INIT\_TASK\_ENTRY\_POINT

#### OPTION TYPE:

This configuration option is an initializer define.

#### DEFAULT VALUE:

The default value is Init.

#### DESCRIPTION:

The value of this configuration option initializes the entry point of the Classic API initialization task.

## NOTES:

The application shall provide the function referenced by this configuration option.

## CONSTRAINTS:

The value of the configuration option shall be defined to a valid function pointer of the type void ( \*entry\_point )( rtems\_task\_argument ).

## <span id="page-659-1"></span><span id="page-659-0"></span>27.10.5 CONFIGURE\_INIT\_TASK\_INITIAL\_MODES

#### CONSTANT:

CONFIGURE\_INIT\_TASK\_INITIAL\_MODES

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

In SMP configurations, the default value is RTEMS\_DEFAULT\_MODES otherwise the default value is RTEMS\_NO\_PREEMPT.

## DESCRIPTION:

The value of this configuration option defines the initial execution mode of the Classic API initialization task.

## CONSTRAINTS:

The value of the configuration option shall be a valid task mode set.

## <span id="page-660-1"></span><span id="page-660-0"></span>27.10.6 CONFIGURE\_INIT\_TASK\_NAME

#### CONSTANT:

CONFIGURE\_INIT\_TASK\_NAME

## OPTION TYPE:

This configuration option is an integer define.

## DEFAULT VALUE:

The default value is rtems\_build\_name( 'U', 'I', '1', ' ' ).

#### DESCRIPTION:

The value of this configuration option defines the name of the Classic API initialization task.

#### NOTES:

Use *[rtems\\_build\\_name\(\)](#page-931-0)* (page 904) to define the task name.

#### CONSTRAINTS:

The value of the configuration option shall be convertible to an integer of type rtems\_name.

## <span id="page-661-1"></span><span id="page-661-0"></span>27.10.7 CONFIGURE\_INIT\_TASK\_PRIORITY

#### CONSTANT:

CONFIGURE\_INIT\_TASK\_PRIORITY

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 1.

#### DESCRIPTION:

The value of this configuration option defines the initial priority of the Classic API initialization task.

#### CONSTRAINTS:

The value of the configuration option shall be a valid Classic API task priority. The set of valid task priorities depends on the scheduler configuration.

## <span id="page-662-1"></span><span id="page-662-0"></span>27.10.8 CONFIGURE\_INIT\_TASK\_STACK\_SIZE

#### CONSTANT:

CONFIGURE\_INIT\_TASK\_STACK\_SIZE

#### OPTION TYPE:

This configuration option is an integer define.

## DEFAULT VALUE:

The default value is *[CONFIGURE\\_MINIMUM\\_TASK\\_STACK\\_SIZE](#page-613-0)* (page 586).

#### DESCRIPTION:

The value of this configuration option defines the task stack size of the Classic API initialization task.

## NOTES:

The

- CONFIGURE\_INIT\_TASK\_STACK\_SIZE and
- *[CONFIGURE\\_INIT\\_TASK\\_CONSTRUCT\\_STORAGE\\_SIZE](#page-657-0)* (page 630)

configuration options are mutually exclusive.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to *[CONFIG-](#page-613-0)[URE\\_MINIMUM\\_TASK\\_STACK\\_SIZE](#page-613-0)* (page 586).
- The value of the configuration option shall be small enough so that the task stack space calculation carried out by <rtems/confdefs.h> does not overflow an integer of type [uintptr\\_t.](https://en.cppreference.com/w/c/types/integer)

## <span id="page-663-1"></span><span id="page-663-0"></span>27.10.9 CONFIGURE\_RTEMS\_INIT\_TASKS\_TABLE

#### CONSTANT:

CONFIGURE\_RTEMS\_INIT\_TASKS\_TABLE

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then exactly one Classic API initialization task is configured.

## NOTES:

The application shall define at least one of the following configuration options

- CONFIGURE\_RTEMS\_INIT\_TASKS\_TABLE,
- *[CONFIGURE\\_POSIX\\_INIT\\_THREAD\\_TABLE](#page-677-0)* (page 650), or
- *[CONFIGURE\\_IDLE\\_TASK\\_INITIALIZES\\_APPLICATION](#page-737-0)* (page 710)

otherwise a compile time error in the configuration file will occur.

The Classic API initialization task performs the *[Global Construction](#page-119-0)* (page 92).

# <span id="page-664-0"></span>27.11 POSIX API Configuration

This section describes configuration options related to the POSIX API. Most POSIX API objects are available by default since RTEMS 5.1. The queued signals and timers are only available if RTEMS was built with the enable POSIX build configuration option.

## <span id="page-665-1"></span><span id="page-665-0"></span>27.11.1 CONFIGURE\_MAXIMUM\_POSIX\_KEYS

#### CONSTANT:

CONFIGURE\_MAXIMUM\_POSIX\_KEYS

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of POSIX API Keys that can be concurrently active.

## NOTES:

This object class can be configured in unlimited allocation mode, see *[Unlimited Objects](#page-593-0)* (page 566).

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to 65535.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.
- The value of the configuration option may be defined through *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) the enable unlimited objects for the object class, if the value passed to *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) satisfies all other constraints of the configuration option.

## <span id="page-666-1"></span><span id="page-666-0"></span>27.11.2 CONFIGURE\_MAXIMUM\_POSIX\_KEY\_VALUE\_PAIRS

#### CONSTANT:

CONFIGURE\_MAXIMUM\_POSIX\_KEY\_VALUE\_PAIRS

#### OPTION TYPE:

This configuration option is an integer define.

## DEFAULT VALUE:

The default value is *[CONFIGURE\\_MAXIMUM\\_POSIX\\_KEYS](#page-665-0)* (page 638) \* ( *[CONFIG-](#page-650-0)[URE\\_MAXIMUM\\_TASKS](#page-650-0)* (page 623) + *[CONFIGURE\\_MAXIMUM\\_POSIX\\_THREADS](#page-671-0)* (page 644) ).

## DESCRIPTION:

The value of this configuration option defines the maximum number of key value pairs used by POSIX API Keys that can be concurrently active.

#### NOTES:

This object class can be configured in unlimited allocation mode, see *[Unlimited Objects](#page-593-0)* (page 566).

A key value pair is created by pthread\_setspecific() if the value is not [NULL,](https://en.cppreference.com/w/c/types/NULL) otherwise it is deleted.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to 65535.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.
- The value of the configuration option may be defined through *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) the enable unlimited objects for the object class, if the value passed to *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) satisfies all other constraints of the configuration option.

## <span id="page-667-1"></span><span id="page-667-0"></span>27.11.3 CONFIGURE\_MAXIMUM\_POSIX\_MESSAGE\_QUEUES

#### CONSTANT:

CONFIGURE\_MAXIMUM\_POSIX\_MESSAGE\_QUEUES

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of POSIX API Message Queues that can be concurrently active.

## NOTES:

This object class can be configured in unlimited allocation mode, see *[Unlimited Objects](#page-593-0)* (page 566). You have to account for the memory used to store the messages of each message queue, see *[CONFIGURE\\_MESSAGE\\_BUFFER\\_MEMORY](#page-610-0)* (page 583).

#### CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to 65535.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.
- The value of the configuration option shall be small enough so that the RTEMS Workspace size calculation carried out by <rtems/confdefs.h> does not overflow an integer of type [uintptr\\_t.](https://en.cppreference.com/w/c/types/integer)
- The value of the configuration option may be defined through *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) the enable unlimited objects for the object class, if the value passed to *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) satisfies all other constraints of the configuration option.

## <span id="page-668-1"></span><span id="page-668-0"></span>27.11.4 CONFIGURE\_MAXIMUM\_POSIX\_QUEUED\_SIGNALS

#### CONSTANT:

CONFIGURE\_MAXIMUM\_POSIX\_QUEUED\_SIGNALS

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of POSIX API Queued Signals that can be concurrently active.

## NOTES:

Unlimited objects are not available for queued signals.

Queued signals are only available if RTEMS was built with the POSIX API build configuration option enabled.

#### CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.
- The value of the configuration option shall be small enough so that the RTEMS Workspace size calculation carried out by <rtems/confdefs.h> does not overflow an integer of type [uintptr\\_t.](https://en.cppreference.com/w/c/types/integer)
- The value of the configuration option shall be zero if the POSIX API is not enabled (e.g. RTEMS was built without the RTEMS\_POSIX\_API = True build configuration option). Otherwise a compile time error in the configuration file will occur.

## <span id="page-669-1"></span><span id="page-669-0"></span>27.11.5 CONFIGURE\_MAXIMUM\_POSIX\_SEMAPHORES

#### CONSTANT:

CONFIGURE\_MAXIMUM\_POSIX\_SEMAPHORES

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of POSIX API Named Semaphores that can be concurrently active.

#### NOTES:

This object class can be configured in unlimited allocation mode, see *[Unlimited Objects](#page-593-0)* (page 566).

Named semaphores are created with sem\_open(). Semaphores initialized with sem\_init() are not affected by this configuration option since the storage space for these semaphores is userprovided.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to 65535.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.
- The value of the configuration option shall be small enough so that the RTEMS Workspace size calculation carried out by <rtems/confdefs.h> does not overflow an integer of type [uintptr\\_t.](https://en.cppreference.com/w/c/types/integer)
- The value of the configuration option may be defined through *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) the enable unlimited objects for the object class, if the value passed to *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) satisfies all other constraints of the configuration option.

## <span id="page-670-1"></span><span id="page-670-0"></span>27.11.6 CONFIGURE\_MAXIMUM\_POSIX\_SHMS

#### CONSTANT:

CONFIGURE\_MAXIMUM\_POSIX\_SHMS

## OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of POSIX API Shared Memory objects that can be concurrently active.

## NOTES:

This object class can be configured in unlimited allocation mode, see *[Unlimited Objects](#page-593-0)* (page 566).

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to 65535.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.
- The value of the configuration option shall be small enough so that the RTEMS Workspace size calculation carried out by <rtems/confdefs.h> does not overflow an integer of type [uintptr\\_t.](https://en.cppreference.com/w/c/types/integer)
- The value of the configuration option may be defined through *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) the enable unlimited objects for the object class, if the value passed to *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) satisfies all other constraints of the configuration option.

## <span id="page-671-1"></span><span id="page-671-0"></span>27.11.7 CONFIGURE\_MAXIMUM\_POSIX\_THREADS

#### CONSTANT:

CONFIGURE\_MAXIMUM\_POSIX\_THREADS

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of POSIX API Threads that can be concurrently active.

## NOTES:

This object class can be configured in unlimited allocation mode, see *[Unlimited Objects](#page-593-0)* (page 566).

This calculations for the required memory in the RTEMS Workspace for threads assume that each thread has a minimum stack size and has floating point support enabled. The configuration option *[CONFIGURE\\_EXTRA\\_TASK\\_STACKS](#page-600-0)* (page 573) is used to specify thread stack requirements **above** the minimum size required.

The maximum number of Classic API Tasks is specified by *[CONFIGURE\\_MAXIMUM\\_TASKS](#page-650-0)* (page 623).

All POSIX threads have floating point enabled.

#### CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to 65535.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.
- The value of the configuration option shall be small enough so that the task stack space calculation carried out by <rtems/confdefs.h> does not overflow an integer of type [uintptr\\_t.](https://en.cppreference.com/w/c/types/integer)

## <span id="page-672-1"></span><span id="page-672-0"></span>27.11.8 CONFIGURE\_MAXIMUM\_POSIX\_TIMERS

#### CONSTANT:

CONFIGURE\_MAXIMUM\_POSIX\_TIMERS

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of POSIX API Timers that can be concurrently active.

## NOTES:

This object class can be configured in unlimited allocation mode, see *[Unlimited Objects](#page-593-0)* (page 566).

Timers are only available if RTEMS was built with the POSIX API build configuration option enabled.

#### CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to 65535.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.
- The value of the configuration option may be defined through *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) the enable unlimited objects for the object class, if the value passed to *[rtems\\_resource\\_unlimited\(\)](#page-810-0)* (page 783) satisfies all other constraints of the configuration option.
- The value of the configuration option shall be zero if the POSIX API is not enabled (e.g. RTEMS was built without the RTEMS\_POSIX\_API = True build configuration option). Otherwise a compile time error in the configuration file will occur.

## <span id="page-673-1"></span><span id="page-673-0"></span>27.11.9 CONFIGURE\_MINIMUM\_POSIX\_THREAD\_STACK\_SIZE

#### CONSTANT:

CONFIGURE\_MINIMUM\_POSIX\_THREAD\_STACK\_SIZE

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is two times the value of *[CONFIGURE\\_MINIMUM\\_TASK\\_STACK\\_SIZE](#page-613-0)* (page 586).

## DESCRIPTION:

The value of this configuration option defines the minimum stack size in bytes for every POSIX thread in the system.

## CONSTRAINTS:

- The value of the configuration option shall be small enough so that the task stack space calculation carried out by <rtems/confdefs.h> does not overflow an integer of type [uintptr\\_t.](https://en.cppreference.com/w/c/types/integer)
- The value of the configuration option shall be greater than or equal to a BSP-specific and application-specific minimum value.

# <span id="page-674-0"></span>27.12 POSIX Initialization Thread Configuration

This section describes configuration options related to the POSIX initialization thread.

## <span id="page-675-1"></span><span id="page-675-0"></span>27.12.1 CONFIGURE\_POSIX\_INIT\_THREAD\_ENTRY\_POINT

#### CONSTANT:

CONFIGURE\_POSIX\_INIT\_THREAD\_ENTRY\_POINT

#### OPTION TYPE:

This configuration option is an initializer define.

## DEFAULT VALUE:

The default value is POSIX\_Init.

#### DESCRIPTION:

The value of this configuration option initializes the entry point of the POSIX API initialization thread.

## NOTES:

The application shall provide the function referenced by this configuration option.

#### CONSTRAINTS:

The value of the configuration option shall be defined to a valid function pointer of the type void \*( \*entry\_point )( void \* ).

## <span id="page-676-1"></span><span id="page-676-0"></span>27.12.2 CONFIGURE\_POSIX\_INIT\_THREAD\_STACK\_SIZE

#### CONSTANT:

CONFIGURE\_POSIX\_INIT\_THREAD\_STACK\_SIZE

#### OPTION TYPE:

This configuration option is an integer define.

## DEFAULT VALUE:

The default value is *[CONFIGURE\\_MINIMUM\\_POSIX\\_THREAD\\_STACK\\_SIZE](#page-673-0)* (page 646).

#### DESCRIPTION:

The value of this configuration option defines the thread stack size of the POSIX API initialization thread.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to *[CONFIG-](#page-613-0)[URE\\_MINIMUM\\_TASK\\_STACK\\_SIZE](#page-613-0)* (page 586).
- The value of the configuration option shall be small enough so that the task stack space calculation carried out by <rtems/confdefs.h> does not overflow an integer of type [uintptr\\_t.](https://en.cppreference.com/w/c/types/integer)

## <span id="page-677-1"></span><span id="page-677-0"></span>27.12.3 CONFIGURE\_POSIX\_INIT\_THREAD\_TABLE

#### CONSTANT:

CONFIGURE\_POSIX\_INIT\_THREAD\_TABLE

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then exactly one POSIX initialization thread is configured.

## NOTES:

The application shall define at least one of the following configuration options

- *[CONFIGURE\\_RTEMS\\_INIT\\_TASKS\\_TABLE](#page-663-0)* (page 636),
- CONFIGURE\_POSIX\_INIT\_THREAD\_TABLE, or
- *[CONFIGURE\\_IDLE\\_TASK\\_INITIALIZES\\_APPLICATION](#page-737-0)* (page 710)

otherwise a compile time error in the configuration file will occur.

If no Classic API initialization task is configured, then the POSIX API initialization thread performs the *[Global Construction](#page-119-0)* (page 92).

# <span id="page-678-0"></span>27.13 Event Recording Configuration

This section describes configuration options related to the event recording.

## <span id="page-679-1"></span><span id="page-679-0"></span>27.13.1 CONFIGURE\_RECORD\_EXTENSIONS\_ENABLED

#### CONSTANT:

CONFIGURE\_RECORD\_EXTENSIONS\_ENABLED

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case

- this configuration option is defined
- and *[CONFIGURE\\_RECORD\\_PER\\_PROCESSOR\\_ITEMS](#page-683-0)* (page 656) is properly defined,

then the event record extensions are enabled.

#### NOTES:

The record extensions capture thread create, start, restart, delete, switch, begin, exitted and terminate events.

## <span id="page-680-1"></span><span id="page-680-0"></span>27.13.2 CONFIGURE\_RECORD\_FATAL\_DUMP\_BASE64

#### CONSTANT:

CONFIGURE\_RECORD\_FATAL\_DUMP\_BASE64

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

#### In case

- this configuration option is defined
- and *[CONFIGURE\\_RECORD\\_PER\\_PROCESSOR\\_ITEMS](#page-683-0)* (page 656) is properly defined,
- and *[CONFIGURE\\_RECORD\\_FATAL\\_DUMP\\_BASE64\\_ZLIB](#page-681-0)* (page 654) is undefined,

then the event records are dumped in Base64 encoding in a fatal error extension (see *[System](#page-546-2) [Termination Procedure](#page-546-2)* (page 519)).

#### NOTES:

This extension can be used to produce crash dumps.

## <span id="page-681-1"></span><span id="page-681-0"></span>27.13.3 CONFIGURE\_RECORD\_FATAL\_DUMP\_BASE64\_ZLIB

#### CONSTANT:

CONFIGURE\_RECORD\_FATAL\_DUMP\_BASE64\_ZLIB

#### OPTION TYPE:

This configuration option is a boolean feature define.

#### DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

## In case

- this configuration option is defined
- and *[CONFIGURE\\_RECORD\\_PER\\_PROCESSOR\\_ITEMS](#page-683-0)* (page 656) is properly defined,

then the event records are compressed by zlib and dumped in Base64 encoding in a fatal error extension (see *[System Termination Procedure](#page-546-2)* (page 519)).

## NOTES:

The zlib compression needs about 512KiB of RAM. This extension can be used to produce crash dumps.

## <span id="page-682-1"></span><span id="page-682-0"></span>27.13.4 CONFIGURE\_RECORD\_INTERRUPTS\_ENABLED

#### CONSTANT:

CONFIGURE\_RECORD\_INTERRUPTS\_ENABLED

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

#### In case

- this configuration option is defined
- and *[CONFIGURE\\_RECORD\\_PER\\_PROCESSOR\\_ITEMS](#page-683-0)* (page 656) is properly defined,

then the interrupt event recording is enabled.

#### NOTES:

The interrupt event recording generates interrupt entry and exit events when interrupt entries are dispatched.

## <span id="page-683-1"></span><span id="page-683-0"></span>27.13.5 CONFIGURE\_RECORD\_PER\_PROCESSOR\_ITEMS

#### CONSTANT:

CONFIGURE\_RECORD\_PER\_PROCESSOR\_ITEMS

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the event record item count per processor.

#### NOTES:

The event record buffers are statically allocated for each configured processor (*[CONFIG-](#page-606-0)[URE\\_MAXIMUM\\_PROCESSORS](#page-606-0)* (page 579)). If the value of this configuration option is zero, then nothing is allocated.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to 16.
- The value of the configuration option shall be less than or equal to [SIZE\\_MAX.](https://en.cppreference.com/w/c/types/limits)
- The value of the configuration option shall be a power of two.
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.

# <span id="page-684-0"></span>27.14 Filesystem Configuration

This section describes configuration options related to filesytems. By default, the In-Memory Filesystem (IMFS) is used as the base filesystem (also known as root filesystem). In order to save some memory for your application, you can disable the filesystem support with the *[CONFIGURE\\_APPLICATION\\_DISABLE\\_FILESYSTEM](#page-685-0)* (page 658) configuration option. Alternatively, you can strip down the features of the base filesystem with the *[CONFIGURE\\_USE\\_MINIIMFS\\_AS\\_BASE\\_FILESYSTEM](#page-713-0)* (page 686) and *[CONFIG-](#page-712-0)[URE\\_USE\\_DEVFS\\_AS\\_BASE\\_FILESYSTEM](#page-712-0)* (page 685) configuration options. These three configuration options are mutually exclusive. They are intended for an advanced application configuration.

Features of the IMFS can be disabled and enabled with the following configuration options:

- *[CONFIGURE\\_IMFS\\_DISABLE\\_CHMOD](#page-694-0)* (page 667)
- *[CONFIGURE\\_IMFS\\_DISABLE\\_CHOWN](#page-695-0)* (page 668)
- *[CONFIGURE\\_IMFS\\_DISABLE\\_LINK](#page-696-0)* (page 669)
- *[CONFIGURE\\_IMFS\\_DISABLE\\_MKNOD](#page-697-0)* (page 670)
- *[CONFIGURE\\_IMFS\\_DISABLE\\_MKNOD\\_FILE](#page-699-0)* (page 672)
- *[CONFIGURE\\_IMFS\\_DISABLE\\_MOUNT](#page-700-0)* (page 673)
- *[CONFIGURE\\_IMFS\\_DISABLE\\_READDIR](#page-701-0)* (page 674)
- *[CONFIGURE\\_IMFS\\_DISABLE\\_READLINK](#page-702-0)* (page 675)
- *[CONFIGURE\\_IMFS\\_DISABLE\\_RENAME](#page-703-0)* (page 676)
- *[CONFIGURE\\_IMFS\\_DISABLE\\_RMNOD](#page-704-0)* (page 677)
- *[CONFIGURE\\_IMFS\\_DISABLE\\_SYMLINK](#page-705-0)* (page 678)
- *[CONFIGURE\\_IMFS\\_DISABLE\\_UNMOUNT](#page-706-0)* (page 679)
- *[CONFIGURE\\_IMFS\\_DISABLE\\_UTIME](#page-707-0)* (page 680)
- *[CONFIGURE\\_IMFS\\_ENABLE\\_MKFIFO](#page-708-0)* (page 681)

## <span id="page-685-1"></span><span id="page-685-0"></span>27.14.1 CONFIGURE\_APPLICATION\_DISABLE\_FILESYSTEM

#### CONSTANT:

CONFIGURE\_APPLICATION\_DISABLE\_FILESYSTEM

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then a base filesystem and the configured filesystems are initialized during system initialization.

#### DESCRIPTION:

In case this configuration option is defined, then **no base filesystem** is initialized during system initialization and **no filesystems** are configured.

## NOTES:

Filesystems shall be initialized to support file descriptor based device drivers and basic input/output functions such as printf(). Filesystems can be disabled to reduce the memory footprint of an application.

## <span id="page-686-1"></span><span id="page-686-0"></span>27.14.2 CONFIGURE\_FILESYSTEM\_ALL

#### CONSTANT:

CONFIGURE\_FILESYSTEM\_ALL

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the following configuration options will be defined as well

- *[CONFIGURE\\_FILESYSTEM\\_DOSFS](#page-687-0)* (page 660),
- *[CONFIGURE\\_FILESYSTEM\\_FTPFS](#page-688-0)* (page 661),
- *[CONFIGURE\\_FILESYSTEM\\_IMFS](#page-689-0)* (page 662),
- *[CONFIGURE\\_FILESYSTEM\\_JFFS2](#page-690-0)* (page 663),
- *[CONFIGURE\\_FILESYSTEM\\_NFS](#page-691-0)* (page 664),
- *[CONFIGURE\\_FILESYSTEM\\_RFS](#page-692-0)* (page 665), and
- *[CONFIGURE\\_FILESYSTEM\\_TFTPFS](#page-693-0)* (page 666).

## <span id="page-687-1"></span><span id="page-687-0"></span>27.14.3 CONFIGURE\_FILESYSTEM\_DOSFS

#### CONSTANT:

CONFIGURE\_FILESYSTEM\_DOSFS

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the DOS (FAT) filesystem is registered, so that instances of this filesystem can be mounted by the application.

## NOTES:

This filesystem requires a Block Device Cache configuration, see *[CONFIG-](#page-715-0)[URE\\_APPLICATION\\_NEEDS\\_LIBBLOCK](#page-715-0)* (page 688).

## <span id="page-688-1"></span><span id="page-688-0"></span>27.14.4 CONFIGURE\_FILESYSTEM\_FTPFS

#### CONSTANT:

CONFIGURE\_FILESYSTEM\_FTPFS

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the FTP filesystem (FTP client) is registered, so that instances of this filesystem can be mounted by the application.

## <span id="page-689-1"></span><span id="page-689-0"></span>27.14.5 CONFIGURE\_FILESYSTEM\_IMFS

#### CONSTANT:

CONFIGURE\_FILESYSTEM\_IMFS

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the In-Memory Filesystem (IMFS) is registered, so that instances of this filesystem can be mounted by the application.

## NOTES:

Applications will rarely need this configuration option. This configuration option is intended for test programs. You do not need to define this configuration option for the base filesystem (also known as root filesystem).

## <span id="page-690-1"></span><span id="page-690-0"></span>27.14.6 CONFIGURE\_FILESYSTEM\_JFFS2

#### CONSTANT:

CONFIGURE\_FILESYSTEM\_JFFS2

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the JFFS2 filesystem is registered, so that instances of this filesystem can be mounted by the application.

## <span id="page-691-1"></span><span id="page-691-0"></span>27.14.7 CONFIGURE\_FILESYSTEM\_NFS

#### CONSTANT:

CONFIGURE\_FILESYSTEM\_NFS

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the Network Filesystem (NFS) client is registered, so that instances of this filesystem can be mounted by the application.

## <span id="page-692-1"></span><span id="page-692-0"></span>27.14.8 CONFIGURE\_FILESYSTEM\_RFS

#### CONSTANT:

CONFIGURE\_FILESYSTEM\_RFS

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the RTEMS Filesystem (RFS) is registered, so that instances of this filesystem can be mounted by the application.

## NOTES:

This filesystem requires a Block Device Cache configuration, see *[CONFIG-](#page-715-0)[URE\\_APPLICATION\\_NEEDS\\_LIBBLOCK](#page-715-0)* (page 688).

## <span id="page-693-1"></span><span id="page-693-0"></span>27.14.9 CONFIGURE\_FILESYSTEM\_TFTPFS

#### CONSTANT:

CONFIGURE\_FILESYSTEM\_TFTPFS

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the TFTP filesystem (TFTP client) is registered, so that instances of this filesystem can be mounted by the application.

## <span id="page-694-1"></span><span id="page-694-0"></span>27.14.10 CONFIGURE\_IMFS\_DISABLE\_CHMOD

#### CONSTANT:

CONFIGURE\_IMFS\_DISABLE\_CHMOD

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the root IMFS supports changing the mode of files.

#### DESCRIPTION:

In case this configuration option is defined, then the root IMFS does not support changing the mode of files (no support for chmod()).

## <span id="page-695-1"></span><span id="page-695-0"></span>27.14.11 CONFIGURE\_IMFS\_DISABLE\_CHOWN

#### CONSTANT:

CONFIGURE\_IMFS\_DISABLE\_CHOWN

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the root IMFS supports changing the ownership of files.

#### DESCRIPTION:

In case this configuration option is defined, then the root IMFS does not support changing the ownership of files (no support for chown()).

## <span id="page-696-1"></span><span id="page-696-0"></span>27.14.12 CONFIGURE\_IMFS\_DISABLE\_LINK

#### CONSTANT:

CONFIGURE\_IMFS\_DISABLE\_LINK

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the root IMFS supports hard links.

#### DESCRIPTION:

In case this configuration option is defined, then the root IMFS does not support hard links (no support for link()).

## <span id="page-697-1"></span><span id="page-697-0"></span>27.14.13 CONFIGURE\_IMFS\_DISABLE\_MKNOD

#### CONSTANT:

CONFIGURE\_IMFS\_DISABLE\_MKNOD

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the root IMFS supports making files.

#### DESCRIPTION:

In case this configuration option is defined, then the root IMFS does not support making files (no support for mknod()).

## <span id="page-698-1"></span><span id="page-698-0"></span>27.14.14 CONFIGURE\_IMFS\_DISABLE\_MKNOD\_DEVICE

#### CONSTANT:

CONFIGURE\_IMFS\_DISABLE\_MKNOD\_DEVICE

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the root IMFS supports making device files.

#### DESCRIPTION:

In case this configuration option is defined, then the root IMFS does not support making device files.

## <span id="page-699-1"></span><span id="page-699-0"></span>27.14.15 CONFIGURE\_IMFS\_DISABLE\_MKNOD\_FILE

#### CONSTANT:

CONFIGURE\_IMFS\_DISABLE\_MKNOD\_FILE

## OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the root IMFS supports making regular files.

#### DESCRIPTION:

In case this configuration option is defined, then the root IMFS does not support making regular files.

## <span id="page-700-1"></span><span id="page-700-0"></span>27.14.16 CONFIGURE\_IMFS\_DISABLE\_MOUNT

#### CONSTANT:

CONFIGURE\_IMFS\_DISABLE\_MOUNT

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the root IMFS supports mounting other filesystems.

#### DESCRIPTION:

In case this configuration option is defined, then the root IMFS does not support mounting other filesystems (no support for mount()).

## <span id="page-701-1"></span><span id="page-701-0"></span>27.14.17 CONFIGURE\_IMFS\_DISABLE\_READDIR

#### CONSTANT:

CONFIGURE\_IMFS\_DISABLE\_READDIR

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the root IMFS supports reading directories.

#### DESCRIPTION:

In case this configuration option is defined, then the root IMFS does not support reading directories (no support for readdir()). It is still possible to open files in a directory.

## <span id="page-702-1"></span><span id="page-702-0"></span>27.14.18 CONFIGURE\_IMFS\_DISABLE\_READLINK

#### CONSTANT:

CONFIGURE\_IMFS\_DISABLE\_READLINK

## OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the root IMFS supports reading symbolic links.

#### DESCRIPTION:

In case this configuration option is defined, then the root IMFS does not support reading symbolic links (no support for readlink()).

## <span id="page-703-1"></span><span id="page-703-0"></span>27.14.19 CONFIGURE\_IMFS\_DISABLE\_RENAME

#### CONSTANT:

CONFIGURE\_IMFS\_DISABLE\_RENAME

## OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the root IMFS supports renaming files.

#### DESCRIPTION:

In case this configuration option is defined, then the root IMFS does not support renaming files (no support for rename()).

## <span id="page-704-1"></span><span id="page-704-0"></span>27.14.20 CONFIGURE\_IMFS\_DISABLE\_RMNOD

#### CONSTANT:

CONFIGURE\_IMFS\_DISABLE\_RMNOD

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the root IMFS supports removing files.

#### DESCRIPTION:

In case this configuration option is defined, then the root IMFS does not support removing files (no support for rmnod()).

## <span id="page-705-1"></span><span id="page-705-0"></span>27.14.21 CONFIGURE\_IMFS\_DISABLE\_SYMLINK

#### CONSTANT:

CONFIGURE\_IMFS\_DISABLE\_SYMLINK

#### OPTION TYPE:

This configuration option is a boolean feature define.

#### DEFAULT CONFIGURATION:

If this configuration option is undefined, then the root IMFS supports creating symbolic links.

#### DESCRIPTION:

In case this configuration option is defined, then the root IMFS does not support creating symbolic links (no support for symlink()).

## <span id="page-706-1"></span><span id="page-706-0"></span>27.14.22 CONFIGURE\_IMFS\_DISABLE\_UNMOUNT

#### CONSTANT:

CONFIGURE\_IMFS\_DISABLE\_UNMOUNT

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the root IMFS supports unmounting other filesystems.

#### DESCRIPTION:

In case this configuration option is defined, then the root IMFS does not support unmounting other filesystems (no support for unmount()).

## <span id="page-707-1"></span><span id="page-707-0"></span>27.14.23 CONFIGURE\_IMFS\_DISABLE\_UTIME

#### CONSTANT:

CONFIGURE\_IMFS\_DISABLE\_UTIME

#### OPTION TYPE:

This configuration option is a boolean feature define.

#### DEFAULT CONFIGURATION:

If this configuration option is undefined, then the root IMFS supports changing file times.

#### DESCRIPTION:

In case this configuration option is defined, then the root IMFS does not support changing file times (no support for utime()).

## <span id="page-708-1"></span><span id="page-708-0"></span>27.14.24 CONFIGURE\_IMFS\_ENABLE\_MKFIFO

#### CONSTANT:

CONFIGURE\_IMFS\_ENABLE\_MKFIFO

#### OPTION TYPE:

This configuration option is a boolean feature define.

#### DEFAULT CONFIGURATION:

If this configuration option is undefined, then the root IMFS does not support making FIFOs (no support for mkfifo()).

#### DESCRIPTION:

In case this configuration option is defined, then the root IMFS supports making FIFOs.

## <span id="page-709-1"></span><span id="page-709-0"></span>27.14.25 CONFIGURE\_IMFS\_MEMFILE\_BYTES\_PER\_BLOCK

#### CONSTANT:

CONFIGURE\_IMFS\_MEMFILE\_BYTES\_PER\_BLOCK

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 128.

#### DESCRIPTION:

The value of this configuration option defines the block size for in-memory files managed by the IMFS.

## NOTES:

The configured block size has two impacts. The first is the average amount of unused memory in the last block of each file. For example, when the block size is 512, on average one-half of the last block of each file will remain unused and the memory is wasted. In contrast, when the block size is 16, the average unused memory per file is only 8 bytes. However, it requires more allocations for the same size file and thus more overhead per block for the dynamic memory management.

Second, the block size has an impact on the maximum size file that can be stored in the IMFS. With smaller block size, the maximum file size is correspondingly smaller. The following shows the maximum file size possible based on the configured block size:

- when the block size is 16 bytes, the maximum file size is 1,344 bytes.
- when the block size is 32 bytes, the maximum file size is 18,688 bytes.
- when the block size is 64 bytes, the maximum file size is 279,552 bytes.
- when the block size is 128 bytes, the maximum file size is 4,329,472 bytes.
- when the block size is 256 bytes, the maximum file size is 68,173,824 bytes.
- when the block size is 512 bytes, the maximum file size is 1,082,195,968 bytes.

#### CONSTRAINTS:

The value of the configuration option shall be equal to 16, 32, 64, 128, 256, or 512.

## <span id="page-710-1"></span><span id="page-710-0"></span>27.14.26 CONFIGURE\_IMFS\_MEMFILE\_OPS

#### CONSTANT:

CONFIGURE\_IMFS\_MEMFILE\_OPS

#### OPTION TYPE:

This configuration option is of type imfs\_memfile\_ops\_t. This type holds the references of allocate, deallocate and get\_free\_space functions.

## DEFAULT VALUE:

The default object has references to functions that internally take the memory from heap. That means this functions internally calls calloc(), free() and malloc\_free\_space().

## DESCRIPTION:

The value of this configuration option defines the methods to allocate, deallocate the user defined blocks for in-memory files managed by the IMFS.

## NOTES:

By default, IMFS uses the kernel heap for file storage. This can lead to heap overflows, preventing file extensions and resulting in an ENOSPC error.

To avoid this, the user can provide their own memory source and implement:

- Allocator allocate memory for file data from user-supplied memory (e.g., a static array or any other user-defined method)
- Deallocator free allocated memory
- Free space calculator determine remaining space (for statvfs compliance)

These functions should be encapsulated in an imfs\_memfile\_ops\_t structure and assigned to the appropriate macro.

## <span id="page-711-1"></span><span id="page-711-0"></span>27.14.27 CONFIGURE\_JFFS2\_DELAYED\_WRITE\_TASK\_PRIORITY

#### CONSTANT:

CONFIGURE\_JFFS2\_DELAYED\_WRITE\_TASK\_PRIORITY

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 15.

#### DESCRIPTION:

The value of this configuration option defines the JFFS2 delayed write task priority.

#### CONSTRAINTS:

The value of the configuration option shall be a valid Classic API task priority. The set of valid task priorities depends on the scheduler configuration.

## <span id="page-712-1"></span><span id="page-712-0"></span>27.14.28 CONFIGURE\_USE\_DEVFS\_AS\_BASE\_FILESYSTEM

#### CONSTANT:

CONFIGURE\_USE\_DEVFS\_AS\_BASE\_FILESYSTEM

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then an IMFS with a reduced feature set will be the base filesystem (also known as root filesystem).

## NOTES:

In case this configuration option is defined, then the following configuration options will be defined as well

- *[CONFIGURE\\_IMFS\\_DISABLE\\_CHMOD](#page-694-0)* (page 667),
- *[CONFIGURE\\_IMFS\\_DISABLE\\_CHOWN](#page-695-0)* (page 668),
- *[CONFIGURE\\_IMFS\\_DISABLE\\_LINK](#page-696-0)* (page 669),
- *[CONFIGURE\\_IMFS\\_DISABLE\\_MKNOD\\_FILE](#page-699-0)* (page 672),
- *[CONFIGURE\\_IMFS\\_DISABLE\\_MOUNT](#page-700-0)* (page 673),
- *[CONFIGURE\\_IMFS\\_DISABLE\\_READDIR](#page-701-0)* (page 674),
- *[CONFIGURE\\_IMFS\\_DISABLE\\_READLINK](#page-702-0)* (page 675),
- *[CONFIGURE\\_IMFS\\_DISABLE\\_RENAME](#page-703-0)* (page 676),
- *[CONFIGURE\\_IMFS\\_DISABLE\\_RMNOD](#page-704-0)* (page 677),
- *[CONFIGURE\\_IMFS\\_DISABLE\\_SYMLINK](#page-705-0)* (page 678),
- *[CONFIGURE\\_IMFS\\_DISABLE\\_UTIME](#page-707-0)* (page 680), and
- *[CONFIGURE\\_IMFS\\_DISABLE\\_UNMOUNT](#page-706-0)* (page 679).

In addition, a simplified path evaluation is enabled. It allows only a look up of absolute paths.

This configuration of the IMFS is basically a device-only filesystem. It is comparable in functionality to the pseudo-filesystem name space provided before RTEMS release 4.5.0.

## <span id="page-713-1"></span><span id="page-713-0"></span>27.14.29 CONFIGURE\_USE\_MINIIMFS\_AS\_BASE\_FILESYSTEM

#### CONSTANT:

CONFIGURE\_USE\_MINIIMFS\_AS\_BASE\_FILESYSTEM

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then an IMFS with a reduced feature set will be the base filesystem (also known as root filesystem).

## NOTES:

In case this configuration option is defined, then the following configuration options will be defined as well

- *[CONFIGURE\\_IMFS\\_DISABLE\\_CHMOD](#page-694-0)* (page 667),
- *[CONFIGURE\\_IMFS\\_DISABLE\\_CHOWN](#page-695-0)* (page 668),
- *[CONFIGURE\\_IMFS\\_DISABLE\\_LINK](#page-696-0)* (page 669),
- *[CONFIGURE\\_IMFS\\_DISABLE\\_READLINK](#page-702-0)* (page 675),
- *[CONFIGURE\\_IMFS\\_DISABLE\\_RENAME](#page-703-0)* (page 676),
- *[CONFIGURE\\_IMFS\\_DISABLE\\_SYMLINK](#page-705-0)* (page 678),
- *[CONFIGURE\\_IMFS\\_DISABLE\\_UTIME](#page-707-0)* (page 680), and
- *[CONFIGURE\\_IMFS\\_DISABLE\\_UNMOUNT](#page-706-0)* (page 679).

# <span id="page-714-0"></span>27.15 Block Device Cache Configuration

This section describes configuration options related to the Block Device Cache (bdbuf).

## <span id="page-715-1"></span><span id="page-715-0"></span>27.15.1 CONFIGURE\_APPLICATION\_NEEDS\_LIBBLOCK

#### CONSTANT:

CONFIGURE\_APPLICATION\_NEEDS\_LIBBLOCK

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the Block Device Cache is initialized during system initialization.

## NOTES:

Each option of the Block Device Cache (bdbuf) configuration can be explicitly set by the user with the configuration options below. The Block Device Cache is used for example by the RFS and DOSFS filesystems.

## <span id="page-716-1"></span><span id="page-716-0"></span>27.15.2 CONFIGURE\_BDBUF\_BUFFER\_MAX\_SIZE

#### CONSTANT:

CONFIGURE\_BDBUF\_BUFFER\_MAX\_SIZE

#### OPTION TYPE:

This configuration option is an integer define.

## DEFAULT VALUE:

The default value is 4096.

#### DESCRIPTION:

The value of this configuration option defines the maximum size of a buffer in bytes.

#### CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be an integral multiple of *[CONFIG-](#page-717-0)[URE\\_BDBUF\\_BUFFER\\_MIN\\_SIZE](#page-717-0)* (page 690).

## <span id="page-717-1"></span><span id="page-717-0"></span>27.15.3 CONFIGURE\_BDBUF\_BUFFER\_MIN\_SIZE

#### CONSTANT:

CONFIGURE\_BDBUF\_BUFFER\_MIN\_SIZE

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 512.

#### DESCRIPTION:

The value of this configuration option defines the minimum size of a buffer in bytes.

#### CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to [UINT32\\_MAX.](https://en.cppreference.com/w/c/types/integer)

## <span id="page-718-1"></span><span id="page-718-0"></span>27.15.4 CONFIGURE\_BDBUF\_CACHE\_MEMORY\_SIZE

#### CONSTANT:

CONFIGURE\_BDBUF\_CACHE\_MEMORY\_SIZE

## OPTION TYPE:

This configuration option is an integer define.

## DEFAULT VALUE:

The default value is 32768.

#### DESCRIPTION:

The value of this configuration option defines the size of the cache memory in bytes.

#### CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to [SIZE\\_MAX.](https://en.cppreference.com/w/c/types/limits)

## <span id="page-719-1"></span><span id="page-719-0"></span>27.15.5 CONFIGURE\_BDBUF\_MAX\_READ\_AHEAD\_BLOCKS

#### CONSTANT:

CONFIGURE\_BDBUF\_MAX\_READ\_AHEAD\_BLOCKS

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the maximum blocks per read-ahead request.

#### NOTES:

A value of 0 disables the read-ahead task (default). The read-ahead task will issue speculative read transfers if a sequential access pattern is detected. This can improve the performance on some systems.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to [UINT32\\_MAX.](https://en.cppreference.com/w/c/types/integer)

## <span id="page-720-1"></span><span id="page-720-0"></span>27.15.6 CONFIGURE\_BDBUF\_MAX\_WRITE\_BLOCKS

#### CONSTANT:

CONFIGURE\_BDBUF\_MAX\_WRITE\_BLOCKS

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 16.

#### DESCRIPTION:

The value of this configuration option defines the maximum blocks per write request.

#### CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to [UINT32\\_MAX.](https://en.cppreference.com/w/c/types/integer)

## <span id="page-721-1"></span><span id="page-721-0"></span>27.15.7 CONFIGURE\_BDBUF\_READ\_AHEAD\_TASK\_PRIORITY

#### CONSTANT:

CONFIGURE\_BDBUF\_READ\_AHEAD\_TASK\_PRIORITY

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 15.

#### DESCRIPTION:

The value of this configuration option defines the read-ahead task priority.

#### CONSTRAINTS:

The value of the configuration option shall be a valid Classic API task priority. The set of valid task priorities depends on the scheduler configuration.

## <span id="page-722-1"></span><span id="page-722-0"></span>27.15.8 CONFIGURE\_BDBUF\_TASK\_STACK\_SIZE

#### CONSTANT:

CONFIGURE\_BDBUF\_TASK\_STACK\_SIZE

#### OPTION TYPE:

This configuration option is an integer define.

## DEFAULT VALUE:

The default value is RTEMS\_MINIMUM\_STACK\_SIZE.

#### DESCRIPTION:

The value of this configuration option defines the task stack size of the Block Device Cache tasks in bytes.

#### CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to *[CONFIG-](#page-613-0)[URE\\_MINIMUM\\_TASK\\_STACK\\_SIZE](#page-613-0)* (page 586).
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.
- The value of the configuration option shall be small enough so that the task stack space calculation carried out by <rtems/confdefs.h> does not overflow an integer of type [uintptr\\_t.](https://en.cppreference.com/w/c/types/integer)

## <span id="page-723-1"></span><span id="page-723-0"></span>27.15.9 CONFIGURE\_SWAPOUT\_BLOCK\_HOLD

#### CONSTANT:

CONFIGURE\_SWAPOUT\_BLOCK\_HOLD

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 1000.

#### DESCRIPTION:

The value of this configuration option defines the swapout task maximum block hold time in milliseconds.

#### CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to [UINT32\\_MAX.](https://en.cppreference.com/w/c/types/integer)

## <span id="page-724-1"></span><span id="page-724-0"></span>27.15.10 CONFIGURE\_SWAPOUT\_SWAP\_PERIOD

#### CONSTANT:

CONFIGURE\_SWAPOUT\_SWAP\_PERIOD

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 250.

#### DESCRIPTION:

The value of this configuration option defines the swapout task swap period in milliseconds.

#### CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to [UINT32\\_MAX.](https://en.cppreference.com/w/c/types/integer)

## <span id="page-725-1"></span><span id="page-725-0"></span>27.15.11 CONFIGURE\_SWAPOUT\_TASK\_PRIORITY

#### CONSTANT:

CONFIGURE\_SWAPOUT\_TASK\_PRIORITY

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 15.

#### DESCRIPTION:

The value of this configuration option defines the swapout task priority.

#### CONSTRAINTS:

The value of the configuration option shall be a valid Classic API task priority. The set of valid task priorities depends on the scheduler configuration.

## <span id="page-726-1"></span><span id="page-726-0"></span>27.15.12 CONFIGURE\_SWAPOUT\_WORKER\_TASKS

CONSTANT:

CONFIGURE\_SWAPOUT\_WORKER\_TASKS

OPTION TYPE:

This configuration option is an integer define.

DEFAULT VALUE:

The default value is 0.

DESCRIPTION:

The value of this configuration option defines the swapout worker task count.

#### CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to [UINT32\\_MAX.](https://en.cppreference.com/w/c/types/integer)

## <span id="page-727-1"></span><span id="page-727-0"></span>27.15.13 CONFIGURE\_SWAPOUT\_WORKER\_TASK\_PRIORITY

#### CONSTANT:

CONFIGURE\_SWAPOUT\_WORKER\_TASK\_PRIORITY

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 15.

#### DESCRIPTION:

The value of this configuration option defines the swapout worker task priority.

#### CONSTRAINTS:

The value of the configuration option shall be a valid Classic API task priority. The set of valid task priorities depends on the scheduler configuration.

# <span id="page-728-0"></span>27.16 Task Stack Allocator Configuration

This section describes configuration options related to the task stack allocator. RTEMS allows the application or BSP to define its own allocation and deallocation methods for task stacks. This can be used to place task stacks in special areas of memory or to utilize a Memory Management Unit so that stack overflows are detected in hardware.

## <span id="page-729-1"></span><span id="page-729-0"></span>27.16.1 CONFIGURE\_TASK\_STACK\_ALLOCATOR

#### CONSTANT:

CONFIGURE\_TASK\_STACK\_ALLOCATOR

#### OPTION TYPE:

This configuration option is an initializer define.

## DEFAULT VALUE:

The default value is \_Workspace\_Allocate, which indicates that task stacks will be allocated from the RTEMS Workspace.

## DESCRIPTION:

The value of this configuration option initializes the stack allocator allocate handler.

## NOTES:

A correctly configured system shall configure the following to be consistent:

- *[CONFIGURE\\_TASK\\_STACK\\_ALLOCATOR\\_INIT](#page-732-0)* (page 705)
- CONFIGURE\_TASK\_STACK\_ALLOCATOR
- *[CONFIGURE\\_TASK\\_STACK\\_DEALLOCATOR](#page-733-0)* (page 706)

## CONSTRAINTS:

The value of the configuration option shall be defined to a valid function pointer of the type void \*( \*allocate )( size\_t ).

## <span id="page-730-1"></span><span id="page-730-0"></span>27.16.2 CONFIGURE\_TASK\_STACK\_ALLOCATOR\_AVOIDS\_WORK\_SPACE

#### CONSTANT:

CONFIGURE\_TASK\_STACK\_ALLOCATOR\_AVOIDS\_WORK\_SPACE

## OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the system is informed that the task stack allocator does not use the RTEMS Workspace.

## NOTES:

This configuration option may be used if a custom task stack allocator is configured, see *[CON-](#page-729-0)[FIGURE\\_TASK\\_STACK\\_ALLOCATOR](#page-729-0)* (page 702).

## <span id="page-731-1"></span><span id="page-731-0"></span>27.16.3 CONFIGURE\_TASK\_STACK\_ALLOCATOR\_FOR\_IDLE

#### CONSTANT:

CONFIGURE\_TASK\_STACK\_ALLOCATOR\_FOR\_IDLE

#### OPTION TYPE:

This configuration option is an initializer define.

## DEFAULT VALUE:

By default, the IDLE task storage area will be allocated from the RTEMS Workspace.

#### DESCRIPTION:

The value of this configuration option is the address for the stack allocator allocate handler used to allocate the task storage area of each *[IDLE task](#page-1067-2)*.

## NOTES:

This configuration option is independent of the other thread stack allocator configuration options. It is assumed that any memory allocated for the task storage area of an *[IDLE task](#page-1067-2)* will not be from the RTEMS Workspace.

The IDLE task stack allocator may increase the size of the allocated memory area to account for the actually allocated memory area.

## The

- *[CONFIGURE\\_IDLE\\_TASK\\_STORAGE\\_SIZE](#page-739-0)* (page 712), and
- CONFIGURE\_TASK\_STACK\_ALLOCATOR\_FOR\_IDLE

configuration options are mutually exclusive.

#### CONSTRAINTS:

- The value of the configuration option shall be defined to a valid function pointer of the type void \*( \*allocate )( uint32\_t, size\_t \* ).
- The IDLE task stack allocator shall return a pointer to the allocated memory area or terminate the system with a fatal error if the allocation request cannot be satisfied.
- The IDLE task stack allocator may increase the size of the allocated memory area.

## <span id="page-732-1"></span><span id="page-732-0"></span>27.16.4 CONFIGURE\_TASK\_STACK\_ALLOCATOR\_INIT

#### CONSTANT:

CONFIGURE\_TASK\_STACK\_ALLOCATOR\_INIT

#### OPTION TYPE:

This configuration option is an initializer define.

#### DEFAULT VALUE:

The default value is [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### DESCRIPTION:

The value of this configuration option initializes the stack allocator initialization handler.

#### NOTES:

A correctly configured system shall configure the following to be consistent:

- CONFIGURE\_TASK\_STACK\_ALLOCATOR\_INIT
- *[CONFIGURE\\_TASK\\_STACK\\_ALLOCATOR](#page-729-0)* (page 702)
- *[CONFIGURE\\_TASK\\_STACK\\_DEALLOCATOR](#page-733-0)* (page 706)

#### CONSTRAINTS:

The value of the configuration option shall be defined to a valid function pointer of the type void ( \*initialize )( size\_t ) or to [NULL.](https://en.cppreference.com/w/c/types/NULL)

## <span id="page-733-1"></span><span id="page-733-0"></span>27.16.5 CONFIGURE\_TASK\_STACK\_DEALLOCATOR

#### CONSTANT:

CONFIGURE\_TASK\_STACK\_DEALLOCATOR

#### OPTION TYPE:

This configuration option is an initializer define.

## DEFAULT VALUE:

The default value is \_Workspace\_Free, which indicates that task stacks will be allocated from the RTEMS Workspace.

## DESCRIPTION:

The value of this configuration option initializes the stack allocator deallocate handler.

## NOTES:

A correctly configured system shall configure the following to be consistent:

- *[CONFIGURE\\_TASK\\_STACK\\_ALLOCATOR\\_INIT](#page-732-0)* (page 705)
- *[CONFIGURE\\_TASK\\_STACK\\_ALLOCATOR](#page-729-0)* (page 702)
- CONFIGURE\_TASK\_STACK\_DEALLOCATOR

## CONSTRAINTS:

The value of the configuration option shall be defined to a valid function pointer of the type void ( \*deallocate )( void \* ).

## <span id="page-734-1"></span><span id="page-734-0"></span>27.16.6 CONFIGURE\_TASK\_STACK\_FROM\_ALLOCATOR

#### CONSTANT:

CONFIGURE\_TASK\_STACK\_FROM\_ALLOCATOR

#### OPTION TYPE:

This configuration option is an initializer define.

## DEFAULT VALUE:

The default value is a macro which supports the system heap allocator.

#### DESCRIPTION:

The value of this configuration option is used to calculate the task stack space size.

#### NOTES:

This configuration option may be used if a custom task stack allocator is configured, see *[CON-](#page-729-0)[FIGURE\\_TASK\\_STACK\\_ALLOCATOR](#page-729-0)* (page 702).

## CONSTRAINTS:

The value of the configuration option shall be defined to a macro which accepts exactly one parameter and returns an unsigned integer. The parameter will be an allocation size and the macro shall return this size plus the overhead of the allocator to manage an allocation request for this size.

# <span id="page-735-0"></span>27.17 Idle Task Configuration

This section describes configuration options related to the idle tasks.

## <span id="page-736-1"></span><span id="page-736-0"></span>27.17.1 CONFIGURE\_IDLE\_TASK\_BODY

#### CONSTANT:

CONFIGURE\_IDLE\_TASK\_BODY

#### OPTION TYPE:

This configuration option is an initializer define.

#### DEFAULT VALUE:

If the *[CONFIGURE\\_DISABLE\\_BSP\\_SETTINGS](#page-597-0)* (page 570) configuration option is not defined and BSP\_IDLE\_TASK\_BODY is provided by the *[BSP](#page-1061-0)*, then the default value is defined by BSP\_IDLE\_TASK\_BODY, otherwise the default value is \_CPU\_Thread\_Idle\_body.

#### DESCRIPTION:

The value of this configuration option initializes the IDLE thread body.

## NOTES:

IDLE threads shall not block. A blocking IDLE thread results in undefined system behaviour because the scheduler assume that at least one ready thread exists.

IDLE threads can be used to initialize the application, see configuration option *[CONFIG-](#page-737-0)[URE\\_IDLE\\_TASK\\_INITIALIZES\\_APPLICATION](#page-737-0)* (page 710).

The BSP may have knowledge of the specific CPU model, system controller logic, and peripheral buses, so a BSP-specific IDLE task may be capable of turning components off to save power during extended periods of no task activity.

#### CONSTRAINTS:

The value of the configuration option shall be defined to a valid function pointer of the type void \*( \*idle\_body )( uintptr\_t ).

## <span id="page-737-1"></span><span id="page-737-0"></span>27.17.2 CONFIGURE\_IDLE\_TASK\_INITIALIZES\_APPLICATION

#### CONSTANT:

CONFIGURE\_IDLE\_TASK\_INITIALIZES\_APPLICATION

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the user is assumed to provide one or more initialization tasks.

## DESCRIPTION:

This configuration option is defined to indicate that the user has configured **no** user initialization tasks or threads and that the user provided IDLE task will perform application initialization and then transform itself into an IDLE task.

## NOTES:

If you use this option be careful, the user IDLE task **cannot** block at all during the initialization sequence. Further, once application initialization is complete, it shall make itself preemptible and enter an idle body loop.

The IDLE task shall run at the lowest priority of all tasks in the system.

If this configuration option is defined, then it is mandatory to configure a user IDLE task with the *[CONFIGURE\\_IDLE\\_TASK\\_BODY](#page-736-0)* (page 709) configuration option, otherwise a compile time error in the configuration file will occur.

The application shall define at least one of the following configuration options

- *[CONFIGURE\\_RTEMS\\_INIT\\_TASKS\\_TABLE](#page-663-0)* (page 636),
- *[CONFIGURE\\_POSIX\\_INIT\\_THREAD\\_TABLE](#page-677-0)* (page 650), or
- CONFIGURE\_IDLE\_TASK\_INITIALIZES\_APPLICATION

otherwise a compile time error in the configuration file will occur.

If no Classic API initialization task and no POSIX API initialization thread is configured, then no *[Global Construction](#page-119-0)* (page 92) is performed.

## <span id="page-738-1"></span><span id="page-738-0"></span>27.17.3 CONFIGURE\_IDLE\_TASK\_STACK\_SIZE

#### CONSTANT:

CONFIGURE\_IDLE\_TASK\_STACK\_SIZE

#### OPTION TYPE:

This configuration option is an integer define.

## DEFAULT VALUE:

If the *[CONFIGURE\\_DISABLE\\_BSP\\_SETTINGS](#page-597-0)* (page 570) configuration option is not defined and BSP\_IDLE\_TASK\_STACK\_SIZE is provided by the *[BSP](#page-1061-0)*, then the default value is defined by BSP\_IDLE\_TASK\_STACK\_SIZE, otherwise the default value is defined by the *[CONFIG-](#page-613-0)[URE\\_MINIMUM\\_TASK\\_STACK\\_SIZE](#page-613-0)* (page 586) configuration option.

#### DESCRIPTION:

The value of this configuration option defines the task stack size for an IDLE task.

## NOTES:

In SMP configurations, there is one IDLE task per configured processor, see *[CONFIG-](#page-606-0)[URE\\_MAXIMUM\\_PROCESSORS](#page-606-0)* (page 579).

#### CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to a BSP-specific and application-specific minimum value.
- The value of the configuration option shall be small enough so that the IDLE task stack area calculation carried out by <rtems/confdefs.h> does not overflow an integer of type [size\\_t.](https://en.cppreference.com/w/c/types/size_t)

## <span id="page-739-1"></span><span id="page-739-0"></span>27.17.4 CONFIGURE\_IDLE\_TASK\_STORAGE\_SIZE

#### CONSTANT:

CONFIGURE\_IDLE\_TASK\_STORAGE\_SIZE

#### OPTION TYPE:

This configuration option is an integer define.

## DEFAULT VALUE:

This configuration option has no default value. If it is not specified, then the task storage area for each *[IDLE task](#page-1067-2)* will allocated from the RTEMS Workspace or through a custom IDLE task stack allocator.

## DESCRIPTION:

If this configuration option is specified, then the task storage areas for the *[IDLE tasks](#page-1067-2)* are statically allocated by <rtems/confdefs.h>. The value of this configuration option defines the size in bytes of the task storage area of each IDLE task in the system.

#### NOTES:

By default, the IDLE task storage areas are allocated from the RTEMS Workspace. Applications which do not want to use a heap allocator can use this configuration option to use statically allocated memory for the IDLE task storage areas. The task storage area contains the task stack, the thread-local storage, and the floating-point context on architectures with a separate floating-point context. The size of the thread-local storage area is defined at link time or by the *[CONFIGURE\\_MAXIMUM\\_THREAD\\_LOCAL\\_STORAGE\\_SIZE](#page-607-0)* (page 580) configuration option. You have to estimate the actual thread-local storage size if you want to use this configuration option. If the IDLE task stack size would be less than the value defined by the *[CONFIGURE\\_IDLE\\_TASK\\_STACK\\_SIZE](#page-738-0)* (page 711) configuration option, for example because the thread-local storage size is larger than expected, then the system terminates with the *[INTERNAL\\_ERROR\\_CORE](#page-547-0)* (page 520) fatal source and the *[INTER-](#page-548-0)[NAL\\_ERROR\\_IDLE\\_THREAD\\_STACK\\_TOO\\_SMALL](#page-548-0)* (page 521) fatal code during system initialization.

The value of this configuration option is passed to *[RTEMS\\_TASK\\_STORAGE\\_SIZE\(\)](#page-171-0)* (page 144) by <rtems/confdefs.h> to determine the actual size of the statically allocated area to take architecture-specific overheads into account.

## The

- CONFIGURE\_IDLE\_TASK\_STORAGE\_SIZE, and
- *[CONFIGURE\\_TASK\\_STACK\\_ALLOCATOR\\_FOR\\_IDLE](#page-731-0)* (page 704)

configuration options are mutually exclusive.

# CONSTRAINTS:

The value of the configuration option shall be greater than or equal to *[CONFIG-](#page-738-0)[URE\\_IDLE\\_TASK\\_STACK\\_SIZE](#page-738-0)* (page 711).

# <span id="page-740-0"></span>27.18 General Scheduler Configuration

This section describes configuration options related to selecting a scheduling algorithm for an application. A scheduler configuration is optional and only necessary in very specific circumstances. A normal application configuration does not need any of the configuration options described in this section.

By default, the *[Deterministic Priority Scheduler](#page-95-1)* (page 68) algorithm is used in uniprocessor configurations. In case SMP is enabled and the configured maximum processors (*[CONFIG-](#page-606-0)[URE\\_MAXIMUM\\_PROCESSORS](#page-606-0)* (page 579)) is greater than one, then the *[Earliest Deadline First](#page-97-1) [SMP Scheduler](#page-97-1)* (page 70) is selected as the default scheduler algorithm.

For the schedulers provided by RTEMS (see *[Scheduling Concepts](#page-88-0)* (page 61)), the configuration is straightforward. All that is required is to define the configuration option which specifies which scheduler you want for in your application.

The pluggable scheduler interface also enables the user to provide their own scheduling algorithm. If you choose to do this, you must define multiple configuration option.

## <span id="page-741-1"></span><span id="page-741-0"></span>27.18.1 CONFIGURE\_CBS\_MAXIMUM\_SERVERS

#### CONSTANT:

CONFIGURE\_CBS\_MAXIMUM\_SERVERS

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is *[CONFIGURE\\_MAXIMUM\\_TASKS](#page-650-0)* (page 623).

#### DESCRIPTION:

The value of this configuration option defines the maximum number Constant Bandwidth Servers that can be concurrently active.

## NOTES:

This configuration option is only evaluated if the configuration option *[CONFIG-](#page-744-0)[URE\\_SCHEDULER\\_CBS](#page-744-0)* (page 717) is defined.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to [SIZE\\_MAX.](https://en.cppreference.com/w/c/types/limits)
- The value of the configuration option shall be less than or equal to a BSP-specific and application-specific value which depends on the size of the memory available to the application.

## <span id="page-742-1"></span><span id="page-742-0"></span>27.18.2 CONFIGURE\_MAXIMUM\_PRIORITY

#### CONSTANT:

CONFIGURE\_MAXIMUM\_PRIORITY

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 255.

#### DESCRIPTION:

For the following schedulers

- *[Deterministic Priority Scheduler](#page-95-1)* (page 68), which is the default in uniprocessor configurations and can be configured through the *[CONFIGURE\\_SCHEDULER\\_PRIORITY](#page-748-0)* (page 721) configuration option,
- *[Deterministic Priority SMP Scheduler](#page-97-2)* (page 70) which can be configured through the *[CON-](#page-750-0)[FIGURE\\_SCHEDULER\\_PRIORITY\\_SMP](#page-750-0)* (page 723) configuration option, and
- *[Arbitrary Processor Affinity Priority SMP Scheduler](#page-97-4)* (page 70) which can be configured through the *[CONFIGURE\\_SCHEDULER\\_PRIORITY\\_AFFINITY\\_SMP](#page-749-0)* (page 722) configuration option

this configuration option specifies the maximum numeric priority of any task for these schedulers and one less that the number of priority levels for these schedulers. For all other schedulers provided by RTEMS, this configuration option has no effect.

## NOTES:

The numerically greatest priority is the logically lowest priority in the system and will thus be used by the IDLE task.

Priority zero is reserved for internal use by RTEMS and is not available to applications.

Reducing the number of priorities through this configuration option reduces the amount of memory allocated by the schedulers listed above. These schedulers use a chain control structure per priority and this structure consists of three pointers. On a 32-bit architecture, the allocated memory is 12 bytes \* (CONFIGURE\_MAXIMUM\_PRIORITY + 1), e.g. 3072 bytes for 256 priority levels (default), 48 bytes for 4 priority levels (CONFIGURE\_MAXIMUM\_PRIORITY == 3).

The default value is 255, because RTEMS shall support 256 priority levels to be compliant with various standards. These priorities range from 0 to 255.

## CONSTRAINTS:

The value of the configuration option shall be equal to 3, 7, 31, 63, 127, or 255.

## <span id="page-743-1"></span><span id="page-743-0"></span>27.18.3 CONFIGURE\_SCHEDULER\_ASSIGNMENTS

#### CONSTANT:

CONFIGURE\_SCHEDULER\_ASSIGNMENTS

#### OPTION TYPE:

This configuration option is an initializer define.

#### DEFAULT VALUE:

The default value of this configuration option is computed so that the default scheduler is assigned to each configured processor (up to 32).

#### DESCRIPTION:

The value of this configuration option is used to initialize the initial scheduler to processor assignments.

#### NOTES:

Where the system was built with SMP support enabled, this configuration option is evaluated, otherwise it is ignored.

This is an advanced configuration option, see *[Clustered Scheduler Configuration](#page-756-0)* (page 729).

#### CONSTRAINTS:

The following constraints apply to this configuration option:

- The value of the configuration option shall be a list of the following macros:
  - **â€“** RTEMS\_SCHEDULER\_ASSIGN( scheduler\_index, attributes )
  - **â€“** RTEMS\_SCHEDULER\_ASSIGN\_NO\_SCHEDULER

The scheduler\_index macro parameter shall be a valid index of the scheduler table defined by the *[CONFIGURE\\_SCHEDULER\\_TABLE\\_ENTRIES](#page-754-0)* (page 727) configuration option.

The attributes macro parameter shall be set to exactly one of the following constants:

- **â€“** RTEMS\_SCHEDULER\_ASSIGN\_PROCESSOR\_MANDATORY
- **â€“** RTEMS\_SCHEDULER\_ASSIGN\_PROCESSOR\_OPTIONAL
- The value of the configuration option shall be a list of exactly *[CONFIG-](#page-606-0)[URE\\_MAXIMUM\\_PROCESSORS](#page-606-0)* (page 579) elements.

## <span id="page-744-1"></span><span id="page-744-0"></span>27.18.4 CONFIGURE\_SCHEDULER\_CBS

#### CONSTANT:

CONFIGURE\_SCHEDULER\_CBS

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the *[Constant Bandwidth Server Scheduling](#page-96-0) [\(CBS\)](#page-96-0)* (page 69) algorithm is made available to the application.

## NOTES:

This scheduler configuration option is an advanced configuration option. Think twice before you use it.

In case no explicit *[Clustered Scheduler Configuration](#page-756-0)* (page 729) is present, then it is used as the scheduler for exactly one processor.

## <span id="page-745-1"></span><span id="page-745-0"></span>27.18.5 CONFIGURE\_SCHEDULER\_EDF

#### CONSTANT:

CONFIGURE\_SCHEDULER\_EDF

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the *[Earliest Deadline First Scheduler](#page-95-3)* (page 68) algorithm is made available to the application.

## NOTES:

This scheduler configuration option is an advanced configuration option. Think twice before you use it.

In case no explicit *[Clustered Scheduler Configuration](#page-756-0)* (page 729) is present, then it is used as the scheduler for exactly one processor.

## <span id="page-746-1"></span><span id="page-746-0"></span>27.18.6 CONFIGURE\_SCHEDULER\_EDF\_SMP

#### CONSTANT:

CONFIGURE\_SCHEDULER\_EDF\_SMP

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the *[Earliest Deadline First SMP Scheduler](#page-97-1)* (page 70) algorithm is made available to the application.

## NOTES:

This scheduler configuration option is an advanced configuration option. Think twice before you use it.

This scheduler algorithm is only available when RTEMS is built with SMP support enabled.

In case no explicit *[Clustered Scheduler Configuration](#page-756-0)* (page 729) is present, then it is used as the scheduler for up to 32 processors.

This scheduler algorithm is the default in SMP configurations if *[CONFIG-](#page-606-0)[URE\\_MAXIMUM\\_PROCESSORS](#page-606-0)* (page 579) is greater than one.

## <span id="page-747-1"></span><span id="page-747-0"></span>27.18.7 CONFIGURE\_SCHEDULER\_NAME

#### CONSTANT:

CONFIGURE\_SCHEDULER\_NAME

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is

- "MEDF" for the *[Earliest Deadline First SMP Scheduler](#page-97-1)* (page 70),
- "MPA " for the *[Arbitrary Processor Affinity Priority SMP Scheduler](#page-97-4)* (page 70),
- "MPD " for the *[Deterministic Priority SMP Scheduler](#page-97-2)* (page 70),
- "MPS " for the *[Simple Priority SMP Scheduler](#page-97-3)* (page 70),
- "UCBS" for the *[Constant Bandwidth Server Scheduling \(CBS\)](#page-96-0)* (page 69),
- "UEDF" for the *[Earliest Deadline First Scheduler](#page-95-3)* (page 68),
- "UPD " for the *[Deterministic Priority Scheduler](#page-95-1)* (page 68), and
- "UPS " for the *[Simple Priority Scheduler](#page-95-2)* (page 68).

#### DESCRIPTION:

The value of this configuration option defines the name of the default scheduler.

#### NOTES:

This scheduler configuration option is an advanced configuration option. Think twice before you use it.

Schedulers can be identified via *[rtems\\_scheduler\\_ident\(\)](#page-99-0)* (page 72).

Use *[rtems\\_build\\_name\(\)](#page-931-0)* (page 904) to define the scheduler name.

#### CONSTRAINTS:

The value of the configuration option shall be convertible to an integer of type rtems\_name.

## <span id="page-748-1"></span><span id="page-748-0"></span>27.18.8 CONFIGURE\_SCHEDULER\_PRIORITY

#### CONSTANT:

CONFIGURE\_SCHEDULER\_PRIORITY

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the *[Deterministic Priority Scheduler](#page-95-1)* (page 68) algorithm is made available to the application.

## NOTES:

This scheduler configuration option is an advanced configuration option. Think twice before you use it.

In case no explicit *[Clustered Scheduler Configuration](#page-756-0)* (page 729) is present, then it is used as the scheduler for exactly one processor.

This scheduler algorithm is the default when *[CONFIGURE\\_MAXIMUM\\_PROCESSORS](#page-606-0)* (page 579) is exactly one.

The memory allocated for this scheduler depends on the *[CONFIGURE\\_MAXIMUM\\_PRIORITY](#page-742-0)* (page 715) configuration option.

## <span id="page-749-1"></span><span id="page-749-0"></span>27.18.9 CONFIGURE\_SCHEDULER\_PRIORITY\_AFFINITY\_SMP

#### CONSTANT:

CONFIGURE\_SCHEDULER\_PRIORITY\_AFFINITY\_SMP

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the *[Arbitrary Processor Affinity Priority SMP](#page-97-4) [Scheduler](#page-97-4)* (page 70) algorithm is made available to the application.

## NOTES:

This scheduler configuration option is an advanced configuration option. Think twice before you use it.

This scheduler algorithm is only available when RTEMS is built with SMP support enabled.

In case no explicit *[Clustered Scheduler Configuration](#page-756-0)* (page 729) is present, then it is used as the scheduler for up to 32 processors.

The memory allocated for this scheduler depends on the *[CONFIGURE\\_MAXIMUM\\_PRIORITY](#page-742-0)* (page 715) configuration option.

## <span id="page-750-1"></span><span id="page-750-0"></span>27.18.10 CONFIGURE\_SCHEDULER\_PRIORITY\_SMP

#### CONSTANT:

CONFIGURE\_SCHEDULER\_PRIORITY\_SMP

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the *[Deterministic Priority SMP Scheduler](#page-97-2)* (page 70) algorithm is made available to the application.

## NOTES:

This scheduler configuration option is an advanced configuration option. Think twice before you use it.

This scheduler algorithm is only available when RTEMS is built with SMP support enabled.

In case no explicit *[Clustered Scheduler Configuration](#page-756-0)* (page 729) is present, then it is used as the scheduler for up to 32 processors.

The memory allocated for this scheduler depends on the *[CONFIGURE\\_MAXIMUM\\_PRIORITY](#page-742-0)* (page 715) configuration option.

## <span id="page-751-1"></span><span id="page-751-0"></span>27.18.11 CONFIGURE\_SCHEDULER\_SIMPLE

#### CONSTANT:

CONFIGURE\_SCHEDULER\_SIMPLE

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the *[Simple Priority Scheduler](#page-95-2)* (page 68) algorithm is made available to the application.

## NOTES:

This scheduler configuration option is an advanced configuration option. Think twice before you use it.

In case no explicit *[Clustered Scheduler Configuration](#page-756-0)* (page 729) is present, then it is used as the scheduler for exactly one processor.

## <span id="page-752-1"></span><span id="page-752-0"></span>27.18.12 CONFIGURE\_SCHEDULER\_SIMPLE\_SMP

#### CONSTANT:

CONFIGURE\_SCHEDULER\_SIMPLE\_SMP

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the *[Simple Priority SMP Scheduler](#page-97-3)* (page 70) algorithm is made available to the application.

## NOTES:

This scheduler configuration option is an advanced configuration option. Think twice before you use it.

This scheduler algorithm is only available when RTEMS is built with SMP support enabled.

In case no explicit *[Clustered Scheduler Configuration](#page-756-0)* (page 729) is present, then it is used as the scheduler for up to 32 processors.

## <span id="page-753-1"></span><span id="page-753-0"></span>27.18.13 CONFIGURE\_SCHEDULER\_STRONG\_APA

#### CONSTANT:

CONFIGURE\_SCHEDULER\_STRONG\_APA

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the Strong APA algorithm is made available to the application.

## NOTES:

This scheduler configuration option is an advanced configuration option. Think twice before you use it.

This scheduler algorithm is only available when RTEMS is built with SMP support enabled.

This scheduler algorithm is not correctly implemented. Do not use it.

## <span id="page-754-1"></span><span id="page-754-0"></span>27.18.14 CONFIGURE\_SCHEDULER\_TABLE\_ENTRIES

#### CONSTANT:

CONFIGURE\_SCHEDULER\_TABLE\_ENTRIES

#### OPTION TYPE:

This configuration option is an initializer define.

#### DEFAULT VALUE:

The default value of this configuration option is the definition of exactly one table entry for the configured scheduler.

## DESCRIPTION:

The value of this configuration option is used to initialize the table of configured schedulers.

## NOTES:

Schedulers registered in the scheduler table by this configuration option are available to the application. The scheduler table entry index defines the index of the scheduler.

This is an advanced configuration option, see *[Clustered Scheduler Configuration](#page-756-0)* (page 729).

#### CONSTRAINTS:

The following constraints apply to this configuration option:

- The value of the configuration option shall be a list of the following macros:
  - **â€“** RTEMS\_SCHEDULER\_TABLE\_CBS( name, obj\_name )
  - **â€“** RTEMS\_SCHEDULER\_TABLE\_EDF( name, obj\_name )
  - **â€“** RTEMS\_SCHEDULER\_TABLE\_EDF\_SMP( name, obj\_name )
  - **â€“** RTEMS\_SCHEDULER\_TABLE\_PRIORITY\_AFFINITY\_SMP( name, obj\_name )
  - **â€“** RTEMS\_SCHEDULER\_TABLE\_PRIORITY( name, obj\_name )
  - **â€“** RTEMS\_SCHEDULER\_TABLE\_PRIORITY\_SMP( name, obj\_name )
  - **â€“** RTEMS\_SCHEDULER\_TABLE\_SIMPLE( name, obj\_name )
  - **â€“** RTEMS\_SCHEDULER\_TABLE\_SIMPLE\_SMP( name, obj\_name )
  - **â€“** RTEMS\_SCHEDULER\_TABLE\_STRONG\_APA( name, obj\_name )

The name macro parameter shall be the name associated with the scheduler data structures, see *[Clustered Scheduler Configuration](#page-756-0)* (page 729).

The obj\_name macro parameter shall be the scheduler object name. It is recommended to define the scheduler object name through *[rtems\\_build\\_name\(\)](#page-931-0)* (page 904).

â€¢ Where the system was build with SMP support enabled, the table shall have one or more entries, otherwise it shall have exactly one entry.

## <span id="page-755-1"></span><span id="page-755-0"></span>27.18.15 CONFIGURE\_SCHEDULER\_USER

#### CONSTANT:

CONFIGURE\_SCHEDULER\_USER

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

In case this configuration option is defined, then the user shall provide a scheduler algorithm to the application.

## NOTES:

This scheduler configuration option is an advanced configuration option. Think twice before you use it.

RTEMS allows the application to provide its own task/thread scheduling algorithm. In order to do this, one shall define CONFIGURE\_SCHEDULER\_USER to indicate the application provides its own scheduling algorithm. If CONFIGURE\_SCHEDULER\_USER is defined then the following additional macros shall be defined:

- CONFIGURE\_SCHEDULER shall be defined to a static definition of the scheduler data structures of the user scheduler.
- CONFIGURE\_SCHEDULER\_TABLE\_ENTRIES shall be defined to a scheduler table entry initializer for the user scheduler.
- CONFIGURE\_SCHEDULER\_USER\_PER\_THREAD shall be defined to the type of the per-thread information of the user scheduler.

At this time, the mechanics and requirements for writing a new scheduler are evolving and not fully documented. It is recommended that you look at the existing Deterministic Priority Scheduler in cpukit/score/src/schedulerpriority\*.c for guidance. For guidance on the configuration macros, please examine cpukit/include/rtems/confdefs/scheduler.h for how these are defined for the Deterministic Priority Scheduler.

# <span id="page-756-0"></span>27.19 Clustered Scheduler Configuration

This section describes configuration options related to clustered scheduling. A clustered scheduler configuration is optional. It is an advanced configuration area and only necessary in specific circumstances.

Clustered scheduling helps to control the worst-case latencies in a multiprocessor system (SMP). The goal is to reduce the amount of shared state in the system and thus prevention of lock contention. Modern multiprocessor systems tend to have several layers of data and instruction caches. With clustered scheduling it is possible to honour the cache topology of a system and thus avoid expensive cache synchronization traffic.

We have clustered scheduling in case the set of processors of a system is partitioned into nonempty pairwise-disjoint subsets. These subsets are called clusters. Clusters with a cardinality of one are partitions. Each cluster is owned by exactly one scheduler.

In order to use clustered scheduling the application designer has to answer two questions.

- 1. How is the set of processors partitioned into clusters?
- 2. Which scheduler algorithm is used for which cluster?

The schedulers are statically configured.

# <span id="page-756-1"></span>27.19.1 Configuration Step 1 - Scheduler Algorithms

Firstly, the application must select which scheduling algorithms are available with the following defines

- *[CONFIGURE\\_SCHEDULER\\_EDF\\_SMP](#page-746-0)* (page 719),
- *[CONFIGURE\\_SCHEDULER\\_PRIORITY\\_AFFINITY\\_SMP](#page-749-0)* (page 722),
- *[CONFIGURE\\_SCHEDULER\\_PRIORITY\\_SMP](#page-750-0)* (page 723), and
- *[CONFIGURE\\_SCHEDULER\\_SIMPLE\\_SMP](#page-752-0)* (page 725).

This is necessary to calculate the per-thread overhead introduced by the scheduler algorithms. After these definitions the configuration file must #include <rtems/scheduler.h> to have access to scheduler-specific configuration macros.

It is possible to make more than one scheduler algorithm available to the application. For example a *[Simple Priority SMP Scheduler](#page-97-3)* (page 70) could be used in a partition for low latency tasks in addition to an *[EDF SMP Scheduler](#page-97-1)* (page 70) for a general-purpose cluster. Since the per-thread overhead depends on the scheduler algorithm only the scheduler algorithms used by the application should be configured.

## <span id="page-756-2"></span>27.19.2 Configuration Step 2 - Schedulers

Each scheduler needs some data structures. Use the following macros to create the scheduler data structures for a particular scheduler identified in the configuration by name.

- RTEMS\_SCHEDULER\_EDF\_SMP(name),
- RTEMS\_SCHEDULER\_PRIORITY\_AFFINITY\_SMP(name, prio\_count),
- RTEMS\_SCHEDULER\_PRIORITY\_SMP(name, prio\_count), and
- RTEMS\_SCHEDULER\_SIMPLE\_SMP(name).

The name parameter is used as part of a designator for scheduler-specific data structures, so the usual C/C++ designator rules apply. This name is not the scheduler object name. Additional parameters are scheduler-specific.

## <span id="page-757-0"></span>27.19.3 Configuration Step 3 - Scheduler Table

The schedulers are registered in the system via the scheduler table. To populate the scheduler table define CONFIGURE\_SCHEDULER\_TABLE\_ENTRIES to a list of the following scheduler table entry initializers

- RTEMS\_SCHEDULER\_TABLE\_EDF\_SMP(name, obj\_name),
- RTEMS\_SCHEDULER\_TABLE\_PRIORITY\_AFFINITY\_SMP(name, obj\_name),
- RTEMS\_SCHEDULER\_TABLE\_PRIORITY\_SMP(name, obj\_name), and
- RTEMS\_SCHEDULER\_TABLE\_SIMPLE\_SMP(name, obj\_name).

The name parameter must correspond to the parameter defining the scheduler data structures of configuration step 2. The obj\_name determines the scheduler object name and can be used in rtems\_scheduler\_ident() to get the scheduler object identifier. The scheduler index is defined by the index of the scheduler table. It is a configuration error to add a scheduler multiple times to the scheduler table.

## <span id="page-757-1"></span>27.19.4 Configuration Step 4 - Processor to Scheduler Assignment

The last step is to define which processor uses which scheduler. For this purpose a scheduler assignment table must be defined. The entry count of this table must be equal to the configured maximum processors (*[CONFIGURE\\_MAXIMUM\\_PROCESSORS](#page-606-0)* (page 579)). A processor assignment to a scheduler can be optional or mandatory. The boot processor must have a scheduler assigned. In case the system needs more mandatory processors than available then a fatal run-time error will occur. To specify the scheduler assignments define CONFIGURE\_SCHEDULER\_ASSIGNMENTS to a list of

- RTEMS\_SCHEDULER\_ASSIGN(scheduler\_index, attr) and
- RTEMS\_SCHEDULER\_ASSIGN\_NO\_SCHEDULER

macros. The scheduler\_index parameter must be a valid index into the scheduler table defined by configuration step 3. The attr parameter defines the scheduler assignment attributes. By default, a scheduler assignment to a processor is optional. For the scheduler assignment attribute use one of the mutually exclusive variants

- RTEMS\_SCHEDULER\_ASSIGN\_DEFAULT,
- RTEMS\_SCHEDULER\_ASSIGN\_PROCESSOR\_MANDATORY, and
- RTEMS\_SCHEDULER\_ASSIGN\_PROCESSOR\_OPTIONAL.

It is possible to add/remove processors to/from schedulers at run-time, see rtems\_scheduler\_add\_processor() and rtems\_scheduler\_remove\_processor().

## <span id="page-757-2"></span>27.19.5 Configuration Example

The following example shows a scheduler configuration for a hypothetical product using two chip variants. One variant has four processors which is used for the normal product line and another provides eight processors for the high-performance product line. The first processor performs hard-real time control of actuators and sensors. The second processor is not used by RTEMS at all and runs a Linux instance to provide a graphical user interface. The additional processors are used for a worker thread pool to perform data processing operations.

The processors managed by RTEMS use two Deterministic Priority SMP schedulers capable of dealing with 256 priority levels. The scheduler with index zero has the name "IO ". The scheduler with index one has the name "WORK". The scheduler assignments of the first, third and fourth processor are mandatory, so the system must have at least four processors, otherwise a fatal run-time error will occur during system startup. The processor assignments for the fifth up to the eighth processor are optional so that the same application can be used for the normal and high-performance product lines. The second processor has no scheduler assigned and runs Linux. A hypervisor will ensure that the two systems cannot interfere in an undesirable way.

```
1 #define CONFIGURE_MAXIMUM_PROCESSORS 8
2 #define CONFIGURE_MAXIMUM_PRIORITY 255
3
4 /* Configuration Step 1 - Scheduler Algorithms */
5 #define CONFIGURE_SCHEDULER_PRIORITY_SMP
6 #include <rtems/scheduler.h>
7
8 /* Configuration Step 2 - Schedulers */
9 RTEMS_SCHEDULER_PRIORITY_SMP(io, CONFIGURE_MAXIMUM_PRIORITY + 1);
10 RTEMS_SCHEDULER_PRIORITY_SMP(work, CONFIGURE_MAXIMUM_PRIORITY + 1);
11
12 /* Configuration Step 3 - Scheduler Table */
13 #define CONFIGURE_SCHEDULER_TABLE_ENTRIES \
14 RTEMS_SCHEDULER_TABLE_PRIORITY_SMP( \
15 io, \
16 rtems_build_name('I', 'O', ' ', ' ') \
17 ), \
18 RTEMS_SCHEDULER_TABLE_PRIORITY_SMP( \
19 work, \
20 rtems_build_name('W', 'O', 'R', 'K') \
21 )
22
23 /* Configuration Step 4 - Processor to Scheduler Assignment */
24 #define CONFIGURE_SCHEDULER_ASSIGNMENTS \
25 RTEMS_SCHEDULER_ASSIGN(0, RTEMS_SCHEDULER_ASSIGN_PROCESSOR_MANDATORY), \
26 RTEMS_SCHEDULER_ASSIGN_NO_SCHEDULER, \
27 RTEMS_SCHEDULER_ASSIGN(1, RTEMS_SCHEDULER_ASSIGN_PROCESSOR_MANDATORY), \
28 RTEMS_SCHEDULER_ASSIGN(1, RTEMS_SCHEDULER_ASSIGN_PROCESSOR_MANDATORY), \
29 RTEMS_SCHEDULER_ASSIGN(1, RTEMS_SCHEDULER_ASSIGN_PROCESSOR_OPTIONAL), \
30 RTEMS_SCHEDULER_ASSIGN(1, RTEMS_SCHEDULER_ASSIGN_PROCESSOR_OPTIONAL), \
31 RTEMS_SCHEDULER_ASSIGN(1, RTEMS_SCHEDULER_ASSIGN_PROCESSOR_OPTIONAL), \
32 RTEMS_SCHEDULER_ASSIGN(1, RTEMS_SCHEDULER_ASSIGN_PROCESSOR_OPTIONAL)
```

## <span id="page-758-0"></span>27.19.6 Configuration Errors

In case one of the scheduler indices in CONFIGURE\_SCHEDULER\_ASSIGNMENTS is invalid a link-time error will occur with an undefined reference to RTEMS\_SCHEDULER\_INVALID\_INDEX.

Some fatal errors may occur in case of scheduler configuration inconsistencies or a lack of processors on the system. The fatal source is RTEMS\_FATAL\_SOURCE\_SMP.

- SMP\_FATAL\_BOOT\_PROCESSOR\_NOT\_ASSIGNED\_TO\_SCHEDULER the boot processor must have a scheduler assigned.
- SMP\_FATAL\_MANDATORY\_PROCESSOR\_NOT\_PRESENT there exists a mandatory processor beyond the range of physically or virtually available processors. The processor demand must be reduced for this system.
- SMP\_FATAL\_START\_OF\_MANDATORY\_PROCESSOR\_FAILED the start of a mandatory processor failed during system initialization. The system may not have this processor at all or it could be a problem with a boot loader for example. Check the CONFIGURE\_SCHEDULER\_ASSIGNMENTS definition.
- SMP\_FATAL\_MULTITASKING\_START\_ON\_UNASSIGNED\_PROCESSOR it is not allowed to start multitasking on a processor with no scheduler assigned.

# <span id="page-760-0"></span>27.20 FACE Technical Standard Related Configuration

This section describes configuration options related to adapting RTEMS behavior to be aligned with the FACE Technical Standard. The FACE Technical Standard is a product of the FACE Consortium which operates under the Open Group. The FACE Consortium was founded by avionics organizations to improve the portability of cockpit software across various platforms. It addresses technical and business concerns.

Most important from an RTEMS perspective, the FACE Technical Standard defines four POSIX profiles: Security, Safety Base, Safety Extended, and the General Purpose Profile. Each has an increasingly larger subset of POSIX APIs. In the Security and Safety profiles, ARINC 653 is required. It is optional in the General Purpose Profile.

The RTEMS Project has been tracking alignment with the FACE POSIX profiles and they are included in the "RTEMS POSIX 1003.1 Compliance Guide."

## <span id="page-761-1"></span><span id="page-761-0"></span>27.20.1 CONFIGURE\_POSIX\_TIMERS\_FACE\_BEHAVIOR

#### CONSTANT:

CONFIGURE\_POSIX\_TIMERS\_FACE\_BEHAVIOR

#### OPTION TYPE:

This configuration option is a boolean feature define.

#### DEFAULT CONFIGURATION:

If this configuration option is undefined, then the described feature is not enabled.

#### DESCRIPTION:

If this configuration option is defined, then POSIX timers may not be created to use the *[CLOCK\\_REALTIME](#page-1062-2)*. Per POSIX, this is allowed behavior but per the FACE Technical Standard, it is not. Using POSIX timers based on CLOCK\_REALTIME (e.g., time of day) is unsafe for real-time safety systems as setting CLOCK\_REALTIME will perturb any active timers.

If this option is not defined, POSIX timers may be created to use the CLOCK\_REALTIME in compliance with the POSIX specification.

# <span id="page-762-0"></span>27.21 Multiprocessing Configuration

This section describes multiprocessing related configuration options. The options are only used if RTEMS was built when the multiprocessing build configuration option is enabled. The multiprocessing configuration is distinct from the SMP configuration. Additionally, this class of configuration options are only applicable if the configuration option *[CONFIGURE\\_MP\\_APPLICATION](#page-764-0)* (page 737) is defined. The multiprocessing (MPCI) support must not be confused with the SMP support.

## <span id="page-763-1"></span><span id="page-763-0"></span>27.21.1 CONFIGURE\_EXTRA\_MPCI\_RECEIVE\_SERVER\_STACK

#### CONSTANT:

CONFIGURE\_EXTRA\_MPCI\_RECEIVE\_SERVER\_STACK

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 0.

#### DESCRIPTION:

The value of this configuration option defines the number of bytes the applications wishes to add to the MPCI task stack on top of *[CONFIGURE\\_MINIMUM\\_TASK\\_STACK\\_SIZE](#page-613-0)* (page 586).

## NOTES:

This configuration option is only evaluated if *[CONFIGURE\\_MP\\_APPLICATION](#page-764-0)* (page 737) is defined.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to [UINT32\\_MAX.](https://en.cppreference.com/w/c/types/integer)
- The value of the configuration option shall be small enough so that the MPCI receive server stack area calculation carried out by <rtems/confdefs.h> does not overflow an integer of type [size\\_t.](https://en.cppreference.com/w/c/types/size_t)

## <span id="page-764-1"></span><span id="page-764-0"></span>27.21.2 CONFIGURE\_MP\_APPLICATION

#### CONSTANT:

CONFIGURE\_MP\_APPLICATION

#### OPTION TYPE:

This configuration option is a boolean feature define.

## DEFAULT CONFIGURATION:

If this configuration option is undefined, then the multiprocessing services are not initialized.

#### DESCRIPTION:

This configuration option is defined to indicate that the application intends to be part of a multiprocessing configuration. Additional configuration options are assumed to be provided.

## NOTES:

This configuration option shall be undefined if the multiprocessing support is not enabled (e.g. RTEMS was built without the multiprocessing build configuration option enabled). Otherwise a compile time error in the configuration file will occur.

## <span id="page-765-1"></span><span id="page-765-0"></span>27.21.3 CONFIGURE\_MP\_MAXIMUM\_GLOBAL\_OBJECTS

#### CONSTANT:

CONFIGURE\_MP\_MAXIMUM\_GLOBAL\_OBJECTS

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 32.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of concurrently active global objects in a multiprocessor system.

## NOTES:

This value corresponds to the total number of objects which can be created with the RTEMS\_GLOBAL attribute.

This configuration option is only evaluated if *[CONFIGURE\\_MP\\_APPLICATION](#page-764-0)* (page 737) is defined.

#### CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to [UINT32\\_MAX.](https://en.cppreference.com/w/c/types/integer)

## <span id="page-766-1"></span><span id="page-766-0"></span>27.21.4 CONFIGURE\_MP\_MAXIMUM\_NODES

#### CONSTANT:

CONFIGURE\_MP\_MAXIMUM\_NODES

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 2.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of nodes in a multiprocessor system.

## NOTES:

This configuration option is only evaluated if *[CONFIGURE\\_MP\\_APPLICATION](#page-764-0)* (page 737) is defined.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to [UINT32\\_MAX.](https://en.cppreference.com/w/c/types/integer)

## <span id="page-767-1"></span><span id="page-767-0"></span>27.21.5 CONFIGURE\_MP\_MAXIMUM\_PROXIES

#### CONSTANT:

CONFIGURE\_MP\_MAXIMUM\_PROXIES

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is 32.

#### DESCRIPTION:

The value of this configuration option defines the maximum number of concurrently active thread/task proxies on this node in a multiprocessor system.

## NOTES:

Since a proxy is used to represent a remote task/thread which is blocking on this node. This configuration parameter reflects the maximum number of remote tasks/threads which can be blocked on objects on this node, see *[Proxies](#page-876-0)* (page 849).

This configuration option is only evaluated if *[CONFIGURE\\_MP\\_APPLICATION](#page-764-0)* (page 737) is defined.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to [UINT32\\_MAX.](https://en.cppreference.com/w/c/types/integer)

## <span id="page-768-1"></span><span id="page-768-0"></span>27.21.6 CONFIGURE\_MP\_MPCI\_TABLE\_POINTER

#### CONSTANT:

CONFIGURE\_MP\_MPCI\_TABLE\_POINTER

#### OPTION TYPE:

This configuration option is an initializer define.

## DEFAULT VALUE:

The default value is &MPCI\_table.

#### DESCRIPTION:

The value of this configuration option initializes the MPCI Configuration Table.

#### NOTES:

RTEMS provides a Shared Memory MPCI Device Driver which can be used on any Multiprocessor System assuming the BSP provides the proper set of supporting methods.

This configuration option is only evaluated if *[CONFIGURE\\_MP\\_APPLICATION](#page-764-0)* (page 737) is defined.

#### CONSTRAINTS:

The value of the configuration option shall be a pointer to rtems\_mpci\_table.

## <span id="page-769-1"></span><span id="page-769-0"></span>27.21.7 CONFIGURE\_MP\_NODE\_NUMBER

#### CONSTANT:

CONFIGURE\_MP\_NODE\_NUMBER

#### OPTION TYPE:

This configuration option is an integer define.

#### DEFAULT VALUE:

The default value is NODE\_NUMBER.

#### DESCRIPTION:

The value of this configuration option defines the node number of this node in a multiprocessor system.

## NOTES:

In the RTEMS Multiprocessing Test Suite, the node number is derived from the Makefile variable NODE\_NUMBER. The same code is compiled with the NODE\_NUMBER set to different values. The test programs behave differently based upon their node number.

This configuration option is only evaluated if *[CONFIGURE\\_MP\\_APPLICATION](#page-764-0)* (page 737) is defined.

## CONSTRAINTS:

- The value of the configuration option shall be greater than or equal to zero.
- The value of the configuration option shall be less than or equal to [UINT32\\_MAX.](https://en.cppreference.com/w/c/types/integer)

# <span id="page-770-1"></span><span id="page-770-0"></span>27.22 PCI Library Configuration

This section defines the system configuration parameters supported by rtems/confdefs.h related to configuring the PCI Library for RTEMS.

The PCI Library startup behaviour can be configured in four different ways depending on how CONFIGURE\_PCI\_CONFIG\_LIB is defined:

#### **PCI\_LIB\_AUTO**

Used to enable the PCI auto configuration software. PCI will be automatically probed, PCI buses enumerated, all devices and bridges will be initialized using Plug & Play software routines. The PCI device tree will be populated based on the PCI devices found in the system, PCI devices will be configured by allocating address region resources automatically in PCI space according to the BSP or host bridge driver set up.

#### **PCI\_LIB\_READ**

Used to enable the PCI read configuration software. The current PCI configuration is read to create the RAM representation (the PCI device tree) of the PCI devices present. PCI devices are assumed to already have been initialized and PCI buses enumerated, it is therefore required that a BIOS or a boot loader has set up configuration space prior to booting into RTEMS.

#### **PCI\_LIB\_STATIC**

Used to enable the PCI static configuration software. The user provides a PCI tree with information how all PCI devices are to be configured at compile time by linking in a custom struct pci\_bus pci\_hb tree. The static PCI library will not probe PCI for devices, instead it will assume that all devices defined by the user are present, it will enumerate the PCI buses and configure all PCI devices in static configuration accordingly. Since probe and allocation software is not needed the startup is faster, has smaller footprint and does not require dynamic memory allocation.

#### **PCI\_LIB\_PERIPHERAL**

Used to enable the PCI peripheral configuration. It is similar to PCI\_LIB\_STATIC, but it will never write the configuration to the PCI devices since PCI peripherals are not allowed to access PCI configuration space.

Note that selecting PCI\_LIB\_STATIC or PCI\_LIB\_PERIPHERAL but not defining pci\_hb will reuslt in link errors. Note also that in these modes Plug & Play is not performed.

# <span id="page-771-0"></span>27.23 Ada Configuration

The GNU Ada runtime library (libgnarl) uses threads, mutexes, condition variables, and signals from the pthreads API. It uses also thread-local storage for the Ada Task Control Block (ATCB). From these resources only the threads need to be accounted for in the configuration. You should include the Ada tasks in your setting of the *[CONFIGURE\\_MAXIMUM\\_POSIX\\_THREADS](#page-671-0)* (page 644) configuration option.

# <span id="page-772-0"></span>27.24 Directives

This section details the directives of the Application Configuration Information. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

27.24. Directives 745

<span id="page-773-1"></span><span id="page-773-0"></span>27.24.1 rtems\_get\_build\_label()

Gets the RTEMS build label.

## CALLING SEQUENCE:

```
1 const char *rtems_get_build_label( void );
```

### DESCRIPTION:

The build label is a user-provided string defined by the build configuration through the RTEMS\_BUILD\_LABEL build option. The format of the string is completely user-defined.

#### RETURN VALUES:

Returns a pointer to the RTEMS build label.

## NOTES:

The build label can be used to distinguish test suite results obtained from different build configurations. A use case is to record test results with performance data to track performance regressions. For this a database of performance limits is required. The build label and the target hash obtained from *[rtems\\_get\\_target\\_hash\(\)](#page-775-0)* (page 748) can be used as a key to obtain performance limits.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

<span id="page-774-1"></span><span id="page-774-0"></span>27.24.2 rtems\_get\_copyright\_notice()

Gets the RTEMS copyright notice.

## CALLING SEQUENCE:

```
1 const char *rtems_get_copyright_notice( void );
```

#### RETURN VALUES:

Returns a pointer to the RTEMS copyright notice.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

27.24. Directives 747

<span id="page-775-1"></span><span id="page-775-0"></span>27.24.3 rtems\_get\_target\_hash()

Gets the RTEMS target hash.

## CALLING SEQUENCE:

```
1 const char *rtems_get_target_hash( void );
```

### DESCRIPTION:

The target hash is calculated from BSP-specific values which characterize a target system. The target hash is encoded as a base64url string. The target hash algorithm is unspecified.

#### RETURN VALUES:

Returns a pointer to the RTEMS target hash.

#### NOTES:

For example, the device tree, settings of the memory controller, processor and bus frequencies, a serial number of a chip may be used to calculate the target hash.

The target hash can be used to distinguish test suite results obtained from different target systems. See also *[rtems\\_get\\_build\\_label\(\)](#page-773-0)* (page 746).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

<span id="page-776-1"></span><span id="page-776-0"></span>27.24.4 rtems\_get\_version\_string()

Gets the RTEMS version string.

## CALLING SEQUENCE:

```
1 const char *rtems_get_version_string( void );
```

### RETURN VALUES:

Returns a pointer to the RTEMS version string.

#### NOTES:

The version string has no particular format. Parsing the string may break across RTEMS releases.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

27.24. Directives 749

## <span id="page-777-1"></span><span id="page-777-0"></span>27.24.5 rtems\_configuration\_get\_do\_zero\_of\_workspace()

Indicates if the RTEMS Workspace is configured to be zeroed during system initialization for this application.

#### CALLING SEQUENCE:

```
1 bool rtems_configuration_get_do_zero_of_workspace( void );
```

#### RETURN VALUES:

Returns true, if the RTEMS Workspace is configured to be zeroed during system initialization for this application, otherwise false.

#### NOTES:

The setting is defined by the *[CONFIGURE\\_ZERO\\_WORKSPACE\\_AUTOMATICALLY](#page-620-0)* (page 593) application configuration option.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

<span id="page-778-1"></span><span id="page-778-0"></span>27.24.6 rtems\_configuration\_get\_idle\_task\_stack\_size()

Gets the IDLE task stack size in bytes of this application.

## CALLING SEQUENCE:

```
1 size_t rtems_configuration_get_idle_task_stack_size( void );
```

#### RETURN VALUES:

Returns the IDLE task stack size in bytes of this application.

## NOTES:

The IDLE task stack size is defined by the *[CONFIGURE\\_IDLE\\_TASK\\_STACK\\_SIZE](#page-738-0)* (page 711) application configuration option.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

27.24. Directives 751

<span id="page-779-1"></span><span id="page-779-0"></span>27.24.7 rtems\_configuration\_get\_idle\_task()

Gets the IDLE task body of this application.

#### CALLING SEQUENCE:

```
1 void *( * )( uintptr_t ) rtems_configuration_get_idle_task( void );
```

### RETURN VALUES:

Returns the IDLE task body of this application.

## NOTES:

The IDLE task body is defined by the *[CONFIGURE\\_IDLE\\_TASK\\_BODY](#page-736-0)* (page 709) application configuration option.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

<span id="page-780-1"></span><span id="page-780-0"></span>27.24.8 rtems\_configuration\_get\_interrupt\_stack\_size()

Gets the interrupt stack size in bytes of this application.

#### CALLING SEQUENCE:

```
1 size_t rtems_configuration_get_interrupt_stack_size( void );
```

#### RETURN VALUES:

Returns the interrupt stack size in bytes of this application.

## NOTES:

The interrupt stack size is defined by the *[CONFIGURE\\_INTERRUPT\\_STACK\\_SIZE](#page-603-0)* (page 576) application configuration option.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

27.24. Directives 753

## <span id="page-781-1"></span><span id="page-781-0"></span>27.24.9 rtems\_configuration\_get\_maximum\_barriers()

Gets the resource number of *[Barrier Manager](#page-382-0)* (page 355) objects configured for this application.

## CALLING SEQUENCE:

```
1 uint32_t rtems_configuration_get_maximum_barriers( void );
```

### RETURN VALUES:

Returns the resource number of *[Barrier Manager](#page-382-0)* (page 355) objects configured for this application.

#### NOTES:

The resource number is defined by the *[CONFIGURE\\_MAXIMUM\\_BARRIERS](#page-643-0)* (page 616) application configuration option. See also *[rtems\\_resource\\_is\\_unlimited\(\)](#page-808-0)* (page 781) and *[rtems\\_resource\\_maximum\\_per\\_allocation\(\)](#page-809-0)* (page 782).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-782-1"></span><span id="page-782-0"></span>27.24.10 rtems\_configuration\_get\_maximum\_extensions()

Gets the resource number of *[User Extensions Manager](#page-570-0)* (page 543) objects configured for this application.

#### CALLING SEQUENCE:

```
1 uint32_t rtems_configuration_get_maximum_extensions( void );
```

#### RETURN VALUES:

Returns the resource number of *[User Extensions Manager](#page-570-0)* (page 543) objects configured for this application.

#### NOTES:

The resource number is defined by the *[CONFIGURE\\_MAXIMUM\\_USER\\_EXTENSIONS](#page-652-0)* (page 625) application configuration option. See also *[rtems\\_resource\\_is\\_unlimited\(\)](#page-808-0)* (page 781) and *[rtems\\_resource\\_maximum\\_per\\_allocation\(\)](#page-809-0)* (page 782).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

27.24. Directives 755

<span id="page-783-1"></span><span id="page-783-0"></span>27.24.11 rtems\_configuration\_get\_maximum\_message\_queues()

Gets the resource number of *[Message Manager](#page-394-0)* (page 367) objects configured for this application.

### CALLING SEQUENCE:

```
1 uint32_t rtems_configuration_get_maximum_message_queues( void );
```

#### RETURN VALUES:

Returns the resource number of *[Message Manager](#page-394-0)* (page 367) objects configured for this application.

#### NOTES:

The resource number is defined by the *[CONFIGURE\\_MAXIMUM\\_MESSAGE\\_QUEUES](#page-644-0)* (page 617) application configuration option. See also *[rtems\\_resource\\_is\\_unlimited\(\)](#page-808-0)* (page 781) and *[rtems\\_resource\\_maximum\\_per\\_allocation\(\)](#page-809-0)* (page 782).

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-784-1"></span><span id="page-784-0"></span>27.24.12 rtems\_configuration\_get\_maximum\_partitions()

Gets the resource number of *[Partition Manager](#page-444-0)* (page 417) objects configured for this application.

#### CALLING SEQUENCE:

```
1 uint32_t rtems_configuration_get_maximum_partitions( void );
```

#### RETURN VALUES:

Returns the resource number of *[Partition Manager](#page-444-0)* (page 417) objects configured for this application.

#### NOTES:

The resource number is defined by the *[CONFIGURE\\_MAXIMUM\\_PARTITIONS](#page-645-0)* (page 618) application configuration option. See also *[rtems\\_resource\\_is\\_unlimited\(\)](#page-808-0)* (page 781) and *[rtems\\_resource\\_maximum\\_per\\_allocation\(\)](#page-809-0)* (page 782).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

27.24. Directives 757

## <span id="page-785-1"></span><span id="page-785-0"></span>27.24.13 rtems\_configuration\_get\_maximum\_periods()

Gets the resource number of *[Rate Monotonic Manager](#page-326-0)* (page 299) objects configured for this application.

#### CALLING SEQUENCE:

```
1 uint32_t rtems_configuration_get_maximum_periods( void );
```

#### RETURN VALUES:

Returns the resource number of *[Rate Monotonic Manager](#page-326-0)* (page 299) objects configured for this application.

#### NOTES:

The resource number is defined by the *[CONFIGURE\\_MAXIMUM\\_PERIODS](#page-646-0)* (page 619) application configuration option. See also *[rtems\\_resource\\_is\\_unlimited\(\)](#page-808-0)* (page 781) and *[rtems\\_resource\\_maximum\\_per\\_allocation\(\)](#page-809-0)* (page 782).

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-786-1"></span><span id="page-786-0"></span>27.24.14 rtems\_configuration\_get\_maximum\_ports()

Gets the resource number of *[Dual-Ported Memory Manager](#page-484-0)* (page 457) objects configured for this application.

#### CALLING SEQUENCE:

```
1 uint32_t rtems_configuration_get_maximum_ports( void );
```

#### RETURN VALUES:

Returns the resource number of *[Dual-Ported Memory Manager](#page-484-0)* (page 457) objects configured for this application.

#### NOTES:

The resource number is defined by the *[CONFIGURE\\_MAXIMUM\\_PORTS](#page-647-0)* (page 620) application configuration option. See also *[rtems\\_resource\\_is\\_unlimited\(\)](#page-808-0)* (page 781) and *[rtems\\_resource\\_maximum\\_per\\_allocation\(\)](#page-809-0)* (page 782).

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

27.24. Directives 759

<span id="page-787-1"></span><span id="page-787-0"></span>27.24.15 rtems\_configuration\_get\_maximum\_processors()

Gets the maximum number of processors configured for this application.

## CALLING SEQUENCE:

```
1 uint32_t rtems_configuration_get_maximum_processors( void );
```

### RETURN VALUES:

Returns the maximum number of processors configured for this application.

## NOTES:

The actual number of processors available to the application is returned by *[rtems\\_scheduler\\_get\\_processor\\_maximum\(\)](#page-107-0)* (page 80) which less than or equal to the configured maximum number of processors (*[CONFIGURE\\_MAXIMUM\\_PROCESSORS](#page-606-0)* (page 579)).

In uniprocessor configurations, this macro is a compile time constant which evaluates to one.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-788-1"></span><span id="page-788-0"></span>27.24.16 rtems\_configuration\_get\_maximum\_regions()

Gets the resource number of *[Region Manager](#page-460-0)* (page 433) objects configured for this application.

#### CALLING SEQUENCE:

```
1 uint32_t rtems_configuration_get_maximum_regions( void );
```

### RETURN VALUES:

Returns the resource number of *[Region Manager](#page-460-0)* (page 433) objects configured for this application.

#### NOTES:

The resource number is defined by the *[CONFIGURE\\_MAXIMUM\\_REGIONS](#page-648-0)* (page 621) application configuration option. See also *[rtems\\_resource\\_is\\_unlimited\(\)](#page-808-0)* (page 781) and *[rtems\\_resource\\_maximum\\_per\\_allocation\(\)](#page-809-0)* (page 782).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

27.24. Directives 761

## <span id="page-789-1"></span><span id="page-789-0"></span>27.24.17 rtems\_configuration\_get\_maximum\_semaphores()

Gets the resource number of *[Semaphore Manager](#page-354-0)* (page 327) objects configured for this application.

### CALLING SEQUENCE:

```
1 uint32_t rtems_configuration_get_maximum_semaphores( void );
```

#### RETURN VALUES:

Returns the resource number of *[Semaphore Manager](#page-354-0)* (page 327) objects configured for this application.

#### NOTES:

The resource number is defined by the *[CONFIGURE\\_MAXIMUM\\_SEMAPHORES](#page-649-0)* (page 622) application configuration option. See also *[rtems\\_resource\\_is\\_unlimited\(\)](#page-808-0)* (page 781) and *[rtems\\_resource\\_maximum\\_per\\_allocation\(\)](#page-809-0)* (page 782).

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-790-1"></span><span id="page-790-0"></span>27.24.18 rtems\_configuration\_get\_maximum\_tasks()

Gets the resource number of *[Task Manager](#page-124-0)* (page 97) objects configured for this application.

#### CALLING SEQUENCE:

```
1 uint32_t rtems_configuration_get_maximum_tasks( void );
```

### RETURN VALUES:

Returns the resource number of *[Task Manager](#page-124-0)* (page 97) objects configured for this application.

#### NOTES:

The resource number is defined by the *[CONFIGURE\\_MAXIMUM\\_TASKS](#page-650-0)* (page 623) application configuration option. See also *[rtems\\_resource\\_is\\_unlimited\(\)](#page-808-0)* (page 781) and *[rtems\\_resource\\_maximum\\_per\\_allocation\(\)](#page-809-0)* (page 782).

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

27.24. Directives 763

## <span id="page-791-1"></span><span id="page-791-0"></span>27.24.19 rtems\_configuration\_get\_maximum\_timers()

Gets the resource number of *[Timer Manager](#page-302-0)* (page 275) objects configured for this application.

## CALLING SEQUENCE:

```
1 uint32_t rtems_configuration_get_maximum_timers( void );
```

#### RETURN VALUES:

Returns the resource number of *[Timer Manager](#page-302-0)* (page 275) objects configured for this application.

#### NOTES:

The resource number is defined by the *[CONFIGURE\\_MAXIMUM\\_TIMERS](#page-651-0)* (page 624) application configuration option. See also *[rtems\\_resource\\_is\\_unlimited\(\)](#page-808-0)* (page 781) and *[rtems\\_resource\\_maximum\\_per\\_allocation\(\)](#page-809-0)* (page 782).

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

<span id="page-792-1"></span><span id="page-792-0"></span>27.24.20 rtems\_configuration\_get\_microseconds\_per\_tick()

Gets the number of microseconds per clock tick configured for this application.

## CALLING SEQUENCE:

```
1 uint32_t rtems_configuration_get_microseconds_per_tick( void );
```

#### RETURN VALUES:

Returns the number of microseconds per clock tick configured for this application.

## NOTES:

The number of microseconds per *[clock tick](#page-1062-1)* is defined by the *[CONFIG-](#page-612-0)[URE\\_MICROSECONDS\\_PER\\_TICK](#page-612-0)* (page 585) application configuration option.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

27.24. Directives 765

<span id="page-793-1"></span><span id="page-793-0"></span>27.24.21 rtems\_configuration\_get\_milliseconds\_per\_tick()

Gets the number of milliseconds per clock tick configured for this application.

## CALLING SEQUENCE:

```
1 uint32_t rtems_configuration_get_milliseconds_per_tick( void );
```

#### RETURN VALUES:

Returns the number of milliseconds per clock tick configured for this application.

## NOTES:

The number of milliseconds per *[clock tick](#page-1062-1)* is defined by the *[CONFIG-](#page-612-0)[URE\\_MICROSECONDS\\_PER\\_TICK](#page-612-0)* (page 585) application configuration option.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

<span id="page-794-1"></span><span id="page-794-0"></span>27.24.22 rtems\_configuration\_get\_nanoseconds\_per\_tick()

Gets the number of microseconds per clock tick configured for this application.

## CALLING SEQUENCE:

```
1 uint32_t rtems_configuration_get_nanoseconds_per_tick( void );
```

#### RETURN VALUES:

Returns the number of microseconds per clock tick configured for this application.

## NOTES:

The number of nanoseconds per *[clock tick](#page-1062-1)* is defined by the *[CONFIG-](#page-612-0)[URE\\_MICROSECONDS\\_PER\\_TICK](#page-612-0)* (page 585) application configuration option.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

27.24. Directives 767

<span id="page-795-1"></span><span id="page-795-0"></span>27.24.23 rtems\_configuration\_get\_number\_of\_initial\_extensions() Gets the number of initial extensions configured for this application.

## CALLING SEQUENCE:

```
1 uint32_t rtems_configuration_get_number_of_initial_extensions( void );
```

### RETURN VALUES:

Returns the number of initial extensions configured for this application.

## NOTES:

The number of initial extensions is defined by the *[CONFIGURE\\_INITIAL\\_EXTENSIONS](#page-602-0)* (page 575) application configuration option and related options.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-796-1"></span><span id="page-796-0"></span>27.24.24 rtems\_configuration\_get\_stack\_allocate\_for\_idle\_hook()

Gets the task stack allocator allocate hook used to allocate the stack of each *[IDLE task](#page-1067-2)* configured for this application.

#### CALLING SEQUENCE:

```
1 void *( * )( uint32_t, size_t * )
2 rtems_configuration_get_stack_allocate_for_idle_hook( void );
```

#### RETURN VALUES:

Returns the task stack allocator allocate hook used to allocate the stack of each *[IDLE task](#page-1067-2)* configured for this application.

#### NOTES:

The task stack allocator allocate hook for idle tasks is defined by the *[CONFIG-](#page-731-0)[URE\\_TASK\\_STACK\\_ALLOCATOR\\_FOR\\_IDLE](#page-731-0)* (page 704) application configuration option.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

27.24. Directives 769

<span id="page-797-1"></span><span id="page-797-0"></span>27.24.25 rtems\_configuration\_get\_stack\_allocate\_hook()

Gets the task stack allocator allocate hook configured for this application.

## CALLING SEQUENCE:

```
1 void *( * )( size_t ) rtems_configuration_get_stack_allocate_hook( void );
```

#### RETURN VALUES:

Returns the task stack allocator allocate hook configured for this application.

## NOTES:

The task stack allocator allocate hook is defined by the *[CONFIGURE\\_TASK\\_STACK\\_ALLOCATOR](#page-729-0)* (page 702) application configuration option.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

<span id="page-798-1"></span><span id="page-798-0"></span>27.24.26 rtems\_configuration\_get\_stack\_allocate\_init\_hook()

Gets the task stack allocator initialization hook configured for this application.

## CALLING SEQUENCE:

```
1 void ( * )( size_t ) rtems_configuration_get_stack_allocate_init_hook( void );
```

### RETURN VALUES:

Returns the task stack allocator initialization hook configured for this application.

## NOTES:

The task stack allocator initialization hook is defined by the *[CONFIG-](#page-732-0)[URE\\_TASK\\_STACK\\_ALLOCATOR\\_INIT](#page-732-0)* (page 705) application configuration option.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

27.24. Directives 771

<span id="page-799-1"></span><span id="page-799-0"></span>27.24.27 rtems\_configuration\_get\_stack\_allocator\_avoids\_work\_space()

Indicates if the task stack allocator is configured to avoid the RTEMS Workspace for this application.

#### CALLING SEQUENCE:

```
1 bool rtems_configuration_get_stack_allocator_avoids_work_space( void );
```

#### RETURN VALUES:

Returns true, if the task stack allocator is configured to avoid the RTEMS Workspace for this application, otherwise false.

#### NOTES:

The setting is defined by the *[CONFIGURE\\_TASK\\_STACK\\_ALLOCATOR\\_AVOIDS\\_WORK\\_SPACE](#page-730-0)* (page 703) application configuration option.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

<span id="page-800-1"></span><span id="page-800-0"></span>27.24.28 rtems\_configuration\_get\_stack\_free\_hook()

Gets the task stack allocator free hook configured for this application.

#### CALLING SEQUENCE:

```
1 void ( * )( void * ) rtems_configuration_get_stack_free_hook( void );
```

#### RETURN VALUES:

Returns the task stack allocator free hook configured for this application.

## NOTES:

The task stack allocator free hook is defined by the *[CONFIGURE\\_TASK\\_STACK\\_DEALLOCATOR](#page-733-0)* (page 706) application configuration option.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

27.24. Directives 773

<span id="page-801-1"></span><span id="page-801-0"></span>27.24.29 rtems\_configuration\_get\_stack\_space\_size()

Gets the configured size in bytes of the memory space used to allocate thread stacks for this application.

#### CALLING SEQUENCE:

```
1 uintptr_t rtems_configuration_get_stack_space_size( void );
```

#### RETURN VALUES:

Returns the configured size in bytes of the memory space used to allocate thread stacks for this application.

#### NOTES:

The size takes only threads and tasks into account with are known at the application configuration time.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

<span id="page-802-1"></span><span id="page-802-0"></span>27.24.30 rtems\_configuration\_get\_ticks\_per\_timeslice()

Gets the clock ticks per timeslice configured for this application.

## CALLING SEQUENCE:

```
1 uint32_t rtems_configuration_get_ticks_per_timeslice( void );
```

#### RETURN VALUES:

Returns the clock ticks per timeslice configured for this application.

## NOTES:

The *[clock ticks](#page-1062-1)* per timeslice is defined by the *[CONFIGURE\\_TICKS\\_PER\\_TIMESLICE](#page-615-0)* (page 588) application configuration option.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

27.24. Directives 775

## <span id="page-803-1"></span><span id="page-803-0"></span>27.24.31 rtems\_configuration\_get\_unified\_work\_area()

Indicates if the RTEMS Workspace and C Program Heap are configured to be unified for this application.

## CALLING SEQUENCE:

```
1 bool rtems_configuration_get_unified_work_area( void );
```

#### RETURN VALUES:

Returns true, if the RTEMS Workspace and C Program Heap are configured to be unified for this application, otherwise false.

#### NOTES:

The setting is defined by the *[CONFIGURE\\_UNIFIED\\_WORK\\_AREAS](#page-616-0)* (page 589) application configuration option.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

<span id="page-804-1"></span><span id="page-804-0"></span>27.24.32 rtems\_configuration\_get\_user\_extension\_table()

Gets the initial extensions table configured for this application.

#### CALLING SEQUENCE:

```
1 const rtems_extensions_table *rtems_configuration_get_user_extension_table(
2 void
3 );
```

#### RETURN VALUES:

Returns a pointer to the initial extensions table configured for this application.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

27.24. Directives 777

<span id="page-805-1"></span><span id="page-805-0"></span>27.24.33 rtems\_configuration\_get\_user\_multiprocessing\_table() Gets the MPCI configuration table configured for this application.

#### CALLING SEQUENCE:

```
1 const MPCI_Configuration *rtems_configuration_get_user_multiprocessing_table(
2 void
3 );
```

#### RETURN VALUES:

Returns a pointer to the MPCI configuration table configured for this application.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

<span id="page-806-1"></span><span id="page-806-0"></span>27.24.34 rtems\_configuration\_get\_work\_space\_size()

Gets the RTEMS Workspace size in bytes configured for this application.

## CALLING SEQUENCE:

```
1 uintptr_t rtems_configuration_get_work_space_size( void );
```

### RETURN VALUES:

Returns the RTEMS Workspace size in bytes configured for this application.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

27.24. Directives 779

<span id="page-807-1"></span><span id="page-807-0"></span>27.24.35 rtems\_configuration\_get\_rtems\_api\_configuration() Gets the Classic API Configuration Table of this application.

#### CALLING SEQUENCE:

```
1 const rtems_api_configuration_table *
2 rtems_configuration_get_rtems_api_configuration( void );
```

#### RETURN VALUES:

Returns a pointer to the Classic API Configuration Table of this application.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

<span id="page-808-1"></span><span id="page-808-0"></span>27.24.36 rtems\_resource\_is\_unlimited()

Indicates if the resource is unlimited.

#### CALLING SEQUENCE:

```
1 bool rtems_resource_is_unlimited( uint32_t resource );
```

#### PARAMETERS:

#### **resource**

This parameter is the resource number.

#### RETURN VALUES:

Returns true, if the resource is unlimited, otherwise false.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive is implemented by a macro and may be called from within C/C++ constant expressions. In addition, a function implementation of the directive exists for bindings to other programming languages.
- The directive will not cause the calling task to be preempted.

27.24. Directives 781

<span id="page-809-1"></span><span id="page-809-0"></span>27.24.37 rtems\_resource\_maximum\_per\_allocation()

Gets the maximum number per allocation of a resource number.

## CALLING SEQUENCE:

```
1 uint32_t rtems_resource_maximum_per_allocation( uint32_t resource );
```

### PARAMETERS:

#### **resource**

This parameter is the resource number.

#### RETURN VALUES:

Returns the maximum number per allocation of a resource number.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive is implemented by a macro and may be called from within C/C++ constant expressions. In addition, a function implementation of the directive exists for bindings to other programming languages.
- The directive will not cause the calling task to be preempted.

## <span id="page-810-1"></span><span id="page-810-0"></span>27.24.38 rtems\_resource\_unlimited()

Augments the resource number so that it indicates an unlimited resource.

## CALLING SEQUENCE:

```
1 uint32_t rtems_resource_unlimited( uint32_t resource );
```

#### PARAMETERS:

#### **resource**

This parameter is the resource number to augment.

#### RETURN VALUES:

Returns the resource number augmented to indicate an unlimited resource.

#### NOTES:

This directive should be used to configure unlimited objects, see *[Unlimited Objects](#page-593-0)* (page 566).

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive is implemented by a macro and may be called from within C/C++ constant expressions. In addition, a function implementation of the directive exists for bindings to other programming languages.
- The directive will not cause the calling task to be preempted.

27.24. Directives 783

# <span id="page-811-12"></span><span id="page-811-0"></span>27.25 Obsolete Configuration Options

## <span id="page-811-1"></span>27.25.1 CONFIGURE\_BDBUF\_BUFFER\_COUNT

This configuration option was introduced in RTEMS 4.7.0 and is obsolete since RTEMS 4.10.0.

## <span id="page-811-2"></span>27.25.2 CONFIGURE\_BDBUF\_BUFFER\_SIZE

This configuration option was introduced in RTEMS 4.7.0 and is obsolete since RTEMS 4.10.0.

## <span id="page-811-3"></span>27.25.3 CONFIGURE\_DISABLE\_CLASSIC\_API\_NOTEPADS

This configuration option was introduced in RTEMS 4.9.0 and is obsolete since RTEMS 5.1.

## <span id="page-811-4"></span>27.25.4 CONFIGURE\_ENABLE\_GO

This configuration option is obsolete since RTEMS 5.1.

## <span id="page-811-5"></span>27.25.5 CONFIGURE\_GNAT\_RTEMS

This configuration option was present in all RTEMS versions since 1997 and is obsolete since RTEMS 5.1. See also *[Ada Configuration](#page-771-0)* (page 744).

## <span id="page-811-6"></span>27.25.6 CONFIGURE\_HAS\_OWN\_CONFIGURATION\_TABLE

This configuration option is obsolete since RTEMS 5.1.

## <span id="page-811-7"></span>27.25.7 CONFIGURE\_HAS\_OWN\_BDBUF\_TABLE

This configuration option was introduced in RTEMS 4.7.0 and is obsolete since RTEMS 4.10.0.

## <span id="page-811-8"></span>27.25.8 CONFIGURE\_HAS\_OWN\_DEVICE\_DRIVER\_TABLE

This configuration option was present in all RTEMS versions since at least 1995 and is obsolete since RTEMS 5.1.

## <span id="page-811-9"></span>27.25.9 CONFIGURE\_HAS\_OWN\_INIT\_TASK\_TABLE

This configuration option was present in all RTEMS versions since at least 1995 and is obsolete since RTEMS 5.1. If you used this configuration option or you think that there should be a way to configure more than one Classic API initialization task, then please ask on the [Users Mailing](https://lists.rtems.org/mailman/listinfo/users/) [List.](https://lists.rtems.org/mailman/listinfo/users/)

## <span id="page-811-10"></span>27.25.10 CONFIGURE\_HAS\_OWN\_MOUNT\_TABLE

This configuration option is obsolete since RTEMS 5.1.

## <span id="page-811-11"></span>27.25.11 CONFIGURE\_HAS\_OWN\_MULTIPROCESSING\_TABLE

This configuration option is obsolete since RTEMS 5.1.

## <span id="page-812-12"></span><span id="page-812-0"></span>27.25.12 CONFIGURE\_LIBIO\_MAXIMUM\_FILE\_DESCRIPTORS

This configuration option was present in all RTEMS versions since 1998 and is obsolete since RTEMS 5.1. See also *[CONFIGURE\\_MAXIMUM\\_FILE\\_DESCRIPTORS](#page-605-0)* (page 578).

## <span id="page-812-1"></span>27.25.13 CONFIGURE\_MAXIMUM\_ADA\_TASKS

This configuration option was present in all RTEMS versions since 1997 and is obsolete since RTEMS 5.1. See also *[Ada Configuration](#page-771-0)* (page 744).

## <span id="page-812-2"></span>27.25.14 CONFIGURE\_MAXIMUM\_DEVICES

This configuration option was present in all RTEMS versions since at least 1995 and is obsolete since RTEMS 5.1.

## <span id="page-812-3"></span>27.25.15 CONFIGURE\_MAXIMUM\_FAKE\_ADA\_TASKS

This configuration option was present in all RTEMS versions since 1997 and is obsolete since RTEMS 5.1. See also *[Ada Configuration](#page-771-0)* (page 744).

## <span id="page-812-4"></span>27.25.16 CONFIGURE\_MAXIMUM\_GO\_CHANNELS

This configuration option is obsolete since RTEMS 5.1.

## <span id="page-812-5"></span>27.25.17 CONFIGURE\_MAXIMUM\_GOROUTINES

This configuration option is obsolete since RTEMS 5.1.

## <span id="page-812-6"></span>27.25.18 CONFIGURE\_MAXIMUM\_MRSP\_SEMAPHORES

This configuration option is obsolete since RTEMS 5.1.

## <span id="page-812-7"></span>27.25.19 CONFIGURE\_NUMBER\_OF\_TERMIOS\_PORTS

This configuration option is obsolete since RTEMS 5.1.

## <span id="page-812-8"></span>27.25.20 CONFIGURE\_MAXIMUM\_POSIX\_BARRIERS

This configuration option is obsolete since RTEMS 5.1.

## <span id="page-812-9"></span>27.25.21 CONFIGURE\_MAXIMUM\_POSIX\_CONDITION\_VARIABLES

This configuration option is obsolete since RTEMS 5.1.

## <span id="page-812-10"></span>27.25.22 CONFIGURE\_MAXIMUM\_POSIX\_MESSAGE\_QUEUE\_DESCRIPTORS

This configuration option was introduced in RTEMS 4.10.0 and is obsolete since RTEMS 5.1.

## <span id="page-812-11"></span>27.25.23 CONFIGURE\_MAXIMUM\_POSIX\_MUTEXES

This configuration option is obsolete since RTEMS 5.1.

## <span id="page-813-6"></span><span id="page-813-0"></span>27.25.24 CONFIGURE\_MAXIMUM\_POSIX\_RWLOCKS

This configuration option is obsolete since RTEMS 5.1.

## <span id="page-813-1"></span>27.25.25 CONFIGURE\_MAXIMUM\_POSIX\_SPINLOCKS

This configuration option is obsolete since RTEMS 5.1.

## <span id="page-813-2"></span>27.25.26 CONFIGURE\_POSIX\_HAS\_OWN\_INIT\_THREAD\_TABLE

This configuration option was present in all RTEMS versions since at least 1995 and is obsolete since RTEMS 5.1. If you used this configuration option or you think that there should be a way to configure more than one POSIX initialization thread, then please ask on the [Users Mailing](https://lists.rtems.org/mailman/listinfo/users/) [List.](https://lists.rtems.org/mailman/listinfo/users/)

## <span id="page-813-3"></span>27.25.27 CONFIGURE\_SMP\_APPLICATION

This configuration option was introduced in RTEMS 4.11.0 and is obsolete since RTEMS 5.1.

## <span id="page-813-4"></span>27.25.28 CONFIGURE\_SMP\_MAXIMUM\_PROCESSORS

This configuration option was introduced in RTEMS 4.11.0 and is obsolete since RTEMS 5.1. See also *[CONFIGURE\\_MAXIMUM\\_PROCESSORS](#page-606-0)* (page 579).

## <span id="page-813-5"></span>27.25.29 CONFIGURE\_TERMIOS\_DISABLED

This configuration option is obsolete since RTEMS 5.1.

CHAPTER

# **TWENTYEIGHT**

# <span id="page-814-0"></span>SELF-CONTAINED OBJECTS

# <span id="page-815-0"></span>28.1 Introduction

One of the original design goals of RTEMS was the support for heterogeneous computing based on message passing. This was realized by synchronization objects with an architectureindependent identifier provided by the system during object creation (a 32-bit unsigned integer used as a bitfield) and a user-defined four character name. This approach in the so called Classic API has some weaknesses:

- Dynamic memory (the workspace) is used to allocate object pools. This requires a complex configuration with heavy use of the C pre-processor. The unlimited objects support optionally expands and shrinks the object pool. Dynamic memory is strongly discouraged by some coding standards, e.g. MISRA C:2012 [\[BBB+13\]](#page-1082-6).
- Objects are created via function calls which return an object identifier. The object operations use this identifier and map it internally to an object representation.
- The object identifier is only known at run-time. This hinders compiler optimizations and static analysis.
- The objects reside in a table, e.g. they are subject to false sharing of cache lines [\[Dre07\]](#page-1083-8).
- The object operations use a rich set of options and attributes. For each object operation these parameters must be evaluated and validated at run-time to figure out what to do exactly for this operation.

For applications that use fine grained locking the mapping of the identifier to the object representation and the parameter evaluation are a significant overhead that may degrade the performance dramatically. An example is the [new network stack \(libbsd\)](https://gitlab.rtems.org/rtems/pkg/rtems-libbsd) which uses hundreds of locks in a basic setup. Another example is the OpenMP support (libgomp).

To overcome these issues new self-contained synchronization objects are available since RTEMS 4.11. Self-contained synchronization objects encapsulate all their state in exactly one data structure. The user must provide the storage space for this structure and nothing more. The user is responsible for the object life-cycle. Initialization and destruction of self-contained synchronization objects cannot fail provided all function parameters are valid. In particular, a not enough memory error cannot happen. It is possible to statically initialize self-contained synchronization objects. This allows an efficient use of static analysis tools.

Several header files define self-contained synchronization objects. The Newlib <sys/lock.h> header file provides

- mutexes,
- recursive mutexes,
- condition variables,
- counting semaphores,
- binary semaphores, and
- Futex synchronization [\[FRK02\]](#page-1083-9).

They are used internally in Newlib (e.g. for FILE objects), for the C++11 threads and the OpenMP support (libgomp). The Newlib provided self-contained synchronization objects focus on performance. There are no error checks to catch software errors, e.g. invalid parameters. The application configuration is significantly simplified, since it is no longer necessary to account for lock objects used by Newlib and GCC. The Newlib defined self-contained synchronization objects can be a statically initialized and reside in the .bss section. Destruction is a no-operation.

The header file <pthread.h> provides

- POSIX barriers (pthread\_barrier\_t),
- POSIX condition variables (pthread\_cond\_t),
- POSIX mutexes (pthread\_mutex\_t),
- POSIX reader/writer locks (pthread\_rwlock\_t), and
- POSIX spinlocks (pthread\_spinlock\_t)

as self-contained synchronization objects. The POSIX synchronization objects are used for example by the Ada run-time support. The header file <semaphore.h> provides self-contained

â€¢ POSIX unnamed semaphores (sem\_t initialized via sem\_init()).

28.1. Introduction 789

# <span id="page-817-0"></span>28.2 RTEMS Thread API

To give RTEMS users access to self-contained synchronization objects an API is necessary. One option would be to simply use the POSIX threads API (pthreads), C11 threads or C++11 threads. However, these standard APIs lack for example binary semaphores which are important for task/interrupt synchronization. The timed operations use in general time values specified by seconds and nanoseconds. Setting up the time values in seconds (time\_t has 64 bits) and nanoseconds is burdened with a high overhead compared to time values in clock ticks for relative timeouts. The POSIX API mutexes can be configured for various protocols and options, this adds a run-time overhead. There are a variety of error conditions. This is a problem in combination with some coding standards, e.g. MISRA C:2012. APIs used by Linux (e.g. [<linux/mutex.h>\)](http://lxr.free-electrons.com/source/include/linux/mutex.h) or the FreeBSD kernel (e.g. [MUTEX\(9\)\)](https://www.freebsd.org/cgi/man.cgi?query=mutex&sektion=9) are better suited as a template for high-performance synchronization objects. The goal of the RTEMS Thread API is to offer the highest performance with the lowest space-overhead on RTEMS. It should be suitable for device drivers.

# <span id="page-818-0"></span>28.3 Mutual Exclusion

The rtems\_mutex and rtems\_recursive\_mutex objects provide mutual-exclusion synchronization using the *[Priority Inheritance Protocol](#page-56-3)* (page 29) in uniprocessor configurations or the *[O\(m\)](#page-57-1) [Independence-Preserving Protocol \(OMIP\)](#page-57-1)* (page 30) in SMP configurations. Recursive locking should be used with care [\[Wil12\]](#page-1084-2). The storage space for these object must be provided by the user. There are no defined comparison or assignment operators for these type. Only the object itself may be used for performing synchronization. The result of referring to copies of the object in calls to

- rtems\_mutex\_lock(),
- rtems\_recursive\_mutex\_lock(),
- rtems\_mutex\_try\_lock(),
- rtems\_recursive\_mutex\_try\_lock(),
- rtems\_mutex\_unlock(),
- rtems\_recursive\_mutex\_unlock(),
- rtems\_mutex\_set\_name(),
- rtems\_recursive\_mutex\_set\_name(),
- rtems\_mutex\_get\_name(),
- rtems\_recursive\_mutex\_get\_name(),
- rtems\_mutex\_destroy(), and
- rtems\_recursive\_mutex\_destroy()

is undefined. Objects of the type rtems\_mutex must be initialized via

- RTEMS\_MUTEX\_INITIALIZER(), or
- rtems\_mutex\_init().

They must be destroyed via

â€¢ rtems\_mutex\_destroy().

Objects of the type rtems\_recursive\_mutex must be initialized via

- RTEMS\_RECURSIVE\_MUTEX\_INITIALIZER(), or
- rtems\_recursive\_mutex\_init().

They must be destroyed via

â€¢ rtems\_recursive\_mutex\_destroy().

## <span id="page-819-0"></span>28.3.1 Static mutex initialization

#### **CALLING SEQUENCE:**

```
1 rtems_mutex mutex = RTEMS_MUTEX_INITIALIZER(
2 name
3 );
4
5 rtems_recursive_mutex mutex = RTEMS_RECURSIVE_MUTEX_INITIALIZER(
6 name
7 );
```

#### **DESCRIPTION:**

An initializer for static initialization. It is equivalent to a call to rtems\_mutex\_init() or rtems\_recursive\_mutex\_init() respectively.

#### **NOTES:**

Global mutexes with a name of NULL may reside in the .bss section.

## <span id="page-820-0"></span>28.3.2 Run-time mutex initialization

#### **CALLING SEQUENCE:**

```
1 void rtems_mutex_init(
2 rtems_mutex *mutex,
3 const char *name
4 );
5
6 void rtems_recursive_mutex_init(
7 rtems_recursive_mutex *mutex,
8 const char *name
9 );
```

#### **DESCRIPTION:**

Initializes the mutex with the specified name.

#### **NOTES:**

The name must be persistent throughout the life-time of the mutex. A name of NULL is valid. The mutex is unlocked after initialization.

## <span id="page-821-0"></span>28.3.3 Lock the mutex

#### **CALLING SEQUENCE:**

```
1 void rtems_mutex_lock(
2 rtems_mutex *mutex
3 );
4
5 void rtems_recursive_mutex_lock(
6 rtems_recursive_mutex *mutex
7 );
```

## **DESCRIPTION:**

Locks the mutex.

#### **NOTES:**

This function must be called from thread context with interrupts enabled. In case the mutex is currently locked by another thread, then the thread is blocked until it becomes the mutex owner. Threads wait in priority order.

A recursive lock happens in case the mutex owner tries to lock the mutex again. The result of recursively locking a mutex depends on the mutex variant. For a normal (non-recursive) mutex (rtems\_mutex) the result is unpredictable. It could block the owner indefinetly or lead to a fatal deadlock error. A recursive mutex (rtems\_recursive\_mutex) can be locked recursively by the mutex owner.

Each mutex lock operation must have a corresponding unlock operation.

## <span id="page-822-0"></span>28.3.4 Try to lock the mutex

#### **CALLING SEQUENCE:**

```
1 int rtems_mutex_try_lock(
2 rtems_mutex *mutex
3 );
4
5 int rtems_recursive_mutex_try_lock(
6 rtems_recursive_mutex *mutex
7 );
```

#### **DESCRIPTION:**

Tries to lock the mutex. In case the mutex is not locked, it will be locked and the function returns with a return value of 0. If the mutex is already locked, the function will return with a value of EBUSY.

#### **NOTES:**

This function must be called from thread context with interrupts enabled.

For recursively locking a mutex, please also see the notes for rtems\_mutex\_lock() and rtems\_recursive\_mutex\_lock().

Each mutex lock operation must have a corresponding unlock operation.

28.3. Mutual Exclusion 795

## <span id="page-823-0"></span>28.3.5 Unlock the mutex

#### **CALLING SEQUENCE:**

```
1 void rtems_mutex_unlock(
2 rtems_mutex *mutex
3 );
4
5 void rtems_recursive_mutex_unlock(
6 rtems_recursive_mutex *mutex
7 );
```

#### **DESCRIPTION:**

Unlocks the mutex.

#### **NOTES:**

This function must be called from thread context with interrupts enabled. In case the currently executing thread is not the owner of the mutex, then the result is unpredictable.

Exactly the outer-most unlock will make a recursive mutex available to other threads.

## <span id="page-824-0"></span>28.3.6 Set mutex name

#### **CALLING SEQUENCE:**

```
1 void rtems_mutex_set_name(
2 rtems_mutex *mutex,
3 const char *name
4 );
5
6 void rtems_recursive_mutex_set_name(
7 rtems_recursive_mutex *mutex,
8 const char *name
9 );
```

#### **DESCRIPTION:**

Sets the mutex name to name.

#### **NOTES:**

The name must be persistent throughout the life-time of the mutex. A name of NULL is valid.

## <span id="page-825-0"></span>28.3.7 Get mutex name

#### **CALLING SEQUENCE:**

```
1 const char *rtems_mutex_get_name(
2 const rtems_mutex *mutex
3 );
4
5 const char *rtems_recursive_mutex_get_name(
6 const rtems_recursive_mutex *mutex
7 );
```

#### **DESCRIPTION:**

Returns the mutex name.

## **NOTES:**

The name may be NULL.

## <span id="page-825-1"></span>28.3.8 Mutex destruction

#### **CALLING SEQUENCE:**

```
1 void rtems_mutex_destroy(
2 rtems_mutex *mutex
3 );
4
5 void rtems_recursive_mutex_destroy(
6 rtems_recursive_mutex *mutex
7 );
```

## **DESCRIPTION:**

Destroys the mutex.

#### **NOTES:**

In case the mutex is locked or still in use, then the result is unpredictable.

# <span id="page-826-0"></span>28.4 Condition Variables

The rtems\_condition\_variable object provides a condition variable synchronization object. The storage space for this object must be provided by the user. There are no defined comparison or assignment operators for this type. Only the object itself may be used for performing synchronization. The result of referring to copies of the object in calls to

- rtems\_condition\_variable\_wait(),
- rtems\_condition\_variable\_signal(),
- rtems\_condition\_variable\_broadcast(),
- rtems\_condition\_variable\_set\_name(),
- rtems\_condition\_variable\_get\_name(), and
- rtems\_condition\_variable\_destroy()

is undefined. Objects of this type must be initialized via

- RTEMS\_CONDITION\_VARIABLE\_INITIALIZER(), or
- rtems\_condition\_variable\_init().

They must be destroyed via

â€¢ rtems\_condition\_variable\_destroy().

## <span id="page-827-0"></span>28.4.1 Static condition variable initialization

#### **CALLING SEQUENCE:**

```
1 rtems_condition_variable condition_variable = RTEMS_CONDITION_VARIABLE_
  Ë“â†’INITIALIZER(
2 name
3 );
```

## **DESCRIPTION:**

An initializer for static initialization. It is equivalent to a call to rtems\_condition\_variable\_init().

#### **NOTES:**

Global condition variables with a name of NULL may reside in the .bss section.

## <span id="page-828-0"></span>28.4.2 Run-time condition variable initialization

#### **CALLING SEQUENCE:**

```
1 void rtems_condition_variable_init(
2 rtems_condition_variable *condition_variable,
3 const char *name
4 );
```

## **DESCRIPTION:**

Initializes the condition\_variable with the specified name.

#### **NOTES:**

The name must be persistent throughout the life-time of the condition variable. A name of NULL is valid.

## <span id="page-829-0"></span>28.4.3 Wait for condition signal

#### **CALLING SEQUENCE:**

```
1 void rtems_condition_variable_wait(
2 rtems_condition_variable *condition_variable,
3 rtems_mutex *mutex
4 );
```

## **DESCRIPTION:**

Atomically waits for a condition signal and unlocks the mutex. Once the condition is signalled to the thread it wakes up and locks the mutex again.

#### **NOTES:**

This function must be called from thread context with interrupts enabled. Threads wait in priority order.

## <span id="page-830-0"></span>28.4.4 Signals a condition change

#### **CALLING SEQUENCE:**

```
1 void rtems_condition_variable_signal(
2 rtems_condition_variable *condition_variable
3 );
```

#### **DESCRIPTION:**

Signals a condition change to the highest priority waiting thread. If no threads wait currently on this condition variable, then nothing happens.

## <span id="page-831-0"></span>28.4.5 Broadcasts a condition change

#### **CALLING SEQUENCE:**

```
1 void rtems_condition_variable_broadcast(
2 rtems_condition_variable *condition_variable
3 );
```

#### **DESCRIPTION:**

Signals a condition change to all waiting thread. If no threads wait currently on this condition variable, then nothing happens.

## <span id="page-832-0"></span>28.4.6 Set condition variable name

#### **CALLING SEQUENCE:**

```
1 void rtems_condition_variable_set_name(
2 rtems_condition_variable *condition_variable,
3 const char *name
4 );
```

## **DESCRIPTION:**

Sets the condition\_variable name to name.

## **NOTES:**

The name must be persistent throughout the life-time of the condition variable. A name of NULL is valid.

## <span id="page-833-0"></span>28.4.7 Get condition variable name

#### **CALLING SEQUENCE:**

```
1 const char *rtems_condition_variable_get_name(
2 const rtems_condition_variable *condition_variable
3 );
```

#### **DESCRIPTION:**

Returns the condition\_variable name.

#### **NOTES:**

The name may be NULL.

## <span id="page-833-1"></span>28.4.8 Condition variable destruction

## **CALLING SEQUENCE:**

```
1 void rtems_condition_variable_destroy(
2 rtems_condition_variable *condition_variable
3 );
```

#### **DESCRIPTION:**

Destroys the condition\_variable.

## **NOTES:**

In case the condition variable still in use, then the result is unpredictable.

# <span id="page-834-0"></span>28.5 Counting Semaphores

The rtems\_counting\_semaphore object provides a counting semaphore synchronization object. The storage space for this object must be provided by the user. There are no defined comparison or assignment operators for this type. Only the object itself may be used for performing synchronization. The result of referring to copies of the object in calls to

- rtems\_counting\_semaphore\_wait(),
- rtems\_counting\_semaphore\_wait\_timed\_ticks(),
- rtems\_counting\_semaphore\_try\_wait(),
- rtems\_counting\_semaphore\_post(),
- rtems\_counting\_semaphore\_set\_name(),
- rtems\_counting\_semaphore\_get\_name(), and
- rtems\_counting\_semaphore\_destroy()

is undefined. Objects of this type must be initialized via

- RTEMS\_COUNTING\_SEMAPHORE\_INITIALIZER(), or
- rtems\_counting\_semaphore\_init().

They must be destroyed via

â€¢ rtems\_counting\_semaphore\_destroy().

## <span id="page-835-0"></span>28.5.1 Static counting semaphore initialization

#### **CALLING SEQUENCE:**

```
1 rtems_counting_semaphore counting_semaphore = RTEMS_COUNTING_SEMAPHORE_
  Ë“â†’INITIALIZER(
2 name,
3 value
4 );
```

## **DESCRIPTION:**

An initializer for static initialization. It is equivalent to a call to rtems\_counting\_semaphore\_init().

#### **NOTES:**

Global counting semaphores with a name of NULL may reside in the .bss section.

## <span id="page-836-0"></span>28.5.2 Run-time counting semaphore initialization

#### **CALLING SEQUENCE:**

```
1 void rtems_counting_semaphore_init(
2 rtems_counting_semaphore *counting_semaphore,
3 const char *name,
4 unsigned int value
5 );
```

#### **DESCRIPTION:**

Initializes the counting\_semaphore with the specified name and value. The initial value is set to value.

#### **NOTES:**

The name must be persistent throughout the life-time of the counting semaphore. A name of NULL is valid.

## <span id="page-837-0"></span>28.5.3 Wait for a counting semaphore

#### **CALLING SEQUENCE:**

```
1 void rtems_counting_semaphore_wait(
2 rtems_counting_semaphore *counting_semaphore
3 );
```

#### **DESCRIPTION:**

Waits for the counting\_semaphore. In case the current semaphore value is positive, then the value is decremented and the function returns immediately, otherwise the thread is blocked waiting for a semaphore post.

#### **NOTES:**

This function must be called from thread context with interrupts enabled. Threads wait in priority order.

## <span id="page-838-0"></span>28.5.4 Wait for a counting semaphore with timeout in ticks

#### **CALLING SEQUENCE:**

```
1 int rtems_counting_semaphore_wait_timed_ticks(
2 rtems_counting_semaphore *counting_semaphore,
3 uint32_t ticks
4 );
```

## **DIRECTIVE STATUS CODES:**

0 The semaphore wait was successful. ETIMEDOUT The semaphore wait timed out.

#### **DESCRIPTION:**

Waits for the counting\_semaphore with a timeout in ticks. In case the current semaphore value is positive, then the value is decremented and the function returns immediately with a return value of 0, otherwise the thread is blocked waiting for a semaphore post. The time waiting for a semaphore post is limited by ticks. A ticks value of zero specifies an infinite timeout.

#### **NOTES:**

This function must be called from thread context with interrupts enabled. Threads wait in priority order.

## <span id="page-839-0"></span>28.5.5 Tries to wait for a counting semaphore

#### **CALLING SEQUENCE:**

```
1 int rtems_counting_semaphore_try_wait(
2 rtems_counting_semaphore *counting_semaphore
3 );
```

## **DIRECTIVE STATUS CODES:**

0 The semaphore wait was successful. EAGAIN The semaphore wait failed.

#### **DESCRIPTION:**

Tries to wait for the counting\_semaphore. In case the current semaphore value is positive, then the value is decremented and the function returns immediately with a return value of 0, otherwise it returns immediately with a return value of EAGAIN.

#### **NOTES:**

This function may be called from interrupt context. In case it is called from thread context, then interrupts must be enabled.

## <span id="page-840-0"></span>28.5.6 Post a counting semaphore

#### **CALLING SEQUENCE:**

```
1 void rtems_counting_semaphore_post(
2 rtems_counting_semaphore *counting_semaphore
3 );
```

#### **DESCRIPTION:**

Posts the counting\_semaphore. In case at least one thread is waiting on the counting semaphore, then the highest priority thread is woken up, otherwise the current value is incremented.

#### **NOTES:**

This function may be called from interrupt context. In case it is called from thread context, then interrupts must be enabled.

## <span id="page-841-0"></span>28.5.7 Set counting semaphore name

#### **CALLING SEQUENCE:**

```
1 void rtems_counting_semaphore_set_name(
2 rtems_counting_semaphore *counting_semaphore,
3 const char *name
4 );
```

## **DESCRIPTION:**

Sets the counting\_semaphore name to name.

## **NOTES:**

The name must be persistent throughout the life-time of the counting semaphore. A name of NULL is valid.

## <span id="page-842-0"></span>28.5.8 Get counting semaphore name

#### **CALLING SEQUENCE:**

```
1 const char *rtems_counting_semaphore_get_name(
2 const rtems_counting_semaphore *counting_semaphore
3 );
```

#### **DESCRIPTION:**

Returns the counting\_semaphore name.

#### **NOTES:**

The name may be NULL.

## <span id="page-842-1"></span>28.5.9 Counting semaphore destruction

## **CALLING SEQUENCE:**

```
1 void rtems_counting_semaphore_destroy(
2 rtems_counting_semaphore *counting_semaphore
3 );
```

#### **DESCRIPTION:**

Destroys the counting\_semaphore.

## **NOTES:**

In case the counting semaphore still in use, then the result is unpredictable.

# <span id="page-843-0"></span>28.6 Binary Semaphores

The rtems\_binary\_semaphore object provides a binary semaphore synchronization object. The storage space for this object must be provided by the user. There are no defined comparison or assignment operators for this type. Only the object itself may be used for performing synchronization. The result of referring to copies of the object in calls to

- rtems\_binary\_semaphore\_wait(),
- rtems\_binary\_semaphore\_wait\_timed\_ticks(),
- rtems\_binary\_semaphore\_try\_wait(),
- rtems\_binary\_semaphore\_post(),
- rtems\_binary\_semaphore\_set\_name(),
- rtems\_binary\_semaphore\_get\_name(), and
- rtems\_binary\_semaphore\_destroy()

is undefined. Objects of this type must be initialized via

- RTEMS\_BINARY\_SEMAPHORE\_INITIALIZER(), or
- rtems\_binary\_semaphore\_init().

They must be destroyed via

â€¢ rtems\_binary\_semaphore\_destroy().

## <span id="page-844-0"></span>28.6.1 Static binary semaphore initialization

#### **CALLING SEQUENCE:**

```
1 rtems_binary_semaphore binary_semaphore = RTEMS_BINARY_SEMAPHORE_INITIALIZER(
2 name
3 );
```

## **DESCRIPTION:**

An initializer for static initialization. It is equivalent to a call to rtems\_binary\_semaphore\_init().

## **NOTES:**

Global binary semaphores with a name of NULL may reside in the .bss section.

## <span id="page-845-0"></span>28.6.2 Run-time binary semaphore initialization

#### **CALLING SEQUENCE:**

```
1 void rtems_binary_semaphore_init(
2 rtems_binary_semaphore *binary_semaphore,
3 const char *name
4 );
```

## **DESCRIPTION:**

Initializes the binary\_semaphore with the specified name. The initial value is set to zero.

## **NOTES:**

The name must be persistent throughout the life-time of the binary semaphore. A name of NULL is valid.

## <span id="page-846-0"></span>28.6.3 Wait for a binary semaphore

#### **CALLING SEQUENCE:**

```
1 void rtems_binary_semaphore_wait(
2 rtems_binary_semaphore *binary_semaphore
3 );
```

## **DESCRIPTION:**

Waits for the binary\_semaphore. In case the current semaphore value is one, then the value is set to zero and the function returns immediately, otherwise the thread is blocked waiting for a semaphore post.

#### **NOTES:**

This function must be called from thread context with interrupts enabled. Threads wait in priority order.

## <span id="page-847-0"></span>28.6.4 Wait for a binary semaphore with timeout in ticks

#### **CALLING SEQUENCE:**

```
1 int rtems_binary_semaphore_wait_timed_ticks(
2 rtems_binary_semaphore *binary_semaphore,
3 uint32_t ticks
4 );
```

## **DIRECTIVE STATUS CODES:**

0 The semaphore wait was successful. ETIMEDOUT The semaphore wait timed out.

#### **DESCRIPTION:**

Waits for the binary\_semaphore with a timeout in ticks. In case the current semaphore value is one, then the value is set to zero and the function returns immediately with a return value of 0, otherwise the thread is blocked waiting for a semaphore post. The time waiting for a semaphore post is limited by ticks. A ticks value of zero specifies an infinite timeout.

## **NOTES:**

This function must be called from thread context with interrupts enabled. Threads wait in priority order.

## <span id="page-848-0"></span>28.6.5 Tries to wait for a binary semaphore

#### **CALLING SEQUENCE:**

```
1 int rtems_binary_semaphore_try_wait(
2 rtems_binary_semaphore *binary_semaphore
3 );
```

## **DIRECTIVE STATUS CODES:**

0 The semaphore wait was successful. EAGAIN The semaphore wait failed.

#### **DESCRIPTION:**

Tries to wait for the binary\_semaphore. In case the current semaphore value is one, then the value is set to zero and the function returns immediately with a return value of 0, otherwise it returns immediately with a return value of EAGAIN.

#### **NOTES:**

This function may be called from interrupt context. In case it is called from thread context, then interrupts must be enabled.

## <span id="page-849-0"></span>28.6.6 Post a binary semaphore

#### **CALLING SEQUENCE:**

```
1 void rtems_binary_semaphore_post(
2 rtems_binary_semaphore *binary_semaphore
3 );
```

#### **DESCRIPTION:**

Posts the binary\_semaphore. In case at least one thread is waiting on the binary semaphore, then the highest priority thread is woken up, otherwise the current value is set to one.

## **NOTES:**

This function may be called from interrupt context. In case it is called from thread context, then interrupts must be enabled.

## <span id="page-850-0"></span>28.6.7 Set binary semaphore name

#### **CALLING SEQUENCE:**

```
1 void rtems_binary_semaphore_set_name(
2 rtems_binary_semaphore *binary_semaphore,
3 const char *name
4 );
```

## **DESCRIPTION:**

Sets the binary\_semaphore name to name.

## **NOTES:**

The name must be persistent throughout the life-time of the binary semaphore. A name of NULL is valid.

## <span id="page-851-0"></span>28.6.8 Get binary semaphore name

#### **CALLING SEQUENCE:**

```
1 const char *rtems_binary_semaphore_get_name(
2 const rtems_binary_semaphore *binary_semaphore
3 );
```

## **DESCRIPTION:**

Returns the binary\_semaphore name.

## **NOTES:**

The name may be NULL.

## <span id="page-851-1"></span>28.6.9 Binary semaphore destruction

## **CALLING SEQUENCE:**

```
1 void rtems_binary_semaphore_destroy(
2 rtems_binary_semaphore *binary_semaphore
3 );
```

## **DESCRIPTION:**

Destroys the binary\_semaphore.

## **NOTES:**

In case the binary semaphore still in use, then the result is unpredictable.

# <span id="page-852-0"></span>28.7 Threads

## . **Warning**

The self-contained threads support is work in progress. In contrast to the synchronization objects the self-contained thread support is not just an API glue layer to already existing implementations.

The rtems\_thread object provides a thread of execution.

### **CALLING SEQUENCE:**

```
1 RTEMS_THREAD_INITIALIZER(
2 name,
3 thread_size,
4 priority,
5 flags,
6 entry,
7 arg
8 );
9
10 void rtems_thread_start(
11 rtems_thread *thread,
12 const char *name,
13 size_t thread_size,
14 uint32_t priority,
15 uint32_t flags,
16 void ( *entry )( void * ),
17 void *arg
18 );
19
20 void rtems_thread_restart(
21 rtems_thread *thread,
22 void *arg
23 ) RTEMS_NO_RETURN;
24
25 void rtems_thread_event_send(
26 rtems_thread *thread,
27 uint32_t events
28 );
29
30 uint32_t rtems_thread_event_poll(
31 rtems_thread *thread,
32 uint32_t events_of_interest
33 );
34
35 uint32_t rtems_thread_event_wait_all(
36 rtems_thread *thread,
37 uint32_t events_of_interest
```

(continues on next page)

28.7. Threads 825

(continued from previous page)

```
38 );
39
40 uint32_t rtems_thread_event_wait_any(
41 rtems_thread *thread,
42 uint32_t events_of_interest
43 );
44
45 void rtems_thread_destroy(
46 rtems_thread *thread
47 );
48
49 void rtems_thread_destroy_self(
50 void
51 ) RTEMS_NO_RETURN;
```

CHAPTER

# **TWENTYNINE**

# <span id="page-854-0"></span>REGULATOR MANAGER

# <span id="page-855-0"></span>29.1 Introduction

The Regulator Manager provides a set of directives to manage a data flow from a source to a destination. The focus is on regulating the bursty input so that it is delivered to the destination at a regular rate. The directives provided by the Regulator Manager are:

- *[rtems\\_regulator\\_create\(\)](#page-861-0)* (page 834) Creates a regulator.
- *[rtems\\_regulator\\_delete\(\)](#page-863-0)* (page 836) Deletes the regulator.
- *[rtems\\_regulator\\_obtain\\_buffer\(\)](#page-865-0)* (page 838) Obtain buffer from a regulator.
- *[rtems\\_regulator\\_release\\_buffer\(\)](#page-866-0)* (page 839) Release buffer to a regulator.
- *[rtems\\_regulator\\_send\(\)](#page-867-0)* (page 840) Send buffer to a regulator.
- *[rtems\\_regulator\\_get\\_statistics\(\)](#page-869-0)* (page 842) Obtain statistics for a regulator.

# <span id="page-856-0"></span>29.2 Background

The regulator provides facilities to accept bursty input and buffer it as needed before delivering it at a pre-defined periodic rate. The input is referred to as the Source, with the output referred to as the Destination. Messages are accepted from the Source and delivered to the Destination by a user-provided Delivery function.

The Regulator implementation uses the RTEMS Classic API Partition Manager to manage the buffer pool and the RTEMS Classic API Message Queue Manager to send the buffer to the Delivery thread. The Delivery thread invokes a user-provided delivery function to get the message to the Destination.

## <span id="page-856-1"></span>29.2.1 Regulator Buffering

The regulator is designed to sit logically between two entities â€“ a source and a destination, where it limits the traffic sent to the destination to prevent it from being flooded with messages from the source. This can be used to accommodate bursts of input from a source and meter it out to a destination. The maximum number of messages which can be buffered in the regulator is specified by the maximum\_messages field in the *[rtems\\_regulator\\_attributes](#page-77-1)* (page 50) structure passed as an argument to *[rtems\\_regulator\\_create\(\)](#page-861-0)* (page 834).

The regulator library accepts an input stream of messages from a source and delivers them to a destination. The regulator assumes that the input stream from the source contains sporadic bursts of data which can exceed the acceptable rate of the destination. By limiting the message rate, the regulator prevents an overflow of messages.

The regulator can be configured for the input buffering required to manage the maximum burst and for the metering rate for the delivery. The delivery rate is in messages per second. If the sender produces data too fast, the regulator will buffer the configured number of messages.

A configuration capability is provided to allow for adaptation to different message streams. The regulator can also support running multiple instances, which could be used on independent message streams.

It is assumed that the application has a design limit on the number of messages which may be buffered. All messages accepted by the regulator, assuming no overflow on input, will eventually be output by the Delivery thread.

## <span id="page-856-2"></span>29.2.2 Message Delivery Rate

The Source sends buffers to the Regulator instance. The Regulator then sends the buffer via a message queue which delivers them to the Delivery thread. The Delivery thread executes periodically at a rate specified by the delivery\_thread\_period field in the *[rtems\\_regulator\\_attributes](#page-77-1)* (page 50) structure passed as an argument to *[rtems\\_regulator\\_create\(\)](#page-861-0)* (page 834).

During each period, the Delivery thread attempts to receive up to maximum\_to\_dequeue\_per\_period number of buffers and invoke the Delivery function to deliver each of them to the Destination. The maximum\_to\_dequeue\_per\_period field in the *[rtems\\_regulator\\_attributes](#page-77-1)* (page 50) structure passed as an argument to *[rtems\\_regulator\\_create\(\)](#page-861-0)* (page 834).

For example, consider a Source that may produce a burst of up to seven messages every five seconds. But the Destination cannot handle a burst of seven and either drops messages or gives an error. This can be accommodated by a Regulator instance configured as follows:

â€¢ maximum\_messages - 7

29.2. Background 829

- delivery\_thread\_period one second
- maximum\_to\_dequeue\_per\_period 3

In this scenario, the application will use the Delivery thread *[rtems\\_regulator\\_send\(\)](#page-867-0)* (page 840) to enqueue the seven messages when they arrive. The Delivery thread will deliver three messages per second. The following illustrates this sequence:

- Time 0: Source sends seven messages
- Time 1: Delivery of messages 1 to 3
- Time 3: Delivery of messages 4 to 6
- Time 3: Delivery of message 7
- Time 4: No messages to deliver

This configuration of the regulator ensures that the Destination does not overflow.

# <span id="page-858-0"></span>29.3 Operations

## <span id="page-858-1"></span>29.3.1 Application Sourcing Data

The application interacting with the Source will obtain buffers from the regulator instance, fill them with information, and send them to the regulator instance. This allows the regulator to buffer bursty input.

A regulator instance is used as follows from the Source side:

```
1 while (1) {
2 use rtems_regulator_obtain_buffer to obtain a buffer
3 // Perform some input operation to fetch data into the buffer
4 rtems_regulator_send(buffer, size of message)
5 }
```

The delivery of message buffers to the Destination and subsequent release is performed in the context of the delivery thread by either the delivery function or delivery thread. Details are below.

The sequence diagram below shows the interaction between a message Source, a Regulator instance, and RTEMS, given the usage described in the above paragraphs.

![](_page_858_Figure_9.jpeg)

As illustrated in the preceding sequence diagram, the Source usually corresponds to application software reading a system input. The Source obtains a buffer from the Regulator instance and fills it with incoming data. The application explicitly obtaining a buffer and filling it in allows for zero copy operations on the Source side.

After the Source has sent the message to the Regulator instance, the Source is free to process another input and the Regulator instance will ensure that the buffer is delivered to the Delivery function and Destination.

## <span id="page-858-2"></span>29.3.2 Delivery Function

The Delivery function is provided by the application for a specific Regulator instance. Depending on the Destination, it may use a function which copies the buffer contents (e.g., write()) or which operates directly on the buffer contents (e.g. DMA from buffer). In the case of a Destination which copies the buffer contents, the buffer can be released via *[rtems\\_regulator\\_release\\_buffer\(\)](#page-866-0)* (page 839) as soon as the function or copying completes. In the case where the delivery uses the buffer and returns, the call to *[rtems\\_regulator\\_release\\_buffer\(\)](#page-866-0)*

29.3. Operations 831

(page 839) will occur when the use of the buffer is complete (e.g. completion of DMA transfer). This explicit and deliberate exposure of buffering provides the application with the ability to avoid copying the contents.

# <span id="page-860-0"></span>29.4 Directives

This section details the directives of the Regulator Manager. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

29.4. Directives 833

## <span id="page-861-1"></span><span id="page-861-0"></span>29.4.1 rtems\_regulator\_create()

Creates a regulator.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_regulator_create(
2 rtems_regulator_attributes *attributes,
3 rtems_regulator_instance **regulator
4 );
```

#### PARAMETERS:

#### **attributes**

This parameter is the attributes associated with the regulator being created.

#### **regulator**

This parameter is the pointer to a regulator instance. When the directive call is successful, a pointer to the created regulator will be stored in this object.

#### DESCRIPTION:

This function creates an instance of a regulator. It uses the provided attributes to create the instance return in regulator. This instance will allocate the buffers associated with the regulator instance as well as the Delivery Thread.

The attributes parameter points to an instance of *[rtems\\_regulator\\_attributes](#page-77-1)* (page 50) which is filled in to reflect the desired configuration of the regulator instance. It defines multiple characteristics of the the Delivery thread dedicated to this regulator instance including the priority and stack size. It also defines the period of the Delivery thread and the maximum number of messages that may be delivered per period via invocation of the delivery function.

For each regulator instance, the following resources are allocated:

- A memory area for the regulator control block using malloc().
- A RTEMS Classic API Message Queue is constructed with message buffer memory allocated using malloc(). Each message consists of a pointer to the contents and a length field.
- A RTEMS Classic API Partition.
- A RTEMS Classic API Rate Monotonic Period.

## RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The attributes parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ADDRESS**

The regulator parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

## **RTEMS\_INVALID\_ADDRESS**

The deliverer field in the structure pointed to by the attributes parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_SIZE**

The maximum\_messages field in the structure pointed to by the attributes parameter was 0.

#### **RTEMS\_INVALID\_NUMBER**

The maximum\_to\_dequeue\_per\_period field in the structure pointed to by the attributes parameter was 0.

#### **RTEMS\_NO\_MEMORY**

The allocation of memory for the regulator instance failed.

#### **RTEMS\_NO\_MEMORY**

The allocation of memory for the buffers failed.

#### **RTEMS\_NO\_MEMORY**

The allocation of memory for the internal message queue failed.

#### NOTES:

*[rtems\\_regulator\\_create\(\)](#page-861-0)* (page 834) uses *[rtems\\_partition\\_create\(\)](#page-449-0)* (page 422), *[rtems\\_message\\_queue\\_construct\(\)](#page-404-0)* (page 377), *[rtems\\_task\\_create\(\)](#page-136-0)* (page 109), and *[rtems\\_task\\_start\(\)](#page-145-0)* (page 118). If any of those directives return a status indicating failure, it will be returned to the caller.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- The number of tasks available to the application is configured through the *[CONFIG-](#page-650-0)[URE\\_MAXIMUM\\_TASKS](#page-650-0)* (page 623) application configuration option.
- Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace.

29.4. Directives 835

## <span id="page-863-1"></span><span id="page-863-0"></span>29.4.2 rtems\_regulator\_delete()

Deletes the regulator.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_regulator_delete(
2 rtems_regulator_instance *regulator,
3 rtems_interval ticks
4 );
```

#### PARAMETERS:

#### **regulator**

This parameter points to the regulator instance.

#### **ticks**

This parameter specifies the maximum length of time to wait.

#### DESCRIPTION:

This directive is used to delete the specified regulator instance. It will deallocate the resources that were allocated by the *[rtems\\_regulator\\_create\(\)](#page-861-0)* (page 834) directive.

This directive ensures that no buffers are outstanding either because the Source is holding one of more buffers or because they are being held by the regulator instance pending delivery.

If the Delivery Thread has been created and is running, this directive will request the thread to voluntarily exit. This call will wait up to ticks for the thread to exit.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ADDRESS**

The regulator parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INCORRECT\_STATE**

The regulator instance was not initialized.

#### **RTEMS\_RESOURCE\_IN\_USE**

The regulator instance has buffers outstanding.

## **RTEMS\_TIMEOUT**

The regulator instance was not able to be deleted within the specific number of ticks.

#### NOTES:

It is the responsibility of the user to ensure that any resources such as sockets or open file descriptors used by the Source or delivery function are also deleted if necessary. It is likely safer to delete those delivery resources after deleting the regulator instance rather than before.

It is the responsibility of the user to ensure that all buffers associated with this regulator instance have been released and that none are in the process of being delivered.

### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.
- The calling task does not have to be the task that created the object. Any local task that knows the object identifier can delete the object.
- Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace.

29.4. Directives 837

## <span id="page-865-1"></span><span id="page-865-0"></span>29.4.3 rtems\_regulator\_obtain\_buffer()

Obtain buffer from regulator.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_regulator_obtain_buffer(
2 rtems_regulator_instance *regulator,
3 void **buffer
4 );
```

#### PARAMETERS:

#### **regulator**

This parameter is the regulator instance to operate upon.

#### **buffer**

This parameter will point to the buffer allocated.

#### DESCRIPTION:

This function is used to obtain a buffer from the regulator's pool. The buffer returned is assumed to be filled in with contents and used in a subsequent call to *[rtems\\_regulator\\_send\(\)](#page-867-0)* (page 840).

When the buffer is delivered, it is expected to be released. If the buffer is not successfully accepted by this method, then it should be returned using *[rtems\\_regulator\\_release\\_buffer\(\)](#page-866-0)* (page 839) or used to send another message.

The buffer returned is of the maximum\_message\_size specified in the attributes passed in to *[rtems\\_regulator\\_create\(\)](#page-861-0)* (page 834).

#### RETURN VALUES:

## **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ADDRESS**

The regulator parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INCORRECT\_STATE**

The regulator instance was not initialized.

#### NOTES:

*[rtems\\_regulator\\_obtain\\_buffer\(\)](#page-865-0)* (page 838) uses *[rtems\\_partition\\_get\\_buffer\(\)](#page-456-0)* (page 429) and if it returns a status indicating failure, it will be returned to the caller.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.

## <span id="page-866-1"></span><span id="page-866-0"></span>29.4.4 rtems\_regulator\_release\_buffer()

Release buffer to regulator.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_regulator_release_buffer(
2 rtems_regulator_instance *regulator,
3 void *buffer
4 );
```

#### PARAMETERS:

#### **regulator**

This parameter is the regulator instance to operate upon.

#### **buffer**

This parameter will point to the buffer to be released.

#### DESCRIPTION:

This function is used to release a buffer to the regulator's pool. It is assumed that the buffer returned will not be used by the application anymore.

The buffer must have previously been allocated by *[rtems\\_regulator\\_obtain\\_buffer\(\)](#page-865-0)* (page 838) and NOT yet passed to *[rtems\\_regulator\\_send\(\)](#page-867-0)* (page 840), or it has been sent and delivery has been completed by the delivery function.

If a subsequent *[rtems\\_regulator\\_send\(\)](#page-867-0)* (page 840) using this buffer is successful, the buffer will eventually be processed by the delivery thread and released.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The regulator parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INCORRECT\_STATE**

The regulator instance was not initialized.

#### NOTES:

*[rtems\\_regulator\\_release\\_buffer\(\)](#page-866-0)* (page 839) uses *[rtems\\_partition\\_return\\_buffer\(\)](#page-458-0)* (page 431) and if it returns a status indicating failure, it will be returned to the caller.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.

29.4. Directives 839

## <span id="page-867-1"></span><span id="page-867-0"></span>29.4.5 rtems\_regulator\_send()

Send buffer to regulator.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_regulator_send(
2 rtems_regulator_instance *regulator,
3 void *message,
4 size_t length
5 );
```

#### PARAMETERS:

#### **regulator**

This parameter is the regulator instance to operate upon.

#### **message**

This parameter points to the buffer to send.

#### **length**

This parameter specifies the number of bytes in the message.

## DESCRIPTION:

This method is used by the producer to send a message to the regulator for later delivery by the delivery thread. The message is contained in the memory pointed to by message and is length bytes in length.

It is required that the message buffer was obtained via *[rtems\\_regulator\\_obtain\\_buffer\(\)](#page-865-0)* (page 838).

It is assumed that the message buffer has been filled in with application content to deliver.

If the *[rtems\\_regulator\\_send\(\)](#page-867-0)* (page 840) is successful, the message buffer is enqueued inside the regulator instance for subsequent delivery. After the message is delivered, it may be released by either delivery function or other application code depending on the implementation.

The status RTEMS\_TOO\_MANY is returned if the regulator's internal queue is full. This indicates that the configured maximum number of messages was insufficient. It is the responsibility of the caller to decide whether to hold messages, drop them, or print a message that the maximum number of messages should be increased

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The regulator parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INCORRECT\_STATE**

The regulator instance was not initialized.

### NOTES:

*[rtems\\_regulator\\_send\(\)](#page-867-0)* (page 840) uses *[rtems\\_message\\_queue\\_send\(\)](#page-410-0)* (page 383) and if it returns a status indicating failure, it will be returned to the caller.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.

29.4. Directives 841

## <span id="page-869-1"></span><span id="page-869-0"></span>29.4.6 rtems\_regulator\_get\_statistics()

Obtain statistics from regulator.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_regulator_get_statistics(
2 rtems_regulator_instance *regulator,
3 rtems_regulator_statistics *statistics
4 );
```

#### PARAMETERS:

#### **regulator**

This parameter is the regulator instance to operate upon.

#### **statistics**

This parameter points to the statistics structure to be filled in.

#### DESCRIPTION:

This method is used by the application to obtain the current statistics for this regulator. The statistics information provided includes:

- the number of buffers obtained via *[rtems\\_regulator\\_obtain\\_buffer\(\)](#page-865-0)* (page 838)
- the number of buffers released via *[rtems\\_regulator\\_release\\_buffer\(\)](#page-866-0)* (page 839)
- the number of buffers delivered by the Delivery Thread via the deliverer function specified in the *[rtems\\_regulator\\_attributes](#page-77-1)* (page 50) structure provided to *[rtems\\_regulator\\_create\(\)](#page-861-0)* (page 834)via theattibutes` parameter.
- the period\_statistics for the Delivery Thread. For more details on period statistics, see *[rtems\\_rate\\_monotonic\\_period\\_statistics](#page-76-3)* (page 49).

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The regulator or statistics parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INCORRECT\_STATE**

The regulator instance was not initialized.

#### NOTES:

The number of buffers outstanding is released minus obtained. The regulator instance cannot be deleted using *[rtems\\_regulator\\_delete\(\)](#page-863-0)* (page 836) until all buffers are released.

The obtained and released values are cumulative over the life of the Regulator instance and are likely to larger than the maximum\_messages value in the attributes structure (*[rtems\\_regulator\\_attributes](#page-77-1)* (page 50) provided to *[rtems\\_regulator\\_create\(\)](#page-861-0)* (page 834).

### <span id="page-870-0"></span>CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.

29.4. Directives 843

CHAPTER

**THIRTY**

# <span id="page-872-0"></span>MULTIPROCESSING MANAGER

# <span id="page-873-1"></span><span id="page-873-0"></span>30.1 Introduction

The Multiprocessing Manager provides support for heterogeneous multiprocessing systems based on message passing in a network of multiprocessing nodes.

In multiprocessor real-time systems, new requirements, such as sharing data and global resources between processors, are introduced. This requires an efficient and reliable communications vehicle which allows all processors to communicate with each other as necessary. In addition, the ramifications of multiple processors affect each and every characteristic of a realtime system, almost always making them more complicated.

RTEMS addresses these issues by providing simple and flexible real-time multiprocessing capabilities. The executive easily lends itself to both tightly-coupled and loosely-coupled configurations of the target system hardware. In addition, RTEMS supports systems composed of both homogeneous and heterogeneous mixtures of processors and target boards.

A major design goal of the RTEMS executive was to transcend the physical boundaries of the target hardware configuration. This goal is achieved by presenting the application software with a logical view of the target system where the boundaries between processor nodes are transparent. As a result, the application developer may designate objects such as tasks, queues, events, signals, semaphores, and memory blocks as global objects. These global objects may then be accessed by any task regardless of the physical location of the object and the accessing task. RTEMS automatically determines that the object being accessed resides on another processor and performs the actions required to access the desired object. Simply stated, RTEMS allows the entire system, both hardware and software, to be viewed logically as a single system. The directives provided by the Multiprocessing Manager are:

â€¢ *[rtems\\_multiprocessing\\_announce\(\)](#page-883-0)* (page 856) - Announces the arrival of a packet.

# <span id="page-874-4"></span><span id="page-874-0"></span>30.2 Background

RTEMS makes no assumptions regarding the connection media or topology of a multiprocessor system. The tasks which compose a particular application can be spread among as many processors as needed to satisfy the application's timing requirements. The application tasks can interact using a subset of the RTEMS directives as if they were on the same processor. These directives allow application tasks to exchange data, communicate, and synchronize regardless of which processor they reside upon.

The RTEMS multiprocessor execution model is multiple instruction streams with multiple data streams (MIMD). This execution model has each of the processors executing code independent of the other processors. Because of this parallelism, the application designer can more easily guarantee deterministic behavior.

By supporting heterogeneous environments, RTEMS allows the systems designer to select the most efficient processor for each subsystem of the application. Configuring RTEMS for a heterogeneous environment is no more difficult than for a homogeneous one. In keeping with RTEMS philosophy of providing transparent physical node boundaries, the minimal heterogeneous processing required is isolated in the MPCI layer.

## <span id="page-874-1"></span>30.2.1 Nodes

A processor in a RTEMS system is referred to as a node. Each node is assigned a unique nonzero node number by the application designer. RTEMS assumes that node numbers are assigned consecutively from one to the maximum\_nodes configuration parameter. The node number, node, and the maximum number of nodes, maximum\_nodes, in a system are found in the Multiprocessor Configuration Table. The maximum\_nodes field and the number of global objects, maximum\_global\_objects, is required to be the same on all nodes in a system.

The node number is used by RTEMS to identify each node when performing remote operations. Thus, the Multiprocessor Communications Interface Layer (MPCI) must be able to route messages based on the node number.

# <span id="page-874-2"></span>30.2.2 Global Objects

All RTEMS objects which are created with the GLOBAL attribute will be known on all other nodes. Global objects can be referenced from any node in the system, although certain directive specific restrictions (e.g. one cannot delete a remote object) may apply. A task does not have to be global to perform operations involving remote objects. The maximum number of global objects is the system is user configurable and can be found in the maximum\_global\_objects field in the Multiprocessor Configuration Table. The distribution of tasks to processors is performed during the application design phase. Dynamic task relocation is not supported by RTEMS.

## <span id="page-874-3"></span>30.2.3 Global Object Table

RTEMS maintains two tables containing object information on every node in a multiprocessor system: a local object table and a global object table. The local object table on each node is unique and contains information for all objects created on this node whether those objects are local or global. The global object table contains information regarding all global objects in the system and, consequently, is the same on every node.

Since each node must maintain an identical copy of the global object table, the maximum number of entries in each copy of the table must be the same. The maximum number of entries in each copy is determined by the maximum\_global\_objects parameter in the Multiprocessor

30.2. Background 847

<span id="page-875-1"></span>Configuration Table. This parameter, as well as the maximum\_nodes parameter, is required to be the same on all nodes. To maintain consistency among the table copies, every node in the system must be informed of the creation or deletion of a global object.

## <span id="page-875-0"></span>30.2.4 Remote Operations

When an application performs an operation on a remote global object, RTEMS must generate a Remote Request (RQ) message and send it to the appropriate node. After completing the requested operation, the remote node will build a Remote Response (RR) message and send it to the originating node. Messages generated as a side-effect of a directive (such as deleting a global task) are known as Remote Processes (RP) and do not require the receiving node to respond.

Other than taking slightly longer to execute directives on remote objects, the application is unaware of the location of the objects it acts upon. The exact amount of overhead required for a remote operation is dependent on the media connecting the nodes and, to a lesser degree, on the efficiency of the user-provided MPCI routines.

The following shows the typical transaction sequence during a remote application:

- 1. The application issues a directive accessing a remote global object.
- 2. RTEMS determines the node on which the object resides.
- 3. RTEMS calls the user-provided MPCI routine GET\_PACKET to obtain a packet in which to build a RQ message.
- 4. After building a message packet, RTEMS calls the user-provided MPCI routine SEND\_PACKET to transmit the packet to the node on which the object resides (referred to as the destination node).
- 5. The calling task is blocked until the RR message arrives, and control of the processor is transferred to another task.
- 6. The MPCI layer on the destination node senses the arrival of a packet (commonly in an ISR), and calls the rtems\_multiprocessing\_announce directive. This directive readies the Multiprocessing Server.
- 7. The Multiprocessing Server calls the user-provided MPCI routine RECEIVE\_PACKET, performs the requested operation, builds an RR message, and returns it to the originating node.
- 8. The MPCI layer on the originating node senses the arrival of a packet (typically via an interrupt), and calls the RTEMS rtems\_multiprocessing\_announce directive. This directive readies the Multiprocessing Server.
- 9. The Multiprocessing Server calls the user-provided MPCI routine RECEIVE\_PACKET, readies the original requesting task, and blocks until another packet arrives. Control is transferred to the original task which then completes processing of the directive.

If an uncorrectable error occurs in the user-provided MPCI layer, the fatal error handler should be invoked. RTEMS assumes the reliable transmission and reception of messages by the MPCI and makes no attempt to detect or correct errors.

## <span id="page-876-0"></span>30.2.5 Proxies

A proxy is an RTEMS data structure which resides on a remote node and is used to represent a task which must block as part of a remote operation. This action can occur as part of the rtems\_semaphore\_obtain and rtems\_message\_queue\_receive directives. If the object were local, the task's control block would be available for modification to indicate it was blocking on a message queue or semaphore. However, the task's control block resides only on the same node as the task. As a result, the remote node must allocate a proxy to represent the task until it can be readied.

The maximum number of proxies is defined in the Multiprocessor Configuration Table. Each node in a multiprocessor system may require a different number of proxies to be configured. The distribution of proxy control blocks is application dependent and is different from the distribution of tasks.

## <span id="page-876-1"></span>30.2.6 Multiprocessor Configuration Table

The Multiprocessor Configuration Table contains information needed by RTEMS when used in a multiprocessor system. This table is discussed in detail in the section Multiprocessor Configuration Table of the Configuring a System chapter.

30.2. Background 849

# <span id="page-877-2"></span><span id="page-877-0"></span>30.3 Multiprocessor Communications Interface Layer

The Multiprocessor Communications Interface Layer (MPCI) is a set of user-provided procedures which enable the nodes in a multiprocessor system to communicate with one another. These routines are invoked by RTEMS at various times in the preparation and processing of remote requests. Interrupts are enabled when an MPCI procedure is invoked. It is assumed that if the execution mode and/or interrupt level are altered by the MPCI layer, that they will be restored prior to returning to RTEMS.

The MPCI layer is responsible for managing a pool of buffers called packets and for sending these packets between system nodes. Packet buffers contain the messages sent between the nodes. Typically, the MPCI layer will encapsulate the packet within an envelope which contains the information needed by the MPCI layer. The number of packets available is dependent on the MPCI layer implementation.

The entry points to the routines in the user's MPCI layer should be placed in the Multiprocessor Communications Interface Table. The user must provide entry points for each of the following table entries in a multiprocessor system:

| initialization | initialize the MPCI             |
|----------------|---------------------------------|
| get_packet     | obtain a packet buffer          |
| return_packet  | return a packet buffer          |
| send_packet    | send a packet to another node   |
| receive_packet | called to get an arrived packet |

A packet is sent by RTEMS in each of the following situations:

- an RQ is generated on an originating node;
- an RR is generated on a destination node;
- a global object is created;
- a global object is deleted;
- a local task blocked on a remote object is deleted;
- during system initialization to check for system consistency.

If the target hardware supports it, the arrival of a packet at a node may generate an interrupt. Otherwise, the real-time clock ISR can check for the arrival of a packet. In any case, the rtems\_multiprocessing\_announce directive must be called to announce the arrival of a packet. After exiting the ISR, control will be passed to the Multiprocessing Server to process the packet. The Multiprocessing Server will call the get\_packet entry to obtain a packet buffer and the receive\_entry entry to copy the message into the buffer obtained.

## <span id="page-877-1"></span>30.3.1 INITIALIZATION

The INITIALIZATION component of the user-provided MPCI layer is called as part of the rtems\_initialize\_executive directive to initialize the MPCI layer and associated hardware. It is invoked immediately after all of the device drivers have been initialized. This component should be adhere to the following prototype:

```
1 rtems_mpci_entry user_mpci_initialization( void );
```

Operations on global objects cannot be performed until this component is invoked. The INI-TIALIZATION component is invoked only once in the life of any system. If the MPCI layer cannot be successfully initialized, the fatal error manager should be invoked by this routine.

One of the primary functions of the MPCI layer is to provide the executive with packet buffers. The INITIALIZATION routine must create and initialize a pool of packet buffers. There must be enough packet buffers so RTEMS can obtain one whenever needed.

# <span id="page-878-0"></span>30.3.2 GET\_PACKET

The GET\_PACKET component of the user-provided MPCI layer is called when RTEMS must obtain a packet buffer to send or broadcast a message. This component should be adhere to the following prototype:

```
1 rtems_mpci_entry user_mpci_get_packet(
2 rtems_packet_prefix **packet
3 );
```

where packet is the address of a pointer to a packet. This routine always succeeds and, upon return, packet will contain the address of a packet. If for any reason, a packet cannot be successfully obtained, then the fatal error manager should be invoked.

RTEMS has been optimized to avoid the need for obtaining a packet each time a message is sent or broadcast. For example, RTEMS sends response messages (RR) back to the originator in the same packet in which the request message (RQ) arrived.

## <span id="page-878-1"></span>30.3.3 RETURN\_PACKET

The RETURN\_PACKET component of the user-provided MPCI layer is called when RTEMS needs to release a packet to the free packet buffer pool. This component should be adhere to the following prototype:

```
1 rtems_mpci_entry user_mpci_return_packet(
2 rtems_packet_prefix *packet
3 );
```

where packet is the address of a packet. If the packet cannot be successfully returned, the fatal error manager should be invoked.

## <span id="page-878-2"></span>30.3.4 RECEIVE\_PACKET

The RECEIVE\_PACKET component of the user-provided MPCI layer is called when RTEMS needs to obtain a packet which has previously arrived. This component should be adhere to the following prototype:

```
1 rtems_mpci_entry user_mpci_receive_packet(
2 rtems_packet_prefix **packet
3 );
```

where packet is a pointer to the address of a packet to place the message from another node. If a message is available, then packet will contain the address of the message from another node. If no messages are available, this entry packet should contain NULL.

## <span id="page-879-2"></span><span id="page-879-0"></span>30.3.5 SEND\_PACKET

The SEND\_PACKET component of the user-provided MPCI layer is called when RTEMS needs to send a packet containing a message to another node. This component should be adhere to the following prototype:

```
1 rtems_mpci_entry user_mpci_send_packet(
2 uint32_t node,
3 rtems_packet_prefix **packet
4 );
```

where node is the node number of the destination and packet is the address of a packet which containing a message. If the packet cannot be successfully sent, the fatal error manager should be invoked.

If node is set to zero, the packet is to be broadcasted to all other nodes in the system. Although some MPCI layers will be built upon hardware which support a broadcast mechanism, others may be required to generate a copy of the packet for each node in the system.

Many MPCI layers use the packet\_length field of the rtems\_packet\_prefix portion of the packet to avoid sending unnecessary data. This is especially useful if the media connecting the nodes is relatively slow.

The to\_convert field of the rtems\_packet\_prefix portion of the packet indicates how much of the packet in 32-bit units may require conversion in a heterogeneous system.

## <span id="page-879-1"></span>30.3.6 Supporting Heterogeneous Environments

Developing an MPCI layer for a heterogeneous system requires a thorough understanding of the differences between the processors which comprise the system. One difficult problem is the varying data representation schemes used by different processor types. The most pervasive data representation problem is the order of the bytes which compose a data entity. Processors which place the least significant byte at the smallest address are classified as little endian processors. Little endian byte-ordering is shown below:

```
1 +---------------+----------------+---------------+----------------+
2 | | | | |
3 | Byte 3 | Byte 2 | Byte 1 | Byte 0 |
4 | | | | |
5 +---------------+----------------+---------------+----------------+
```

Conversely, processors which place the most significant byte at the smallest address are classified as big endian processors. Big endian byte-ordering is shown below:

```
1 +---------------+----------------+---------------+----------------+
2 | | | | |
3 | Byte 0 | Byte 1 | Byte 2 | Byte 3 |
4 | | | | |
5 +---------------+----------------+---------------+----------------+
```

Unfortunately, sharing a data structure between big endian and little endian processors requires translation into a common endian format. An application designer typically chooses the common endian format to minimize conversion overhead.

Another issue in the design of shared data structures is the alignment of data structure elements. Alignment is both processor and compiler implementation dependent. For example, some processors allow data elements to begin on any address boundary, while others impose restrictions. Common restrictions are that data elements must begin on either an even address or on a long word boundary. Violation of these restrictions may cause an exception or impose a performance penalty.

Other issues which commonly impact the design of shared data structures include the representation of floating point numbers, bit fields, decimal data, and character strings. In addition, the representation method for negative integers could be one's or two's complement. These factors combine to increase the complexity of designing and manipulating data structures shared between processors.

RTEMS addressed these issues in the design of the packets used to communicate between nodes. The RTEMS packet format is designed to allow the MPCI layer to perform all necessary conversion without burdening the developer with the details of the RTEMS packet format. As a result, the MPCI layer must be aware of the following:

- All packets must begin on a four byte boundary.
- Packets are composed of both RTEMS and application data. All RTEMS data is treated as 32-bit unsigned quantities and is in the first to\_convert 32-bit quantities of the packet. The to\_convert field is part of the rtems\_packet\_prefix portion of the packet.
- The RTEMS data component of the packet must be in native endian format. Endian conversion may be performed by either the sending or receiving MPCI layer.
- RTEMS makes no assumptions regarding the application data component of the packet.

# <span id="page-881-0"></span>30.4 Operations

## <span id="page-881-1"></span>30.4.1 Announcing a Packet

The rtems\_multiprocessing\_announce directive is called by the MPCI layer to inform RTEMS that a packet has arrived from another node. This directive can be called from an interrupt service routine or from within a polling routine.

# <span id="page-882-0"></span>30.5 Directives

This section details the directives of the Multiprocessing Manager. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

30.5. Directives 855

## <span id="page-883-1"></span><span id="page-883-0"></span>30.5.1 rtems\_multiprocessing\_announce()

Announces the arrival of a packet.

#### CALLING SEQUENCE:

```
1 void rtems_multiprocessing_announce( void );
```

### DESCRIPTION:

This directive informs RTEMS that a multiprocessing communications packet has arrived from another node. This directive is called by the user-provided MPCI, and is only used in multiprocessing configurations.

#### NOTES:

This directive is typically called from an *[ISR](#page-1067-0)*.

This directive does not generate activity on remote nodes.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within interrupt context.
- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may unblock a task. This may cause the calling task to be preempted.

CHAPTER

# **THIRTYONE**

# <span id="page-884-0"></span>SYMMETRIC MULTIPROCESSING (SMP)

# <span id="page-885-0"></span>31.1 Introduction

RTEMS Symmetric Multiprocessing (SMP) support is available on a subset of target architectures supported by RTEMS. Further on some target architectures, it is only available on a subset of BSPs. The user is advised to check the BSP specific documentation and RTEMS source code to verify the status of SMP support for a specific BSP. The following architectures have support for SMP:

- AArch64,
- ARMv7-A,
- i386,
- PowerPC,
- RISC-V, and
- SPARC.

## . **Warning**

SMP support is only available if RTEMS was built with the SMP build configuration option enabled.

RTEMS is supposed to be a real-time operating system. What does this mean in the context of SMP? The RTEMS interpretation of real-time on SMP is the support for *[Clustered Scheduling](#page-887-2)* (page 860) with priority based schedulers and adequate locking protocols. One aim is to enable a schedulability analysis under the sporadic task model [\[Bra11\]](#page-1082-7) [\[BW13\]](#page-1082-2).

# <span id="page-886-0"></span>31.2 Background

## <span id="page-886-1"></span>31.2.1 Application Configuration

By default, the maximum processor count is set to one in the application configuration. To enable SMP, the application configuration option *[CONFIGURE\\_MAXIMUM\\_PROCESSORS](#page-606-0)* (page 579) must be defined to a value greater than one. It is recommended to use the smallest value suitable for the application in order to save memory. Each processor needs an idle thread and interrupt stack for example.

The default scheduler for SMP applications supports up to 32 processors and is a global fixed priority scheduler, see also *[Clustered Scheduler Configuration](#page-756-0)* (page 729).

The following compile-time test can be used to check if the SMP support is available or not.

```
1 #include <rtems.h>
2
3 #ifdef RTEMS_SMP
4 #warning "SMP support is enabled"
5 #else
6 #warning "SMP support is disabled"
7 #endif
```

## <span id="page-886-2"></span>31.2.2 Examples

For example applications see [testsuites/smptests.](https://gitlab.rtems.org/rtems/rtos/rtems/-/blob/main/testsuites/smptests)

## <span id="page-886-3"></span>31.2.3 Uniprocessor versus SMP Parallelism

Uniprocessor systems have long been used in embedded systems. In this hardware model, there are some system execution characteristics which have long been taken for granted:

- one task executes at a time
- hardware events result in interrupts

There is no true parallelism. Even when interrupts appear to occur at the same time, they are processed in largely a serial fashion. This is true even when the interupt service routines are allowed to nest. From a tasking viewpoint, it is the responsibility of the real-time operatimg system to simulate parallelism by switching between tasks. These task switches occur in response to hardware interrupt events and explicit application events such as blocking for a resource or delaying.

With symmetric multiprocessing, the presence of multiple processors allows for true concurrency and provides for cost-effective performance improvements. Uniprocessors tend to increase performance by increasing clock speed and complexity. This tends to lead to hot, power hungry microprocessors which are poorly suited for many embedded applications.

The true concurrency is in sharp contrast to the single task and interrupt model of uniprocessor systems. This results in a fundamental change to uniprocessor system characteristics listed above. Developers are faced with a different set of characteristics which, in turn, break some existing assumptions and result in new challenges. In an SMP system with N processors, these are the new execution characteristics.

- N tasks execute in parallel
- hardware events result in interrupts

31.2. Background 859

<span id="page-887-3"></span>There is true parallelism with a task executing on each processor and the possibility of interrupts occurring on each processor. Thus in contrast to their being one task and one interrupt to consider on a uniprocessor, there are N tasks and potentially N simultaneous interrupts to consider on an SMP system.

This increase in hardware complexity and presence of true parallelism results in the application developer needing to be even more cautious about mutual exclusion and shared data access than in a uniprocessor embedded system. Race conditions that never or rarely happened when an application executed on a uniprocessor system, become much more likely due to multiple threads executing in parallel. On a uniprocessor system, these race conditions would only happen when a task switch occurred at just the wrong moment. Now there are N-1 tasks executing in parallel all the time and this results in many more opportunities for small windows in critical sections to be hit.

## <span id="page-887-0"></span>31.2.4 Task Affinity

RTEMS provides services to manipulate the affinity of a task. Affinity is used to specify the subset of processors in an SMP system on which a particular task can execute.

By default, tasks have an affinity which allows them to execute on any available processor.

Task affinity is a possible feature to be supported by SMP-aware schedulers. However, only a subset of the available schedulers support affinity. Although the behavior is scheduler specific, if the scheduler does not support affinity, it is likely to ignore all attempts to set affinity.

The scheduler with support for arbitary processor affinities uses a proof of concept implementation. See <https://gitlab.rtems.org/rtems/programs/gsoc/-/issues/34>

## <span id="page-887-1"></span>31.2.5 Task Migration

With more than one processor in the system tasks can migrate from one processor to another. There are four reasons why tasks migrate in RTEMS.

- The scheduler changes explicitly via rtems\_task\_set\_scheduler() or similar directives.
- The task processor affinity changes explicitly via rtems\_task\_set\_affinity() or similar directives.
- The task resumes execution after a blocking operation. On a priority based scheduler it will evict the lowest priority task currently assigned to a processor in the processor set managed by the scheduler instance.
- The task moves temporarily to another scheduler instance due to locking protocols like the *[Multiprocessor Resource Sharing Protocol \(MrsP\)](#page-57-0)* (page 30) or the *[O\(m\) Independence-](#page-57-1)[Preserving Protocol \(OMIP\)](#page-57-1)* (page 30).

Task migration should be avoided so that the working set of a task can stay on the most local cache level.

## <span id="page-887-2"></span>31.2.6 Clustered Scheduling

The scheduler is responsible to assign processors to some of the threads which are ready to execute. Trouble starts if more ready threads than processors exist at the same time. There are various rules how the processor assignment can be performed attempting to fulfill additional constraints or yield some overall system properties. As a matter of fact it is impossible to meet all requirements at the same time. The way a scheduler works distinguishes real-time operating systems from general purpose operating systems.

We have clustered scheduling in case the set of processors of a system is partitioned into nonempty pairwise-disjoint subsets of processors. These subsets are called clusters. Clusters with a cardinality of one are partitions. Each cluster is owned by exactly one scheduler instance. In case the cluster size equals the processor count, it is called global scheduling.

Modern SMP systems have multi-layer caches. An operating system which neglects cache constraints in the scheduler will not yield good performance. Real-time operating systems usually provide priority (fixed or job-level) based schedulers so that each of the highest priority threads is assigned to a processor. Priority based schedulers have difficulties in providing cache locality for threads and may suffer from excessive thread migrations [\[Bra11\]](#page-1082-7) [\[CMV14\]](#page-1083-10). Schedulers that use local run queues and some sort of load-balancing to improve the cache utilization may not fulfill global constraints [\[GCB13\]](#page-1083-11) and are more difficult to implement than one would normally expect [\[LLF+16\]](#page-1083-12).

Clustered scheduling was implemented for RTEMS SMP to best use the cache topology of a system and to keep the worst-case latencies under control. The low-level SMP locks use FIFO ordering. So, the worst-case run-time of operations increases with each processor involved. The scheduler configuration is quite flexible and done at link-time, see *[Clustered Scheduler Con](#page-756-0)[figuration](#page-756-0)* (page 729). It is possible to re-assign processors to schedulers during run-time via rtems\_scheduler\_add\_processor() and rtems\_scheduler\_remove\_processor(). The schedulers are implemented in an object-oriented fashion.

The problem is to provide synchronization primitives for inter-cluster synchronization (more than one cluster is involved in the synchronization process). In RTEMS there are currently some means available

- events,
- message queues,
- mutexes using the *[O\(m\) Independence-Preserving Protocol \(OMIP\)](#page-57-1)* (page 30),
- mutexes using the *[Multiprocessor Resource Sharing Protocol \(MrsP\)](#page-57-0)* (page 30), and
- binary and counting semaphores.

The clustered scheduling approach enables separation of functions with real-time requirements and functions that profit from fairness and high throughput provided the scheduler instances are fully decoupled and adequate inter-cluster synchronization primitives are used.

To set the scheduler of a task see rtems\_scheduler\_ident() and rtems\_task\_set\_scheduler().

## <span id="page-888-0"></span>31.2.7 OpenMP

OpenMP support for RTEMS is available via the GCC provided libgomp. There is libgomp support for RTEMS in the POSIX configuration of libgomp since GCC 4.9 (requires a Newlib snapshot after 2015-03-12). In GCC 6.1 or later (requires a Newlib snapshot after 2015-07- 30 for <sys/lock.h> provided self-contained synchronization objects) there is a specialized libgomp configuration for RTEMS which offers a significantly better performance compared to the POSIX configuration of libgomp. In addition application configurable thread pools for each scheduler instance are available in GCC 6.1 or later.

The run-time configuration of libgomp is done via environment variables documented in the [libgomp manual.](https://gcc.gnu.org/onlinedocs/libgomp/) The environment variables are evaluated in a constructor function which executes in the context of the first initialization task before the actual initialization task function is called (just like a global C++ constructor). To set application specific values, a higher priority constructor function must be used to set up the environment variables.

31.2. Background 861

```
1 #include <stdlib.h>
2 void __attribute__((constructor(1000))) config_libgomp( void )
3 {
4 setenv( "OMP_DISPLAY_ENV", "VERBOSE", 1 );
5 setenv( "GOMP_SPINCOUNT", "30000", 1 );
6 setenv( "GOMP_RTEMS_THREAD_POOLS", "1$2@SCHD", 1 );
7 }
```

The environment variable GOMP\_RTEMS\_THREAD\_POOLS is RTEMS-specific. It determines the thread pools for each scheduler instance. The format for GOMP\_RTEMS\_THREAD\_POOLS is a list of optional <thread-pool-count>[\$<priority>]@<scheduler-name> configurations separated by : where:

- <thread-pool-count> is the thread pool count for this scheduler instance.
- \$<priority> is an optional priority for the worker threads of a thread pool according to pthread\_setschedparam. In case a priority value is omitted, then a worker thread will inherit the priority of the OpenMP master thread that created it. The priority of the worker thread is not changed by libgomp after creation, even if a new OpenMP master thread using the worker has a different priority.
- @<scheduler-name> is the scheduler instance name according to the RTEMS application configuration.

In case no thread pool configuration is specified for a scheduler instance, then each OpenMP master thread of this scheduler instance will use its own dynamically allocated thread pool. To limit the worker thread count of the thread pools, each OpenMP master thread must call omp\_set\_num\_threads.

Lets suppose we have three scheduler instances IO, WRK0, and WRK1 with GOMP\_RTEMS\_THREAD\_POOLS set to "1@WRK0:3\$4@WRK1". Then there are no thread pool restrictions for scheduler instance IO. In the scheduler instance WRK0 there is one thread pool available. Since no priority is specified for this scheduler instance, the worker thread inherits the priority of the OpenMP master thread that created it. In the scheduler instance WRK1 there are three thread pools available and their worker threads run at priority four.

## <span id="page-889-0"></span>31.2.8 Atomic Operations

There is no public RTEMS API for atomic operations. It is recommended to use the standard C [<stdatomic.h>](https://en.cppreference.com/w/c/atomic) or C++ [<atomic>](https://en.cppreference.com/w/cpp/atomic/atomic) APIs in applications.

# <span id="page-890-0"></span>31.3 Application Issues

Most operating system services provided by the uniprocessor RTEMS are available in SMP configurations as well. However, applications designed for an uniprocessor environment may need some changes to correctly run in an SMP configuration.

As discussed earlier, SMP systems have opportunities for true parallelism which was not possible on uniprocessor systems. Consequently, multiple techniques that provided adequate critical sections on uniprocessor systems are unsafe on SMP systems. In this section, some of these unsafe techniques will be discussed.

In general, applications must use proper operating system provided mutual exclusion mechanisms to ensure correct behavior.

## <span id="page-890-1"></span>31.3.1 Task variables

Task variables are ordinary global variables with a dedicated value for each thread. During a context switch from the executing thread to the heir thread, the value of each task variable is saved to the thread control block of the executing thread and restored from the thread control block of the heir thread. This is inherently broken if more than one executing thread exists. Alternatives to task variables are POSIX keys and *[TLS](#page-1077-2)*. All use cases of task variables in the RTEMS code base were replaced with alternatives. The task variable API has been removed in RTEMS 5.1.

## <span id="page-890-2"></span>31.3.2 Highest Priority Thread Never Walks Alone

On a uniprocessor system, it is safe to assume that when the highest priority task in an application executes, it will execute without being preempted until it voluntarily blocks. Interrupts may occur while it is executing, but there will be no context switch to another task unless the highest priority task voluntarily initiates it.

Given the assumption that no other tasks will have their execution interleaved with the highest priority task, it is possible for this task to be constructed such that it does not need to acquire a mutex for protected access to shared data.

In an SMP system, it cannot be assumed there will never be a single task executing. It should be assumed that every processor is executing another application task. Further, those tasks will be ones which would not have been executed in a uniprocessor configuration and should be assumed to have data synchronization conflicts with what was formerly the highest priority task which executed without conflict.

## <span id="page-890-3"></span>31.3.3 Disabling of Thread Preemption

A thread which disables preemption prevents that a higher priority thread gets hold of its processor involuntarily. In uniprocessor configurations, this can be used to ensure mutual exclusion at thread level. In SMP configurations, however, more than one executing thread may exist. Thus, it is impossible to ensure mutual exclusion using this mechanism. In order to prevent that applications using preemption for this purpose, would show inappropriate behaviour, this feature is disabled in SMP configurations and its use would case run-time errors.

## <span id="page-891-0"></span>31.3.4 Disabling of Interrupts

A low overhead means that ensures mutual exclusion in uniprocessor configurations is the disabling of interrupts around a critical section. This is commonly used in device driver code. In SMP configurations, however, disabling the interrupts on one processor has no effect on other processors. So, this is insufficient to ensure system-wide mutual exclusion. The macros

- rtems\_interrupt\_disable(),
- rtems\_interrupt\_enable(), and
- rtems\_interrupt\_flash().

are disabled in SMP configurations and its use will cause compile-time warnings and link-time errors. In the unlikely case that interrupts must be disabled on the current processor, the

- rtems\_interrupt\_local\_disable(), and
- rtems\_interrupt\_local\_enable().

macros are now available in all configurations.

Since disabling of interrupts is insufficient to ensure system-wide mutual exclusion on SMP a new low-level synchronization primitive was added â€“ interrupt locks. The interrupt locks are a simple API layer on top of the SMP locks used for low-level synchronization in the operating system core. Currently, they are implemented as a ticket lock. In uniprocessor configurations, they degenerate to simple interrupt disable/enable sequences by means of the C pre-processor. It is disallowed to acquire a single interrupt lock in a nested way. This will result in an infinite loop with interrupts disabled. While converting legacy code to interrupt locks, care must be taken to avoid this situation to happen.

```
1 #include <rtems.h>
2
3 void legacy_code_with_interrupt_disable_enable( void )
4 {
5 rtems_interrupt_level level;
6
7 rtems_interrupt_disable( level );
8 /* Critical section */
9 rtems_interrupt_enable( level );
10 }
11
12 RTEMS_INTERRUPT_LOCK_DEFINE( static, lock, "Name" )
13
14 void smp_ready_code_with_interrupt_lock( void )
15 {
16 rtems_interrupt_lock_context lock_context;
17
18 rtems_interrupt_lock_acquire( &lock, &lock_context );
19 /* Critical section */
20 rtems_interrupt_lock_release( &lock, &lock_context );
21 }
```

An alternative to the RTEMS-specific interrupt locks are POSIX spinlocks. The pthread\_spinlock\_t is defined as a self-contained object, e.g. the user must provide the storage for this synchronization object.

```
1 #include <assert.h>
2 #include <pthread.h>
3
4 pthread_spinlock_t lock;
5
6 void smp_ready_code_with_posix_spinlock( void )
7 {
8 int error;
9
10 error = pthread_spin_lock( &lock );
11 assert( error == 0 );
12 /* Critical section */
13 error = pthread_spin_unlock( &lock );
14 assert( error == 0 );
15 }
```

In contrast to POSIX spinlock implementation on Linux or FreeBSD, it is not allowed to call blocking operating system services inside the critical section. A recursive lock attempt is a severe usage error resulting in an infinite loop with interrupts disabled. Nesting of different locks is allowed. The user must ensure that no deadlock can occur. As a non-portable feature the locks are zero-initialized, e.g. statically initialized global locks reside in the .bss section and there is no need to call pthread\_spin\_init().

## <span id="page-892-0"></span>31.3.5 Interrupt Service Routines Execute in Parallel With Threads

On a machine with more than one processor, interrupt service routines (this includes timer service routines installed via rtems\_timer\_fire\_after()) and threads can execute in parallel. Interrupt service routines must take this into account and use proper locking mechanisms to protect critical sections from interference by threads (interrupt locks or POSIX spinlocks). This likely requires code modifications in legacy device drivers.

## <span id="page-892-1"></span>31.3.6 Timers Do Not Stop Immediately

Timer service routines run in the context of the clock interrupt. On uniprocessor configurations, it is sufficient to disable interrupts and remove a timer from the set of active timers to stop it. In SMP configurations, however, the timer service routine may already run and wait on an SMP lock owned by the thread which is about to stop the timer. This opens the door to subtle synchronization issues. During destruction of objects, special care must be taken to ensure that timer service routines cannot access (partly or fully) destroyed objects.

## <span id="page-892-2"></span>31.3.7 False Sharing of Cache Lines Due to Objects Table

The Classic API and most POSIX API objects are indirectly accessed via an object identifier. The user-level functions validate the object identifier and map it to the actual object structure which resides in a global objects table for each object class. So, unrelated objects are packed together in a table. This may result in false sharing of cache lines. The effect of false sharing of cache lines can be observed with the [TMFINE 1](https://gitlab.rtems.org/rtems/rtos/rtems/-/blob/main/testsuites/tmtests/tmfine01) test program on a suitable platform, e.g. QorIQ T4240. High-performance SMP applications need full control of the object storage [\[Dre07\]](#page-1083-8). Therefore, self-contained synchronization objects are now available for RTEMS.

# <span id="page-893-0"></span>31.4 Implementation Details

This section covers some implementation details of the RTEMS SMP support.

### <span id="page-893-1"></span>31.4.1 Low-Level Synchronization

All low-level synchronization primitives are implemented using C11 atomic operations, so no target-specific hand-written assembler code is necessary. Four synchronization primitives are currently available

- ticket locks (mutual exclusion),
- *MCS* locks (mutual exclusion),
- barriers, implemented as a sense barrier, and
- sequence locks [Boe12].

A vital requirement for low-level mutual exclusion is *FIFO* fairness since we are interested in a predictable system and not maximum throughput. With this requirement, there are only few options to resolve this problem. For reasons of simplicity, the ticket lock algorithm was chosen to implement the SMP locks. However, the API is capable to support MCS locks, which may be interesting in the future for systems with a processor count in the range of 32 or more, e.g. *NUMA*, many-core systems.

The test program SMPLOCK 1 can be used to gather performance and fairness data for several scenarios. The SMP lock performance and fairness measured on the QorIQ T4240 follows as an example. This chip contains three L2 caches. Each L2 cache is shared by eight processors.

![](_page_893_Figure_12.jpeg)

![](_page_894_Figure_2.jpeg)

#### <span id="page-894-0"></span>31.4.2 Internal Locking

In SMP configurations, the operating system uses non-recursive SMP locks for low-level mutual exclusion. The locking domains are roughly

- a particular data structure,
- the thread queue operations,
- the thread state changes, and
- the scheduler operations.

For a good average-case performance it is vital that every high-level synchronization object, e.g. mutex, has its own SMP lock. In the average-case, only this SMP lock should be involved to carry out a specific operation, e.g. obtain/release a mutex. In general, the high-level synchronization objects have a thread queue embedded and use its SMP lock.

In case a thread must block on a thread queue, then things get complicated. The executing thread first acquires the SMP lock of the thread queue and then figures out that it needs to block. The procedure to block the thread on this particular thread queue involves state changes of the thread itself and for this thread-specific SMP locks must be used.

In order to determine if a thread is blocked on a thread queue or not thread-specific SMP locks must be used. A thread priority change must propagate this to the thread queue (possibly recursively). Care must be taken to not have a lock order reversal between thread queue and thread-specific SMP locks.

Each scheduler instance has its own SMP lock. For the scheduler helping protocol multiple scheduler instances may be in charge of a thread. It is not possible to acquire two scheduler instance SMP locks at the same time, otherwise deadlocks would happen. A thread-specific SMP lock is used to synchronize the thread data shared by different scheduler instances.

The thread state SMP lock protects various things, e.g. the thread state, join operations, signals, post-switch actions, the home scheduler instance, etc.

## <span id="page-895-0"></span>31.4.3 Profiling

To identify the bottlenecks in the system, support for profiling of low-level synchronization is optionally available. The profiling support is an RTEMS build time configuration option and is implemented with an acceptable overhead, even for production systems. A low-overhead counter for short time intervals must be provided by the hardware.

Profiling reports are generated in XML for most test programs of the RTEMS testsuite (more than 500 test programs). This gives a good sample set for statistics. For example the maximum thread dispatch disable time, the maximum interrupt latency or lock contention can be determined.

```
1 <ProfilingReport name="SMPMIGRATION 1">
2 <PerCPUProfilingReport processorIndex="0">
3 <MaxThreadDispatchDisabledTime unit="ns">36636</MaxThreadDispatchDisabledTime>
4 <MeanThreadDispatchDisabledTime unit="ns">5065</
  Ë“â†’MeanThreadDispatchDisabledTime>
5 <TotalThreadDispatchDisabledTime unit="ns">3846635988
6 </TotalThreadDispatchDisabledTime>
7 <ThreadDispatchDisabledCount>759395</ThreadDispatchDisabledCount>
8 <MaxInterruptDelay unit="ns">8772</MaxInterruptDelay>
9 <MaxInterruptTime unit="ns">13668</MaxInterruptTime>
10 <MeanInterruptTime unit="ns">6221</MeanInterruptTime>
11 <TotalInterruptTime unit="ns">6757072</TotalInterruptTime>
12 <InterruptCount>1086</InterruptCount>
13 </PerCPUProfilingReport>
14 <PerCPUProfilingReport processorIndex="1">
15 <MaxThreadDispatchDisabledTime unit="ns">39408</MaxThreadDispatchDisabledTime>
16 <MeanThreadDispatchDisabledTime unit="ns">5060</
  Ë“â†’MeanThreadDispatchDisabledTime>
17 <TotalThreadDispatchDisabledTime unit="ns">3842749508
18 </TotalThreadDispatchDisabledTime>
19 <ThreadDispatchDisabledCount>759391</ThreadDispatchDisabledCount>
20 <MaxInterruptDelay unit="ns">8412</MaxInterruptDelay>
21 <MaxInterruptTime unit="ns">15868</MaxInterruptTime>
22 <MeanInterruptTime unit="ns">3525</MeanInterruptTime>
23 <TotalInterruptTime unit="ns">3814476</TotalInterruptTime>
24 <InterruptCount>1082</InterruptCount>
25 </PerCPUProfilingReport>
26 <!-- more reports omitted --->
27 <SMPLockProfilingReport name="Scheduler">
28 <MaxAcquireTime unit="ns">7092</MaxAcquireTime>
29 <MaxSectionTime unit="ns">10984</MaxSectionTime>
30 <MeanAcquireTime unit="ns">2320</MeanAcquireTime>
31 <MeanSectionTime unit="ns">199</MeanSectionTime>
32 <TotalAcquireTime unit="ns">3523939244</TotalAcquireTime>
33 <TotalSectionTime unit="ns">302545596</TotalSectionTime>
34 <UsageCount>1518758</UsageCount>
35 <ContentionCount initialQueueLength="0">759399</ContentionCount>
36 <ContentionCount initialQueueLength="1">759359</ContentionCount>
37 <ContentionCount initialQueueLength="2">0</ContentionCount>
38 <ContentionCount initialQueueLength="3">0</ContentionCount>
39 </SMPLockProfilingReport>
```

(continues on next page)

(continued from previous page)

<sup>40</sup> **</ProfilingReport>**

## <span id="page-896-0"></span>31.4.4 Scheduler Helping Protocol

The scheduler provides a helping protocol to support locking protocols like the *[O\(m\)](#page-57-1) [Independence-Preserving Protocol \(OMIP\)](#page-57-1)* (page 30) or the *[Multiprocessor Resource Sharing Pro](#page-57-0)[tocol \(MrsP\)](#page-57-0)* (page 30). Each thread has a scheduler node for each scheduler instance in the system which are located in its *[TCB](#page-1077-1)*. A thread has exactly one home scheduler instance which is set during thread creation. The home scheduler instance can be changed with rtems\_task\_set\_scheduler(). Due to the locking protocols a thread may gain access to scheduler nodes of other scheduler instances. This allows the thread to temporarily migrate to another scheduler instance in case of preemption.

The scheduler infrastructure is based on an object-oriented design. The scheduler operations for a thread are defined as virtual functions. For the scheduler helping protocol the following operations must be implemented by an SMP-aware scheduler

- ask a scheduler node for help,
- reconsider the help request of a scheduler node,
- withdraw a schedule node.

All currently available SMP-aware schedulers use a framework which is customized via inline functions. This eases the implementation of scheduler variants. Up to now, only priority-based schedulers are implemented.

In case a thread is allowed to use more than one scheduler node it will ask these nodes for help

- in case of preemption, or
- an unblock did not schedule the thread, or
- a yield was successful.

The actual ask for help scheduler operations are carried out as a side-effect of the thread dispatch procedure. Once a need for help is recognized, a help request is registered in one of the processors related to the thread and a thread dispatch is issued. This indirection leads to a better decoupling of scheduler instances. Unrelated processors are not burdened with extra work for threads which participate in resource sharing. Each ask for help operation indicates if it could help or not. The procedure stops after the first successful ask for help. Unsuccessful ask for help operations will register this need in the scheduler context.

After a thread dispatch the reconsider help request operation is used to clean up stale help registrations in the scheduler contexts.

The withdraw operation takes away scheduler nodes once the thread is no longer allowed to use them, e.g. it released a mutex. The availability of scheduler nodes for a thread is controlled by the thread queues.

## <span id="page-896-1"></span>31.4.5 Thread Dispatch Details

This section gives background information to developers interested in the interrupt latencies introduced by thread dispatching. A thread dispatch consists of all work which must be done to stop the currently executing thread on a processor and hand over this processor to an heir thread.

In SMP systems, scheduling decisions on one processor must be propagated to other processors through inter-processor interrupts. A thread dispatch which must be carried out on another processor does not happen instantaneously. Thus, several thread dispatch requests might be in the air and it is possible that some of them may be out of date before the corresponding processor has time to deal with them. The thread dispatch mechanism uses three per-processor variables,

- the executing thread,
- the heir thread, and
- a boolean flag indicating if a thread dispatch is necessary or not.

Updates of the heir thread are done via a normal store operation. The thread dispatch necessary indicator of another processor is set as a side-effect of an inter-processor interrupt. So, this change notification works without the use of locks. The thread context is protected by a *[TTAS](#page-1078-3)* lock embedded in the context to ensure that it is used on at most one processor at a time. Normally, only thread-specific or per-processor locks are used during a thread dispatch. This implementation turned out to be quite efficient and no lock contention was observed in the testsuite. The heavy-weight thread dispatch sequence is only entered in case the thread dispatch indicator is set.

The context-switch is performed with interrupts enabled. During the transition from the executing to the heir thread neither the stack of the executing nor the heir thread must be used during interrupt processing. For this purpose a temporary per-processor stack is set up which may be used by the interrupt prologue before the stack is switched to the interrupt stack.

## <span id="page-897-0"></span>31.4.6 Per-Processor Data

RTEMS provides two means for per-processor data:

- 1. Per-processor data which is used by RTEMS itself is contained in the Per\_CPU\_Control structure. The application configuration via <rtems/confdefs.h> creates a table of these structures (\_Per\_CPU\_Information[]). The table is dimensioned according to the count of configured processors (*[CONFIGURE\\_MAXIMUM\\_PROCESSORS](#page-606-0)* (page 579)).
- 2. For low level support libraries an API for statically allocated per-processor data is available via [<rtems/score/percpudata.h>.](https://gitlab.rtems.org/rtems/rtos/rtems/-/blob/main/cpukit/include/rtems/score/percpudata.h) This API is not intended for general application use. Please ask on the development mailing list in case you want to use it.

## <span id="page-897-1"></span>31.4.7 Thread Pinning

Thread pinning ensures that a thread is only dispatched to the processor on which it is pinned. It may be used to access per-processor data structures in critical sections with enabled thread dispatching, e.g. a pinned thread is allowed to block. The \_Thread\_Pin() operation will pin the executing thread to its current processor. A thread may be pinned recursively, the last unpin request via \_Thread\_Unpin() revokes the pinning.

Thread pinning should be used only for short critical sections and not all the time. Thread pinning is a very low overhead operation in case the thread is not preempted during the pinning. A preemption will result in scheduler operations to ensure that the thread executes only on its pinned processor. Thread pinning must be used with care, since it prevents help through the locking protocols. This makes the *[OMIP](#page-57-1)* (page 30) and *[MrsP](#page-57-0)* (page 30) locking protocols ineffective if pinned threads are involved.

<span id="page-898-0"></span>The thread pinning is not intended for general application use. Please ask on the development mailing list in case you want to use it.

CHAPTER

# **THIRTYTWO**

# <span id="page-900-0"></span>PCI LIBRARY

# <span id="page-901-0"></span>32.1 Introduction

The Peripheral Component Interconnect (PCI) bus is a very common computer bus architecture that is found in almost every PC today. The PCI bus is normally located at the motherboard where some PCI devices are soldered directly onto the PCB and expansion slots allows the user to add custom devices easily. There is a wide range of PCI hardware available implementing all sorts of interfaces and functions.

This section describes the PCI Library available in RTEMS used to access the PCI bus in a portable way across computer architectures supported by RTEMS.

The PCI Library aims to be compatible with PCI 2.3 with a couple of limitations, for example there is no support for hot-plugging, 64-bit memory space and cardbus bridges.

In order to support different architectures and with small foot-print embedded systems in mind the PCI Library offers four different configuration options listed below. It is selected during compile time by defining the appropriate macros in confdefs.h. It is also possible to enable PCI\_LIB\_NONE (No Configuration) which can be used for debuging PCI access functions.

- Auto Configuration (Plug & Play)
- Read Configuration (read BIOS or boot loader configuration)
- Static Configuration (write user defined configuration)
- Peripheral Configuration (no access to cfg-space)

# <span id="page-902-0"></span>32.2 Background

The PCI bus is constructed in a way where on-board devices and devices in expansion slots can be automatically found (probed) and configured using Plug & Play completely implemented in software. The bus is set up once during boot up. The Plug & Play information can be read and written from PCI configuration space. A PCI device is identified in configuration space by a unique bus, slot and function number. Each PCI slot can have up to 8 functions and interface to another PCI sub-bus by implementing a PCI-to-PCI bridge according to the PCI Bridge Architecture specification.

Using the unique [bus:slot:func] any device can be configured regardless of how PCI is currently set up as long as all PCI buses are enumerated correctly. The enumeration is done during probing, all bridges are given a bus number in order for the bridges to respond to accesses from both directions. The PCI library can assign address ranges to which a PCI device should respond using Plug & Play technique or a static user defined configuration. After the configuration has been performed the PCI device drivers can find devices by the read-only PCI Class type, Vendor ID and Device ID information found in configuration space for each device.

In some systems there is a boot loader or BIOS which have already configured all PCI devices, but on embedded targets it is quite common that there is no BIOS or boot loader, thus RTEMS must configure the PCI bus. Only the PCI host may do configuration space access, the host driver or BSP is responsible to translate the [bus:slot:func] into a valid PCI configuration space access.

If the target is not a host, but a peripheral, configuration space can not be accessed, the peripheral is set up by the host during start up. In complex embedded PCI systems the peripheral may need to access other PCI boards than the host. In such systems a custom (static) configuration of both the host and peripheral may be a convenient solution.

The PCI bus defines four interrupt signals INTA#. . . INTD#. The interrupt signals must be mapped into a system interrupt/vector, it is up to the BSP or host driver to know the mapping, however the BIOS or boot loader may use the 8-bit read/write "Interrupt Line" register to pass the knowledge along to the OS.

The PCI standard defines and recommends that the backplane route the interupt lines in a systematic way, however in standard there is no such requirement. The PCI Auto Configuration Library implements the recommended way of routing which is very common but it is also supported to some extent to override the interrupt routing from the BSP or Host Bridge driver using the configuration structure.

## <span id="page-902-1"></span>32.2.1 Software Components

The PCI library is located in cpukit/libpci, it consists of different parts:

- PCI Host bridge driver interface
- Configuration routines
- Access (Configuration, I/O and Memory space) routines
- Interrupt routines (implemented by BSP)
- Print routines
- Static/peripheral configuration creation
- PCI shell command

32.2. Background 875

## <span id="page-903-0"></span>32.2.2 PCI Configuration

During start up the PCI bus must be configured in order for host and peripherals to access one another using Memory or I/O accesses and that interrupts are properly handled. Three different spaces are defined and mapped separately:

- 1. I/O space (IO)
- 2. non-prefetchable Memory space (MEMIO)
- 3. prefetchable Memory space (MEM)

Regions of the same type (I/O or Memory) may not overlap which is guaranteed by the software. MEM regions may be mapped into MEMIO regions, but MEMIO regions can not be mapped into MEM, for that could lead to prefetching of registers. The interrupt pin which a board is driving can be read out from PCI configuration space, however it is up to software to know how interrupt signals are routed between PCI-to-PCI bridges and how PCI INT[A. . . D]# pins are mapped to system IRQ. In systems where previous software (boot loader or BIOS) has already set up this the configuration is overwritten or simply read out.

In order to support different configuration methods the following configuration libraries are selectable by the user:

- Auto Configuration (run Plug & Play software)
- Read Configuration (relies on a boot loader or BIOS)
- Static Configuration (write user defined setup, no Plug & Play)
- Peripheral Configuration (user defined setup, no access to configuration space)

A host driver can be made to support all three configuration methods, or any combination. It may be defined by the BSP which approach is used.

The configuration software is called from the PCI driver (pci\_config\_init()).

Regardless of configuration method a PCI device tree is created in RAM during initialization, the tree can be accessed to find devices and resources without accessing configuration space later on. The user is responsible to create the device tree at compile time when using the static/peripheral method.

#### <span id="page-903-1"></span>32.2.2.1 RTEMS Configuration selection

The active configuration method can be selected at compile time in the same way as other project parameters by including rtems/confdefs.h and setting

- CONFIGURE\_INIT
- RTEMS\_PCI\_CONFIG\_LIB
- CONFIGURE\_PCI\_LIB = PCI\_LIB\_(AUTO,STATIC,READ,PERIPHERAL)

See the RTEMS configuration section how to setup the PCI library.

## <span id="page-903-2"></span>32.2.2.2 Auto Configuration

The auto configuration software enumerates PCI buses and initializes all PCI devices found using Plug & Play. The auto configuration software requires that a configuration setup has been registered by the driver or BSP in order to setup the I/O and Memory regions at the correct address ranges. PCI interrupt pins can optionally be routed over PCI-to-PCI bridges and mapped to a system interrupt number. BAR resources are sorted by size and required alignment, unused "dead" space may be created when PCI bridges are present due to the PCI bridge window size does not equal the alignment. To cope with that resources are reordered to fit smaller BARs into the dead space to minimize the PCI space required. If a BAR or ROM register can not be allocated a PCI address region (due to too few resources available) the register will be given the value of pci\_invalid\_address which defaults to 0.

The auto configuration routines support:

- PCI 2.3
- Little and big endian PCI bus
- one I/O 16 or 32-bit range (IO)
- memory space (MEMIO)
- prefetchable memory space (MEM), if not present MEM will be mapped into MEMIO
- multiple PCI buses PCI-to-PCI bridges
- standard BARs, PCI-to-PCI bridge BARs, ROM BARs
- Interrupt routing over bridges
- Interrupt pin to system interrupt mapping

## Not supported:

- hot-pluggable devices
- Cardbus bridges
- 64-bit memory space
- 16-bit and 32-bit I/O address ranges at the same time

In PCI 2.3 there may exist I/O BARs that must be located at the low 64kBytes address range, in order to support this the host driver or BSP must make sure that I/O addresses region is within this region.

#### <span id="page-904-0"></span>32.2.2.3 Read Configuration

When a BIOS or boot loader already has setup the PCI bus the configuration can be read directly from the PCI resource registers and buses are already enumerated, this is a much simpler approach than configuring PCI ourselves. The PCI device tree is automatically created based on the current configuration and devices present. After initialization is done there is no difference between the auto or read configuration approaches.

#### <span id="page-904-1"></span>32.2.2.4 Static Configuration

To support custom configurations and small-footprint PCI systems, the user may provide the PCI device tree which contains the current configuration. The PCI buses are enumerated and all resources are written to PCI devices during initialization. When this approach is selected PCI boards must be located at the same slots every time and devices can not be removed or added, Plug & Play is not performed. Boards of the same type may of course be exchanged.

The user can create a configuration by calling pci\_cfg\_print() on a running system that has had PCI setup by the auto or read configuration routines, it can be called from the PCI shell command. The user must provide the PCI device tree named pci\_hb.

32.2. Background 877

### <span id="page-905-0"></span>32.2.2.5 Peripheral Configuration

On systems where a peripheral PCI device needs to access other PCI devices than the host the peripheral configuration approach may be handy. Most PCI devices answers on the PCI host's requests and start DMA accesses into the Hosts memory, however in some complex systems PCI devices may want to access other devices on the same bus or at another PCI bus.

A PCI peripheral is not allowed to do PCI configuration cycles, which means that it must either rely on the host to give it the addresses it needs, or that the addresses are predefined.

This configuration approach is very similar to the static option, however the configuration is never written to PCI bus, instead it is only used for drivers to find PCI devices and resources using the same PCI API as for the host

## <span id="page-905-1"></span>32.2.3 PCI Access

The PCI access routines are low-level routines provided for drivers, configuration software, etc. in order to access different regions in a way not dependent upon the host driver, BSP or platform.

- PCI configuration space
- PCI I/O space
- Registers over PCI memory space
- Translate PCI address into CPU accessible address and vice versa

By using the access routines drivers can be made portable over different architectures. The access routines take the architecture endianness into consideration and let the host driver or BSP implement I/O space and configuration space access.

Some non-standard hardware may also define the PCI bus big-endian, for example the LEON2 AT697 PCI host bridge and some LEON3 systems may be configured that way. It is up to the BSP to set the appropriate PCI endianness on compile time (BSP\_PCI\_BIG\_ENDIAN) in order for inline macros to be correctly defined. Another possibility is to use the function pointers defined by the access layer to implement drivers that support "run-time endianness detection".

#### <span id="page-905-2"></span>32.2.3.1 Configuration space

Configuration space is accessed using the routines listed below. The pci\_dev\_t type is used to specify a specific PCI bus, device and function. It is up to the host driver or BSP to create a valid access to the requested PCI slot. Requests made to slots that are not supported by hardware should result in PCISTS\_MSTABRT and/or data must be ignored (writes) or 0xFFFFFFFF is always returned (reads).

```
1 /* Configuration Space Access Read Routines */
2 extern int pci_cfg_r8(pci_dev_t dev, int ofs, uint8_t *data);
3 extern int pci_cfg_r16(pci_dev_t dev, int ofs, uint16_t *data);
4 extern int pci_cfg_r32(pci_dev_t dev, int ofs, uint32_t *data);
5
6 /* Configuration Space Access Write Routines */
7 extern int pci_cfg_w8(pci_dev_t dev, int ofs, uint8_t data);
8 extern int pci_cfg_w16(pci_dev_t dev, int ofs, uint16_t data);
9 extern int pci_cfg_w32(pci_dev_t dev, int ofs, uint32_t data);
```

## <span id="page-906-0"></span>32.2.3.2 I/O space

The BSP or driver provide special routines in order to access I/O space. Some architectures have a special instruction accessing I/O space, others have it mapped into a "PCI I/O window" in the standard address space accessed by the CPU. The window size may vary and must be taken into consideration by the host driver. The below routines must be used to access I/O space. The address given to the functions is not the PCI I/O addresses, the caller must have translated PCI I/O addresses (available in the PCI BARs) into a BSP or host driver custom address, see [Access functions] for how addresses are translated.

```
1 /* Read a register over PCI I/O Space */
2 extern uint8_t pci_io_r8(uint32_t adr);
3 extern uint16_t pci_io_r16(uint32_t adr);
4 extern uint32_t pci_io_r32(uint32_t adr);
5
6 /* Write a register over PCI I/O Space */
7 extern void pci_io_w8(uint32_t adr, uint8_t data);
8 extern void pci_io_w16(uint32_t adr, uint16_t data);
9 extern void pci_io_w32(uint32_t adr, uint32_t data);
```

#### <span id="page-906-1"></span>32.2.3.3 Registers over Memory space

PCI host bridge hardware normally swap data accesses into the endianness of the host architecture in order to lower the load of the CPU, peripherals can do DMA without swapping. However, the host controller can not separate a standard memory access from a memory access to a register, registers may be mapped into memory space. This leads to register content being swapped, which must be swapped back. The below routines makes it possible to access registers over PCI memory space in a portable way on different architectures, the BSP or architecture must provide necessary functions in order to implement this.

```
1 static inline uint16_t pci_ld_le16(volatile uint16_t *addr);
2 static inline void pci_st_le16(volatile uint16_t *addr, uint16_t val);
3 static inline uint32_t pci_ld_le32(volatile uint32_t *addr);
4 static inline void pci_st_le32(volatile uint32_t *addr, uint32_t val);
5 static inline uint16_t pci_ld_be16(volatile uint16_t *addr);
6 static inline void pci_st_be16(volatile uint16_t *addr, uint16_t val);
7 static inline uint32_t pci_ld_be32(volatile uint32_t *addr);
8 static inline void pci_st_be32(volatile uint32_t *addr, uint32_t val);
```

In order to support non-standard big-endian PCI bus the above pci\_\* functions is required, pci\_ld\_le16 != ld\_le16 on big endian PCI buses.

## <span id="page-906-2"></span>32.2.3.4 Access functions

The PCI Access Library can provide device drivers with function pointers executing the above Configuration, I/O and Memory space accesses. The functions have the same arguments and return values as the above functions.

The pci\_access\_func() function defined below can be used to get a function pointer of a specific access type.

```
1 /* Get Read/Write function for accessing a register over PCI Memory Space
2 * (non-inline functions).
                                                                       (continues on next page)
```

32.2. Background 879

(continued from previous page)

```
3 *
4 * Arguments
5 * wr 0(Read), 1(Write)
6 * size 1(Byte), 2(Word), 4(Double Word)
7 * func Where function pointer will be stored
8 * endian PCI_LITTLE_ENDIAN or PCI_BIG_ENDIAN
9 * type 1(I/O), 3(REG over MEM), 4(CFG)
10 *
11 * Return
12 * 0 Found function
13 * others No such function defined by host driver or BSP
14 */
15 int pci_access_func(int wr, int size, void **func, int endian, int type);
```

PCI device drivers may be written to support run-time detection of endianess, this is mosly for debugging or for development systems. When the product is finally deployed macros switch to using the inline functions instead which have been configured for the correct endianness.

#### <span id="page-907-0"></span>32.2.3.5 PCI address translation

When PCI addresses, both I/O and memory space, is not mapped 1:1 address translation before access is needed. If drivers read the PCI resources directly using configuration space routines or in the device tree, the addresses given are PCI addresses. The below functions can be used to translate PCI addresses into CPU accessible addresses or vice versa, translation may be different for different PCI spaces/regions.

```
1 /* Translate PCI address into CPU accessible address */
2 static inline int pci_pci2cpu(uint32_t *address, int type);
3
4 /* Translate CPU accessible address into PCI address (for DMA) */
5 static inline int pci_cpu2pci(uint32_t *address, int type);
```

## <span id="page-907-1"></span>32.2.4 PCI Interrupt

The PCI specification defines four different interrupt lines INTA#. . . INTD#, the interrupts are low level sensitive which make it possible to support multiple interrupt sources on the same interrupt line. Since the lines are level sensitive the interrupt sources must be acknowledged before clearing the interrupt contoller, or the interrupt controller must be masked. The BSP must provide a routine for clearing/acknowledging the interrupt controller, it is up to the interrupt service routine to acknowledge the interrupt source.

The PCI Library relies on the BSP for implementing shared interrupt handling through the BSP\_PCI\_shared\_interrupt\_\* functions/macros, they must be defined when including bsp.h.

PCI device drivers may use the pci\_interrupt\_\* routines in order to call the BSP specific functions in a platform independent way. The PCI interrupt interface has been made similar to the RTEMS IRQ extension so that a BSP can use the standard RTEMS interrupt functions directly.

# <span id="page-908-1"></span><span id="page-908-0"></span>32.2.5 PCI Shell command

The RTEMS shell has a PCI command 'pci' which makes it possible to read/write configuration space, print the current PCI configuration and print out a configuration C-file for the static or peripheral library.

32.2. Background 881

CHAPTER

# **THIRTYTHREE**

# <span id="page-910-0"></span>STACK BOUNDS CHECKER

# <span id="page-911-0"></span>33.1 Introduction

The stack bounds checker is an RTEMS support component that determines if a task has overrun its run-time stack. The routines provided by the stack bounds checker manager are:

- [rtems\_stack\_checker\_is\_blown] Has the Current Task Blown its Stack
- [rtems\_stack\_checker\_report\_usage] Report Task Stack Usage

# <span id="page-912-0"></span>33.2 Background

## <span id="page-912-1"></span>33.2.1 Task Stack

Each task in a system has a fixed size stack associated with it. This stack is allocated when the task is created. As the task executes, the stack is used to contain parameters, return addresses, saved registers, and local variables. The amount of stack space required by a task is dependent on the exact set of routines used. The peak stack usage reflects the worst case of subroutine pushing information on the stack. For example, if a subroutine allocates a local buffer of 1024 bytes, then this data must be accounted for in the stack of every task that invokes that routine.

Recursive routines make calculating peak stack usage difficult, if not impossible. Each call to the recursive routine consumes *n* bytes of stack space. If the routine recursives 1000 times, then 1000 \* n bytes of stack space are required.

## <span id="page-912-2"></span>33.2.2 Execution

The stack bounds checker operates as a set of task extensions. At task creation time, the task's stack is filled with a pattern to indicate the stack is unused. As the task executes, it will overwrite this pattern in memory. At each task switch, the stack bounds checker's task switch extension is executed. This extension checks that:

- the last n bytes of the task's stack have not been overwritten. If this pattern has been damaged, it indicates that at some point since this task was context switch to the CPU, it has used too much stack space.
- the current stack pointer of the task is not within the address range allocated for use as the task's stack.

If either of these conditions is detected, then a blown stack error is reported using the printk routine.

The number of bytes checked for an overwrite is processor family dependent. The minimum stack frame per subroutine call varies widely between processor families. On CISC families like the Motorola MC68xxx and Intel ix86, all that is needed is a return address. On more complex RISC processors, the minimum stack frame per subroutine call may include space to save a significant number of registers.

Another processor dependent feature that must be taken into account by the stack bounds checker is the direction that the stack grows. On some processor families, the stack grows up or to higher addresses as the task executes. On other families, it grows down to lower addresses. The stack bounds checker implementation uses the stack description definitions provided by every RTEMS port to get for this information.

33.2. Background 885

# <span id="page-913-0"></span>33.3 Operations

## <span id="page-913-1"></span>33.3.1 Initializing the Stack Bounds Checker

The stack checker is initialized automatically when its task create extension runs for the first time.

The application must include the stack bounds checker extension set in its set of Initial Extensions. This set of extensions is defined as STACK\_CHECKER\_EXTENSION. If using <rtems/ confdefs.h> for Configuration Table generation, then all that is necessary is to define the macro CONFIGURE\_STACK\_CHECKER\_ENABLED before including <rtems/confdefs.h> as shown below:

```
1 #define CONFIGURE_STACK_CHECKER_ENABLED
2 ...
3 #include <rtems/confdefs.h>
```

## <span id="page-913-2"></span>33.3.2 Checking for Blown Task Stack

The application may check whether the stack pointer of currently executing task is within proper bounds at any time by calling the rtems\_stack\_checker\_is\_blown method. This method return FALSE if the task is operating within its stack bounds and has not damaged its pattern area.

## <span id="page-913-3"></span>33.3.3 Reporting Task Stack Usage

The application may dynamically report the stack usage for every task in the system by calling the rtems\_stack\_checker\_report\_usage routine. This routine prints a table with the peak usage and stack size of every task in the system. The following is an example of the report generated:

| 1 ID<br>NAME |      | LOW        | HIGH       | AVAILABLE |       | USED |
|--------------|------|------------|------------|-----------|-------|------|
| 2 0x04010001 | IDLE | 0x003e8a60 | 0x003e9667 |           | 2952  | 200  |
| 3 0x08010002 | TA1  | 0x003e5750 | 0x003e7b57 |           | 9096  | 1168 |
| 4 0x08010003 | TA2  | 0x003e31c8 | 0x003e55cf |           | 9096  | 1168 |
| 5 0x08010004 | TA3  | 0x003e0c40 | 0x003e3047 |           | 9096  | 1104 |
| 6 0xffffffff | INTR | 0x003ecfc0 | 0x003effbf |           | 12160 | 128  |

Notice the last line. The task id is 0xffffffff and its name is INTR. This is not actually a task, it is the interrupt stack.

## <span id="page-913-4"></span>33.3.4 When a Task Overflows the Stack

When the stack bounds checker determines that a stack overflow has occurred, it will attempt to print a message using printk identifying the task and then shut the system down. If the stack overflow has caused corruption, then it is possible that the message cannot be printed.

The following is an example of the output generated:

```
1 BLOWN STACK!!! Offending task(0x3eb360): id=0x08010002; name=0x54413120
2 stack covers range 0x003e5750 - 0x003e7b57 (9224 bytes)
3 Damaged pattern begins at 0x003e5758 and is 128 bytes long
```

The above includes the task id and a pointer to the task control block as well as enough information so one can look at the task's stack and see what was happening.

# <span id="page-914-3"></span><span id="page-914-0"></span>33.4 Routines

This section details the stack bounds checker's routines. A subsection is dedicated to each of routines and describes the calling sequence, related constants, usage, and status codes.

## <span id="page-914-1"></span>33.4.1 STACK\_CHECKER\_IS\_BLOWN - Has Current Task Blown Its Stack

## **CALLING SEQUENCE:**

```
1 bool rtems_stack_checker_is_blown( void );
```

#### **STATUS CODES:**

| TRUE  | Stack is operating within its stack limits      |
|-------|-------------------------------------------------|
| FALSE | Current stack pointer is outside allocated area |

#### **DESCRIPTION:**

This method is used to determine if the current stack pointer of the currently executing task is within bounds.

#### **NOTES:**

This method checks the current stack pointer against the high and low addresses of the stack memory allocated when the task was created and it looks for damage to the high water mark pattern for the worst case usage of the task being called.

<span id="page-914-2"></span>33.4.2 STACK\_CHECKER\_REPORT\_USAGE - Report Task Stack Usage

#### **CALLING SEQUENCE:**

```
1 void rtems_stack_checker_report_usage( void );
```

## **STATUS CODES:**

NONE

#### **DESCRIPTION:**

This routine prints a table with the peak stack usage and stack space allocation of every task in the system.

#### **NOTES:**

NONE

33.4. Routines 887

CHAPTER

# **THIRTYFOUR**

# <span id="page-916-0"></span>CPU USAGE STATISTICS

# <span id="page-917-0"></span>34.1 Introduction

The CPU usage statistics manager is an RTEMS support component that provides a convenient way to manipulate the CPU usage information associated with each task. The routines provided by the CPU usage statistics manager are:

- [rtems\_cpu\_usage\_report] Report CPU Usage Statistics
- [rtems\_cpu\_usage\_reset] Reset CPU Usage Statistics

# <span id="page-918-0"></span>34.2 Background

When analyzing and debugging real-time applications, it is important to be able to know how much CPU time each task in the system consumes. This support component provides a mechanism to easily obtain this information with little burden placed on the target.

The raw data is gathered as part of performing a context switch. RTEMS keeps track of how many clock ticks have occurred which the task being switched out has been executing. If the task has been running less than 1 clock tick, then for the purposes of the statistics, it is assumed to have executed 1 clock tick. This results in some inaccuracy but the alternative is for the task to have appeared to execute 0 clock ticks.

RTEMS versions newer than the 4.7 release series, support the ability to obtain timestamps with nanosecond granularity if the BSP provides support. It is a desirable enhancement to change the way the usage data is gathered to take advantage of this recently added capability. Please consider sponsoring the core RTEMS development team to add this capability.

34.2. Background 891

# <span id="page-919-0"></span>34.3 Operations

## <span id="page-919-1"></span>34.3.1 Report CPU Usage Statistics

The application may dynamically report the CPU usage for every task in the system by calling the rtems\_cpu\_usage\_report routine. This routine prints a table with the following information per task:

- task id
- task name
- number of clock ticks executed
- percentage of time consumed by this task

The following is an example of the report generated:

| 2  CPU<br>USAGE<br>BY                     | 1 ++<br>THREAD                       |         |                       |
|-------------------------------------------|--------------------------------------|---------|-----------------------|
| 4  ID<br>                                 | 3 ++++<br>NAME<br>                   | SECONDS | <br>PERCENT<br>       |
| 6  0x04010001<br>                         | 5 +++++<br>IDLE<br>                  | 0       | <br>0.000<br>         |
| 8  0x08010002<br>                         | 7 +++++<br>TA1<br>                   | 1203    | <br>0.748<br>         |
| 10  0x08010003<br>                        | 9 +++++<br>TA2<br>                   | 203     | <br>0.126<br>         |
| 12  0x08010004<br>                        | 11 +++++<br>TA3<br>                  | 202     | <br>0.126<br>         |
| 14  TICKS<br>SINCE<br>15  TOTAL<br>UNITS: | 13 +++++<br>LAST<br>SYSTEM<br>RESET: |         | 1600<br> <br>1608<br> |
|                                           | 16 ++                                |         |                       |

Notice that the TOTAL UNITS is greater than the ticks per reset. This is an artifact of the way in which RTEMS keeps track of CPU usage. When a task is context switched into the CPU, the number of clock ticks it has executed is incremented. While the task is executing, this number is incremented on each clock tick. Otherwise, if a task begins and completes execution between successive clock ticks, there would be no way to tell that it executed at all.

Another thing to keep in mind when looking at idle time, is that many systems - especially during debug - have a task providing some type of debug interface. It is usually fine to think of the total idle time as being the sum of the IDLE task and a debug task that will not be included in a production build of an application.

## <span id="page-919-2"></span>34.3.2 Reset CPU Usage Statistics

Invoking the rtems\_cpu\_usage\_reset routine resets the CPU usage statistics for all tasks in the system.

# <span id="page-920-0"></span>34.4 Directives

This section details the CPU usage statistics manager's directives. A subsection is dedicated to each of this manager's directives and describes the calling sequence, related constants, usage, and status codes.

34.4. Directives 893

## <span id="page-921-1"></span><span id="page-921-0"></span>34.4.1 cpu\_usage\_report - Report CPU Usage Statistics

#### **CALLING SEQUENCE:**

```
1 void rtems_cpu_usage_report( void );
```

## **STATUS CODES:**

NONE

#### **DESCRIPTION:**

This routine prints out a table detailing the CPU usage statistics for all tasks in the system.

## **NOTES:**

The table is printed using the printk routine.

<span id="page-922-1"></span><span id="page-922-0"></span>34.4.2 cpu\_usage\_reset - Reset CPU Usage Statistics

#### **CALLING SEQUENCE:**

```
1 void rtems_cpu_usage_reset( void );
```

## **STATUS CODES:**

NONE

#### **DESCRIPTION:**

This routine re-initializes the CPU usage statistics for all tasks in the system to their initial state. The initial state is that a task has not executed and thus has consumed no CPU time.

#### **NOTES:**

NONE

34.4. Directives 895

CHAPTER

# **THIRTYFIVE**

# <span id="page-924-0"></span>OBJECT SERVICES

# <span id="page-925-0"></span>35.1 Introduction

RTEMS provides a collection of services to assist in the management and usage of the objects created and utilized via other managers. These services assist in the manipulation of RTEMS objects independent of the API used to create them. The directives provided by the Object Services are:

- *[rtems\\_build\\_id\(\)](#page-930-0)* (page 903) Builds the object identifier from the API, class, MPCI node, and index components.
- *[rtems\\_build\\_name\(\)](#page-931-0)* (page 904) Builds the object name composed of the four characters.
- *[rtems\\_object\\_get\\_classic\\_name\(\)](#page-932-0)* (page 905) Gets the object name associated with the object identifier.
- *[rtems\\_object\\_get\\_name\(\)](#page-933-0)* (page 906) Gets the object name associated with the object identifier as a string.
- *[rtems\\_object\\_set\\_name\(\)](#page-934-0)* (page 907) Sets the object name of the object associated with the object identifier.
- *[rtems\\_object\\_id\\_get\\_api\(\)](#page-935-0)* (page 908) Gets the API component of the object identifier.
- *[rtems\\_object\\_id\\_get\\_class\(\)](#page-936-0)* (page 909) Gets the class component of the object identifier.
- *[rtems\\_object\\_id\\_get\\_node\(\)](#page-937-0)* (page 910) Gets the MPCI node component of the object identifier.
- *[rtems\\_object\\_id\\_get\\_index\(\)](#page-938-0)* (page 911) Gets the index component of the object identifier.
- *[rtems\\_object\\_id\\_api\\_minimum\(\)](#page-939-0)* (page 912) Gets the lowest valid value for the API component of an object identifier.
- *[rtems\\_object\\_id\\_api\\_maximum\(\)](#page-940-0)* (page 913) Gets the highest valid value for the API component of an object identifier.
- *[rtems\\_object\\_api\\_minimum\\_class\(\)](#page-941-0)* (page 914) Gets the lowest valid class value of the object API.
- *[rtems\\_object\\_api\\_maximum\\_class\(\)](#page-942-0)* (page 915) Gets the highest valid class value of the object API.
- *[rtems\\_object\\_get\\_api\\_name\(\)](#page-943-0)* (page 916) Gets a descriptive name of the object API.
- *[rtems\\_object\\_get\\_api\\_class\\_name\(\)](#page-944-0)* (page 917) Gets a descriptive name of the object class of the object API.
- *[rtems\\_object\\_get\\_class\\_information\(\)](#page-945-0)* (page 918) Gets the object class information of the object class of the object API.
- *[rtems\\_object\\_get\\_local\\_node\(\)](#page-946-0)* (page 919) Gets the local MPCI node number.
- *[RTEMS\\_OBJECT\\_ID\\_INITIAL\(\)](#page-947-0)* (page 920) Builds the object identifier with the lowest index from the API, class, and MPCI node components.

# <span id="page-926-0"></span>35.2 Background

## <span id="page-926-1"></span>35.2.1 APIs

RTEMS implements multiple APIs including an Internal API, the Classic API, and the POSIX API. These APIs share the common foundation of SuperCore objects and thus share object management code. This includes a common scheme for object Ids and for managing object names whether those names be in the thirty-two bit form used by the Classic API or C strings.

The object Id contains a field indicating the API that an object instance is associated with. This field holds a numerically small non-zero integer.

## <span id="page-926-2"></span>35.2.2 Object Classes

Each API consists of a collection of managers. Each manager is responsible for instances of a particular object class. Classic API Tasks and POSIX Mutexes example classes.

The object Id contains a field indicating the class that an object instance is associated with. This field holds a numerically small non-zero integer. In all APIs, a class value of one is reserved for tasks or threads.

## <span id="page-926-3"></span>35.2.3 Object Names

Every RTEMS object which has an Id may also have a name associated with it. Depending on the API, names may be either thirty-two bit integers as in the Classic API or strings as in the POSIX API.

Some objects have Ids but do not have a defined way to associate a name with them. For example, POSIX threads have Ids but per POSIX do not have names. In RTEMS, objects not defined to have thirty-two bit names may have string names assigned to them via the rtems\_object\_set\_name service. The original impetus in providing this service was so the normally anonymous POSIX threads could have a user defined name in CPU Usage Reports.

35.2. Background 899

# <span id="page-927-0"></span>35.3 Operations

## <span id="page-927-1"></span>35.3.1 Decomposing and Recomposing an Object Id

Services are provided to decompose an object Id into its subordinate components. The following services are used to do this:

- rtems\_object\_id\_get\_api
- rtems\_object\_id\_get\_class
- rtems\_object\_id\_get\_node
- rtems\_object\_id\_get\_index

The following C language example illustrates the decomposition of an Id and printing the values.

```
1 void printObjectId(rtems_id id)
2 {
3 printf(
4 "API=%d Class=%" PRIu32 " Node=%" PRIu32 " Index=%" PRIu16 "\n",
5 rtems_object_id_get_api(id),
6 rtems_object_id_get_class(id),
7 rtems_object_id_get_node(id),
8 rtems_object_id_get_index(id)
9 );
10 }
```

This prints the components of the Ids as integers.

It is also possible to construct an arbitrary Id using the rtems\_build\_id service. The following C language example illustrates how to construct the "next Id."

```
1 rtems_id nextObjectId(rtems_id id)
2 {
3 return rtems_build_id(
4 rtems_object_id_get_api(id),
5 rtems_object_id_get_class(id),
6 rtems_object_id_get_node(id),
7 rtems_object_id_get_index(id) + 1
8 );
9 }
```

Note that this Id may not be valid in this system or associated with an allocated object.

## <span id="page-927-2"></span>35.3.2 Printing an Object Id

RTEMS also provides services to associate the API and Class portions of an Object Id with strings. This allows the application developer to provide more information about an object in diagnostic messages.

In the following C language example, an Id is decomposed into its constituent parts and "prettyprinted."

```
1 void prettyPrintObjectId(rtems_id id)
2 {
3 int tmpAPI;
4 uint32_t tmpClass;
5
6 tmpAPI = rtems_object_id_get_api(id),
7 tmpClass = rtems_object_id_get_class(id),
8
9 printf(
10 "API=%s Class=%s Node=%" PRIu32 " Index=%" PRIu16 "\n",
11 rtems_object_get_api_name(tmpAPI),
12 rtems_object_get_api_class_name(tmpAPI, tmpClass),
13 rtems_object_id_get_node(id),
14 rtems_object_id_get_index(id)
15 );
16 }
```

35.3. Operations 901

# <span id="page-929-0"></span>35.4 Directives

This section details the directives of the Object Services. A subsection is dedicated to each of this manager's directives and lists the calling sequence, parameters, description, return values, and notes of the directive.

## <span id="page-930-1"></span><span id="page-930-0"></span>35.4.1 rtems\_build\_id()

Builds the object identifier from the API, class, MPCI node, and index components.

## CALLING SEQUENCE:

```
1 rtems_id rtems_build_id(
2 uint32_t api,
3 uint32_t the_class,
4 uint32_t node,
5 uint32_t index
6 );
```

#### PARAMETERS:

#### **api**

This parameter is the API of the object identifier to build.

#### **the\_class**

This parameter is the class of the object identifier to build.

#### **node**

This parameter is the MPCI node of the object identifier to build.

## **index**

This parameter is the index of the object identifier to build.

## RETURN VALUES:

Returns the object identifier built from the API, class, MPCI node, and index components.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive is implemented by a macro and may be called from within C/C++ constant expressions. In addition, a function implementation of the directive exists for bindings to other programming languages.
- The directive will not cause the calling task to be preempted.

35.4. Directives 903

## <span id="page-931-1"></span><span id="page-931-0"></span>35.4.2 rtems\_build\_name()

Builds the object name composed of the four characters.

## CALLING SEQUENCE:

```
1 rtems_name rtems_build_name( char c1, char c2, char c3, char c4 );
```

### PARAMETERS:

**c1**

This parameter is the first character of the name.

**c2**

This parameter is the second character of the name.

**c3**

This parameter is the third character of the name.

**c4**

This parameter is the fourth character of the name.

## DESCRIPTION:

This directive takes the four characters provided as arguments and composes a 32-bit object name with c1 in the most significant 8-bits and c4 in the least significant 8-bits.

#### RETURN VALUES:

Returns the object name composed of the four characters.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive is implemented by a macro and may be called from within C/C++ constant expressions. In addition, a function implementation of the directive exists for bindings to other programming languages.
- The directive will not cause the calling task to be preempted.

## <span id="page-932-1"></span><span id="page-932-0"></span>35.4.3 rtems\_object\_get\_classic\_name()

Gets the object name associated with the object identifier.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_object_get_classic_name(
2 rtems_id id,
3 rtems_name *name
4 );
```

#### PARAMETERS:

#### **id**

This parameter is the object identifier to get the name.

#### **name**

This parameter is the pointer to an *[rtems\\_name](#page-75-9)* (page 48) object. When the directive call is successful, the object name associated with the object identifier will be stored in this object.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

#### **RTEMS\_INVALID\_ADDRESS**

The name parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no object information available for the object identifier.

## **RTEMS\_INVALID\_ID**

The object name associated with the object identifier was a string.

#### **RTEMS\_INVALID\_ID**

There was no object associated with the object identifier.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

35.4. Directives 905

## <span id="page-933-1"></span><span id="page-933-0"></span>35.4.4 rtems\_object\_get\_name()

Gets the object name associated with the object identifier as a string.

#### CALLING SEQUENCE:

```
1 char *rtems_object_get_name( rtems_id id, size_t length, char *name );
```

#### PARAMETERS:

## **id**

This parameter is the object identifier to get the name.

#### **length**

This parameter is the buffer length in bytes.

#### **name**

This parameter is the pointer to a buffer of the specified length.

#### DESCRIPTION:

The object name is stored in the name buffer. If the name buffer length is greater than zero, then the stored object name will be NUL terminated. The stored object name may be truncated to fit the length. There is no indication if a truncation occurred. Every attempt is made to return name as a printable string even if the object has the Classic API 32-bit integer style name.

## RETURN VALUES:

## **[NULL](https://en.cppreference.com/w/c/types/NULL)**

The length parameter was 0.

#### **[NULL](https://en.cppreference.com/w/c/types/NULL)**

The name parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

## **[NULL](https://en.cppreference.com/w/c/types/NULL)**

There was no object information available for the object identifier.

## **[NULL](https://en.cppreference.com/w/c/types/NULL)**

There was no object associated with the object identifier.

Returns the name parameter value, if there is an object name associated with the object identifier.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-934-1"></span><span id="page-934-0"></span>35.4.5 rtems\_object\_set\_name()

Sets the object name of the object associated with the object identifier.

## CALLING SEQUENCE:

```
1 rtems_status_code rtems_object_set_name( rtems_id id, const char *name );
```

## PARAMETERS:

## **id**

This parameter is the object identifier of the object to set the name.

#### **name**

This parameter is the object name to set.

#### DESCRIPTION:

This directive will set the object name based upon the user string.

## RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ADDRESS**

The name parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

#### **RTEMS\_INVALID\_ID**

There was no object information available for the object identifier.

## **RTEMS\_INVALID\_ID**

There was no object associated with the object identifier.

#### **RTEMS\_NO\_MEMORY**

There was no memory available to duplicate the name.

#### NOTES:

This directive can be used to set the name of objects which do not have a naming scheme per their API.

If the object specified by id is of a class that has a string name, this directive will free the existing name to the RTEMS Workspace and allocate enough memory from the RTEMS Workspace to make a copy of the string located at name.

If the object specified by id is of a class that has a 32-bit integer style name, then the first four characters in name will be used to construct the name.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within device driver initialization context.
- The directive may be called from within task context.
- The directive may obtain and release the object allocator mutex. This may cause the calling task to be preempted.

35.4. Directives 907

## <span id="page-935-1"></span><span id="page-935-0"></span>35.4.6 rtems\_object\_id\_get\_api()

Gets the API component of the object identifier.

## CALLING SEQUENCE:

```
1 int rtems_object_id_get_api( rtems_id id );
```

#### PARAMETERS:

**id**

This parameter is the object identifier with the API component to get.

#### RETURN VALUES:

Returns the API component of the object identifier.

#### NOTES:

This directive does not validate the object identifier provided in id.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive is implemented by a macro and may be called from within C/C++ constant expressions. In addition, a function implementation of the directive exists for bindings to other programming languages.
- The directive will not cause the calling task to be preempted.

## <span id="page-936-1"></span><span id="page-936-0"></span>35.4.7 rtems\_object\_id\_get\_class()

Gets the class component of the object identifier.

#### CALLING SEQUENCE:

```
1 int rtems_object_id_get_class( rtems_id id );
```

#### PARAMETERS:

**id**

This parameter is the object identifier with the class component to get.

#### RETURN VALUES:

Returns the class component of the object identifier.

## NOTES:

This directive does not validate the object identifier provided in id.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive is implemented by a macro and may be called from within C/C++ constant expressions. In addition, a function implementation of the directive exists for bindings to other programming languages.
- The directive will not cause the calling task to be preempted.

35.4. Directives 909

## <span id="page-937-1"></span><span id="page-937-0"></span>35.4.8 rtems\_object\_id\_get\_node()

Gets the MPCI node component of the object identifier.

#### CALLING SEQUENCE:

```
1 int rtems_object_id_get_node( rtems_id id );
```

### PARAMETERS:

**id**

This parameter is the object identifier with the MPCI node component to get.

#### RETURN VALUES:

Returns the MPCI node component of the object identifier.

## NOTES:

This directive does not validate the object identifier provided in id.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive is implemented by a macro and may be called from within C/C++ constant expressions. In addition, a function implementation of the directive exists for bindings to other programming languages.
- The directive will not cause the calling task to be preempted.

## <span id="page-938-1"></span><span id="page-938-0"></span>35.4.9 rtems\_object\_id\_get\_index()

Gets the index component of the object identifier.

#### CALLING SEQUENCE:

```
1 int rtems_object_id_get_index( rtems_id id );
```

#### PARAMETERS:

**id**

This parameter is the object identifier with the index component to get.

#### RETURN VALUES:

Returns the index component of the object identifier.

## NOTES:

This directive does not validate the object identifier provided in id.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive is implemented by a macro and may be called from within C/C++ constant expressions. In addition, a function implementation of the directive exists for bindings to other programming languages.
- The directive will not cause the calling task to be preempted.

35.4. Directives 911

## <span id="page-939-1"></span><span id="page-939-0"></span>35.4.10 rtems\_object\_id\_api\_minimum()

Gets the lowest valid value for the API component of an object identifier.

## CALLING SEQUENCE:

```
1 int rtems_object_id_api_minimum( void );
```

### RETURN VALUES:

Returns the lowest valid value for the API component of an object identifier.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive is implemented by a macro and may be called from within C/C++ constant expressions. In addition, a function implementation of the directive exists for bindings to other programming languages.
- The directive will not cause the calling task to be preempted.

## <span id="page-940-1"></span><span id="page-940-0"></span>35.4.11 rtems\_object\_id\_api\_maximum()

Gets the highest valid value for the API component of an object identifier.

## CALLING SEQUENCE:

```
1 int rtems_object_id_api_maximum( void );
```

#### RETURN VALUES:

Returns the highest valid value for the API component of an object identifier.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive is implemented by a macro and may be called from within C/C++ constant expressions. In addition, a function implementation of the directive exists for bindings to other programming languages.
- The directive will not cause the calling task to be preempted.

35.4. Directives 913

## <span id="page-941-1"></span><span id="page-941-0"></span>35.4.12 rtems\_object\_api\_minimum\_class()

Gets the lowest valid class value of the object API.

#### CALLING SEQUENCE:

```
1 int rtems_object_api_minimum_class( int api );
```

#### PARAMETERS:

## **api**

This parameter is the object API to get the lowest valid class value.

#### RETURN VALUES:

**-1**

The object API was invalid.

Returns the lowest valid class value of the object API.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-942-1"></span><span id="page-942-0"></span>35.4.13 rtems\_object\_api\_maximum\_class()

Gets the highest valid class value of the object API.

#### CALLING SEQUENCE:

```
1 int rtems_object_api_maximum_class( int api );
```

#### PARAMETERS:

#### **api**

This parameter is the object API to get the highest valid class value.

#### RETURN VALUES:

**0**

The object API was invalid.

Returns the highest valid class value of the object API.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

35.4. Directives 915

## <span id="page-943-1"></span><span id="page-943-0"></span>35.4.14 rtems\_object\_get\_api\_name()

Gets a descriptive name of the object API.

#### CALLING SEQUENCE:

```
1 const char *rtems_object_get_api_name( int api );
```

### PARAMETERS:

#### **api**

This parameter is the object API to get the name.

#### RETURN VALUES:

#### **"BAD API"**

The API was invalid.

Returns a descriptive name of the API, if the API was valid.

#### NOTES:

The string returned is from constant space. Do not modify or free it.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

## <span id="page-944-1"></span><span id="page-944-0"></span>35.4.15 rtems\_object\_get\_api\_class\_name()

Gets a descriptive name of the object class of the object API.

#### CALLING SEQUENCE:

```
1 const char *rtems_object_get_api_class_name( int the_api, int the_class );
```

#### PARAMETERS:

#### **the\_api**

This parameter is the object API of the object class.

#### **the\_class**

This parameter is the object class of the object API to get the name.

#### RETURN VALUES:

#### **"BAD API"**

The API was invalid.

### **"BAD CLASS"**

The class of the API was invalid.

Returns a descriptive name of the class of the API, if the class of the API and the API were valid.

#### NOTES:

The string returned is from constant space. Do not modify or free it.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

35.4. Directives 917

## <span id="page-945-1"></span><span id="page-945-0"></span>35.4.16 rtems\_object\_get\_class\_information()

Gets the object class information of the object class of the object API.

#### CALLING SEQUENCE:

```
1 rtems_status_code rtems_object_get_class_information(
2 int the_api,
3 int the_class,
4 rtems_object_api_class_information *info
5 );
```

#### PARAMETERS:

#### **the\_api**

This parameter is the object API of the object class.

#### **the\_class**

This parameter is the object class of the object API to get the class information.

#### **info**

This parameter is the pointer to an *[rtems\\_object\\_api\\_class\\_information](#page-75-10)* (page 48) object. When the directive call is successful, the object class information of the class of the API will be stored in this object.

#### RETURN VALUES:

#### **RTEMS\_SUCCESSFUL**

The requested operation was successful.

## **RTEMS\_INVALID\_ADDRESS**

The info parameter was [NULL.](https://en.cppreference.com/w/c/types/NULL)

## **RTEMS\_INVALID\_NUMBER**

The class of the API or the API was invalid.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

<span id="page-946-1"></span><span id="page-946-0"></span>35.4.17 rtems\_object\_get\_local\_node()

Gets the local MPCI node number.

## CALLING SEQUENCE:

```
1 uint16_t rtems_object_get_local_node( void );
```

### RETURN VALUES:

Returns the local MPCI node number.

## CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

35.4. Directives 919

## <span id="page-947-1"></span><span id="page-947-0"></span>35.4.18 RTEMS\_OBJECT\_ID\_INITIAL()

Builds the object identifier with the lowest index from the API, class, and MPCI node components.

#### CALLING SEQUENCE:

```
1 rtems_id RTEMS_OBJECT_ID_INITIAL(
2 uint32_t api,
3 uint32_t class,
4 uint32_t node
5 );
```

#### PARAMETERS:

#### **api**

This parameter is the API of the object identifier to build.

#### **class**

This parameter is the class of the object identifier to build.

#### **node**

This parameter is the MPCI node of the object identifier to build.

## RETURN VALUES:

Returns the object identifier with the lowest index built from the API, class, and MPCI node components.

#### CONSTRAINTS:

The following constraints apply to this directive:

- The directive may be called from within any runtime context.
- The directive will not cause the calling task to be preempted.

CHAPTER

# **THIRTYSIX**

# <span id="page-948-0"></span>CHAINS

# <span id="page-949-0"></span>36.1 Introduction

The Chains API is an interface to the Super Core (score) chain implementation. The Super Core uses chains for all list type functions. This includes wait queues and task queues. The Chains API provided by RTEMS is:

- [rtems\_chain\_initialize] initialize the chain with nodes
- [rtems\_chain\_initialize\_empty] initialize the chain as empty
- [rtems\_chain\_is\_null\_node] Is the node NULL ?
- [rtems\_chain\_head] Return the chain's head
- [rtems\_chain\_tail] Return the chain's tail
- [rtems\_chain\_are\_nodes\_equal] Are the node's equal ?
- [rtems\_chain\_is\_empty] Is the chain empty ?
- [rtems\_chain\_is\_first] Is the Node the first in the chain ?
- [rtems\_chain\_is\_last] Is the Node the last in the chain ?
- [rtems\_chain\_has\_only\_one\_node] Does the node have one node ?
- [rtems\_chain\_node\_count\_unprotected] Returns the node count of the chain (unprotected)
- [rtems\_chain\_is\_head] Is the node the head ?
- [rtems\_chain\_is\_tail] Is the node the tail ?
- [rtems\_chain\_extract] Extract the node from the chain
- [rtems\_chain\_extract\_unprotected] Extract the node from the chain (unprotected)
- [rtems\_chain\_get] Return the first node on the chain
- [rtems\_chain\_get\_unprotected] Return the first node on the chain (unprotected)
- [rtems\_chain\_insert] Insert the node into the chain
- [rtems\_chain\_insert\_unprotected] Insert the node into the chain (unprotected)
- [rtems\_chain\_append] Append the node to chain
- [rtems\_chain\_append\_unprotected] Append the node to chain (unprotected)
- [rtems\_chain\_prepend] Prepend the node to the end of the chain
- [rtems\_chain\_prepend\_unprotected] Prepend the node to chain (unprotected)

# <span id="page-950-0"></span>36.2 Background

The Chains API maps to the Super Core Chains API. Chains are implemented as a double linked list of nodes anchored to a control node. The list starts at the control node and is terminated at the control node. A node has previous and next pointers. Being a double linked list nodes can be inserted and removed without the need to travse the chain.

Chains have a small memory footprint and can be used in interrupt service routines and are thread safe in a multi-threaded environment. The directives list which operations disable interrupts.

Chains are very useful in Board Support packages and applications.

## <span id="page-950-1"></span>36.2.1 Nodes

A chain is made up from nodes that orginate from a chain control object. A node is of type rtems\_chain\_node. The node is designed to be part of a user data structure and a cast is used to move from the node address to the user data structure address. For example:

```
1 typedef struct foo
2 {
3 rtems_chain_node node;
4 int bar;
5 } foo;
```

creates a type foo that can be placed on a chain. To get the foo structure from the list you perform the following:

```
1 foo* get_foo(rtems_chain_control* control)
2 {
3 return (foo*) rtems_chain_get(control);
4 }
```

The node is placed at the start of the user's structure to allow the node address on the chain to be easly cast to the user's structure address.

## <span id="page-950-2"></span>36.2.2 Controls

A chain is anchored with a control object. Chain control provide the user with access to the nodes on the chain. The control is head of the node.

```
1 [Control]
2 first ------------------------>
3 permanent_null <--------------- [NODE]
4 last ------------------------->
```

The implementation does not require special checks for manipulating the first and last nodes on the chain. To accomplish this the rtems\_chain\_control structure is treated as two overlapping rtems\_chain\_node structures. The permanent head of the chain overlays a node structure on the first and permanent\_null fields. The permanent\_tail of the chain overlays a node structure on the permanent\_null and last elements of the structure.

36.2. Background 923

# <span id="page-951-4"></span><span id="page-951-0"></span>36.3 Operations

## <span id="page-951-1"></span>36.3.1 Multi-threading

Chains are designed to be used in a multi-threading environment. The directives list which operations mask interrupts. Chains supports tasks and interrupt service routines appending and extracting nodes with out the need for extra locks. Chains how-ever cannot insure the integrity of a chain for all operations. This is the responsibility of the user. For example an interrupt service routine extracting nodes while a task is iterating over the chain can have unpredictable results.

## <span id="page-951-2"></span>36.3.2 Creating a Chain

To create a chain you need to declare a chain control then add nodes to the control. Consider a user structure and chain control:

```
1 typedef struct foo
2 {
3 rtems_chain_node node;
4 char* data;
5 } foo;
6 rtems_chain_control chain;
```

Add nodes with the following code:

```
1 rtems_chain_initialize_empty (&chain);
2
3 for (i = 0; i < count; i++)
4 {
5 foo* bar = malloc (sizeof (foo));
6 if (!bar)
7 return -1;
8 bar->data = malloc (size);
9 rtems_chain_append (&chain, &bar->node);
10 }
```

The chain is initialized and the nodes allocated and appended to the chain. This is an example of a pool of buffers.

## <span id="page-951-3"></span>36.3.3 Iterating a Chain

Iterating a chain is a common function. The example shows how to iterate the buffer pool chain created in the last section to find buffers starting with a specific string. If the buffer is located it is extracted from the chain and placed on another chain:

```
1 void foobar (const char* match,
2 rtems_chain_control* chain,
3 rtems_chain_control* out)
4 {
5 rtems_chain_node* node;
6 foo* bar;
7
```

(continues on next page)

(continued from previous page)

```
8 rtems_chain_initialize_empty (out);
9
10 node = rtems_chain_first (chain);
11
12 while (!rtems_chain_is_tail (chain, node))
13 {
14 bar = (foo*) node;
15 rtems_chain_node* next_node = rtems_chain_next(node);
16 if (strcmp (match, bar->data) == 0)
17 {
18 rtems_chain_extract (node);
19 rtems_chain_append (out, node);
20 }
21 node = next_node;
22 }
23 }
```

36.3. Operations 925

# <span id="page-953-0"></span>36.4 Directives

The section details the Chains directives.

## <span id="page-954-1"></span><span id="page-954-0"></span>36.4.1 Initialize Chain With Nodes

#### **CALLING SEQUENCE:**

```
1 void rtems_chain_initialize(
2 rtems_chain_control *the_chain,
3 void *starting_address,
4 size_t number_nodes,
5 size_t node_size
6 )
```

#### **RETURNS:**

Returns nothing.

#### **DESCRIPTION:**

This function take in a pointer to a chain control and initializes it to contain a set of chain nodes. The chain will contain number\_nodes chain nodes from the memory pointed to by start\_address. Each node is assumed to be node\_size bytes.

#### **NOTES:**

This call will discard any nodes on the chain.

This call does NOT inititialize any user data on each node.

36.4. Directives 927

## <span id="page-955-1"></span><span id="page-955-0"></span>36.4.2 Initialize Empty

#### **CALLING SEQUENCE:**

```
1 void rtems_chain_initialize_empty(
2 rtems_chain_control *the_chain
3 );
```

## **RETURNS:**

Returns nothing.

#### **DESCRIPTION:**

This function take in a pointer to a chain control and initializes it to empty.

#### **NOTES:**

This call will discard any nodes on the chain.

## <span id="page-956-1"></span><span id="page-956-0"></span>36.4.3 Is Null Node ?

#### **CALLING SEQUENCE:**

```
1 bool rtems_chain_is_null_node(
2 const rtems_chain_node *the_node
3 );
```

## **RETURNS:**

Returns true is the node point is NULL and false if the node is not NULL.

## **DESCRIPTION:**

Tests the node to see if it is a NULL returning true if a null.

36.4. Directives 929

## <span id="page-957-1"></span><span id="page-957-0"></span>36.4.4 Head

#### **CALLING SEQUENCE:**

```
1 rtems_chain_node *rtems_chain_head(
2 rtems_chain_control *the_chain
3 )
```

## **RETURNS:**

Returns the permanent head node of the chain.

## **DESCRIPTION:**

This function returns a pointer to the first node on the chain.

## <span id="page-958-1"></span><span id="page-958-0"></span>36.4.5 Tail

#### **CALLING SEQUENCE:**

```
1 rtems_chain_node *rtems_chain_tail(
2 rtems_chain_control *the_chain
3 );
```

#### **RETURNS:**

Returns the permanent tail node of the chain.

## **DESCRIPTION:**

This function returns a pointer to the last node on the chain.

36.4. Directives 931

## <span id="page-959-1"></span><span id="page-959-0"></span>36.4.6 Are Two Nodes Equal ?

#### **CALLING SEQUENCE:**

```
1 bool rtems_chain_are_nodes_equal(
2 const rtems_chain_node *left,
3 const rtems_chain_node *right
4 );
```

## **RETURNS:**

This function returns true if the left node and the right node are equal, and false otherwise.

#### **DESCRIPTION:**

This function returns true if the left node and the right node are equal, and false otherwise.

## <span id="page-960-1"></span><span id="page-960-0"></span>36.4.7 Is the Chain Empty

#### **CALLING SEQUENCE:**

```
1 bool rtems_chain_is_empty(
2 rtems_chain_control *the_chain
3 );
```

#### **RETURNS:**

This function returns true if there a no nodes on the chain and false otherwise.

## **DESCRIPTION:**

This function returns true if there a no nodes on the chain and false otherwise.

36.4. Directives 933

## <span id="page-961-1"></span><span id="page-961-0"></span>36.4.8 Is this the First Node on the Chain ?

#### **CALLING SEQUENCE:**

```
1 bool rtems_chain_is_first(
2 const rtems_chain_node *the_node
3 );
```

## **RETURNS:**

This function returns true if the node is the first node on a chain and false otherwise.

## **DESCRIPTION:**

This function returns true if the node is the first node on a chain and false otherwise.

#### <span id="page-962-1"></span><span id="page-962-0"></span>**CALLING SEQUENCE:**

```
1 bool rtems_chain_is_last(
2 const rtems_chain_node *the_node
3 );
```

## **RETURNS:**

This function returns true if the node is the last node on a chain and false otherwise.

## **DESCRIPTION:**

This function returns true if the node is the last node on a chain and false otherwise.

36.4. Directives 935

## <span id="page-963-1"></span><span id="page-963-0"></span>36.4.10 Does this Chain have only One Node ?

#### **CALLING SEQUENCE:**

```
1 bool rtems_chain_has_only_one_node(
2 const rtems_chain_control *the_chain
3 );
```

## **RETURNS:**

This function returns true if there is only one node on the chain and false otherwise.

## **DESCRIPTION:**

This function returns true if there is only one node on the chain and false otherwise.

936 Chapter 36. Chains

## <span id="page-964-1"></span><span id="page-964-0"></span>36.4.11 Returns the node count of the chain (unprotected)

#### **CALLING SEQUENCE:**

```
1 size_t rtems_chain_node_count_unprotected(
2 const rtems_chain_control *the_chain
3 );
```

## **RETURNS:**

This function returns the node count of the chain.

## **DESCRIPTION:**

This function returns the node count of the chain.

36.4. Directives 937

## <span id="page-965-1"></span><span id="page-965-0"></span>36.4.12 Is this Node the Chain Head ?

#### **CALLING SEQUENCE:**

```
1 bool rtems_chain_is_head(
2 rtems_chain_control *the_chain,
3 rtems_const chain_node *the_node
4 );
```

## **RETURNS:**

This function returns true if the node is the head of the chain and false otherwise.

#### **DESCRIPTION:**

This function returns true if the node is the head of the chain and false otherwise.

## <span id="page-966-1"></span><span id="page-966-0"></span>36.4.13 Is this Node the Chain Tail ?

#### **CALLING SEQUENCE:**

```
1 bool rtems_chain_is_tail(
2 rtems_chain_control *the_chain,
3 const rtems_chain_node *the_node
4 )
```

## **RETURNS:**

This function returns true if the node is the tail of the chain and false otherwise.

#### **DESCRIPTION:**

This function returns true if the node is the tail of the chain and false otherwise.

36.4. Directives 939

## <span id="page-967-1"></span><span id="page-967-0"></span>36.4.14 Extract a Node

#### **CALLING SEQUENCE:**

```
1 void rtems_chain_extract(
2 rtems_chain_node *the_node
3 );
```

## **RETURNS:**

Returns nothing.

## **DESCRIPTION:**

This routine extracts the node from the chain on which it resides.

#### **NOTES:**

Interrupts are disabled while extracting the node to ensure the atomicity of the operation.

Use rtems\_chain\_extract\_unprotected to avoid disabling of interrupts.

## <span id="page-968-1"></span><span id="page-968-0"></span>36.4.15 Extract a Node (unprotected)

#### **CALLING SEQUENCE:**

```
1 void rtems_chain_extract_unprotected(
2 rtems_chain_node *the_node
3 );
```

## **RETURNS:**

Returns nothing.

## **DESCRIPTION:**

This routine extracts the node from the chain on which it resides.

#### **NOTES:**

The function does nothing to ensure the atomicity of the operation.

36.4. Directives 941

## <span id="page-969-1"></span><span id="page-969-0"></span>36.4.16 Get the First Node

#### **CALLING SEQUENCE:**

```
1 rtems_chain_node *rtems_chain_get(
2 rtems_chain_control *the_chain
3 );
```

#### **RETURNS:**

Returns a pointer a node. If a node was removed, then a pointer to that node is returned. If the chain was empty, then NULL is returned.

#### **DESCRIPTION:**

This function removes the first node from the chain and returns a pointer to that node. If the chain is empty, then NULL is returned.

#### **NOTES:**

Interrupts are disabled while obtaining the node to ensure the atomicity of the operation.

Use rtems\_chain\_get\_unprotected() to avoid disabling of interrupts.

## <span id="page-970-1"></span><span id="page-970-0"></span>36.4.17 Get the First Node (unprotected)

#### **CALLING SEQUENCE:**

```
1 rtems_chain_node *rtems_chain_get_unprotected(
2 rtems_chain_control *the_chain
3 );
```

## **RETURNS:**

A pointer to the former first node is returned.

#### **DESCRIPTION:**

Removes the first node from the chain and returns a pointer to it. In case the chain was empty, then the results are unpredictable.

#### **NOTES:**

The function does nothing to ensure the atomicity of the operation.

36.4. Directives 943

## <span id="page-971-1"></span><span id="page-971-0"></span>36.4.18 Insert a Node

#### **CALLING SEQUENCE:**

```
1 void rtems_chain_insert(
2 rtems_chain_node *after_node,
3 rtems_chain_node *the_node
4 );
```

## **RETURNS:**

Returns nothing.

## **DESCRIPTION:**

This routine inserts a node on a chain immediately following the specified node.

#### **NOTES:**

Interrupts are disabled during the insert to ensure the atomicity of the operation.

Use rtems\_chain\_insert\_unprotected() to avoid disabling of interrupts.

## <span id="page-972-1"></span><span id="page-972-0"></span>36.4.19 Insert a Node (unprotected)

#### **CALLING SEQUENCE:**

```
1 void rtems_chain_insert_unprotected(
2 rtems_chain_node *after_node,
3 rtems_chain_node *the_node
4 );
```

## **RETURNS:**

Returns nothing.

#### **DESCRIPTION:**

This routine inserts a node on a chain immediately following the specified node.

#### **NOTES:**

The function does nothing to ensure the atomicity of the operation.

36.4. Directives 945

## <span id="page-973-1"></span><span id="page-973-0"></span>36.4.20 Append a Node

#### **CALLING SEQUENCE:**

```
1 void rtems_chain_append(
2 rtems_chain_control *the_chain,
3 rtems_chain_node *the_node
4 );
```

## **RETURNS:**

Returns nothing.

#### **DESCRIPTION:**

This routine appends a node to the end of a chain.

#### **NOTES:**

Interrupts are disabled during the append to ensure the atomicity of the operation.

Use rtems\_chain\_append\_unprotected to avoid disabling of interrupts.

## <span id="page-974-1"></span><span id="page-974-0"></span>36.4.21 Append a Node (unprotected)

#### **CALLING SEQUENCE:**

```
1 void rtems_chain_append_unprotected(
2 rtems_chain_control *the_chain,
3 rtems_chain_node *the_node
4 );
```

## **RETURNS:**

Returns nothing.

## **DESCRIPTION:**

This routine appends a node to the end of a chain.

#### **NOTES:**

The function does nothing to ensure the atomicity of the operation.

36.4. Directives 947

## <span id="page-975-1"></span><span id="page-975-0"></span>36.4.22 Prepend a Node

#### **CALLING SEQUENCE:**

```
1 void rtems_chain_prepend(
2 rtems_chain_control *the_chain,
3 rtems_chain_node *the_node
4 );
```

## **RETURNS:**

Returns nothing.

## **DESCRIPTION:**

This routine prepends a node to the front of the chain.

#### **NOTES:**

Interrupts are disabled during the prepend to ensure the atomicity of the operation.

Use rtems\_chain\_prepend\_unprotected to avoid disabling of interrupts.

## <span id="page-976-1"></span><span id="page-976-0"></span>36.4.23 Prepend a Node (unprotected)

#### **CALLING SEQUENCE:**

```
1 void rtems_chain_prepend_unprotected(
2 rtems_chain_control *the_chain,
3 rtems_chain_node *the_node
4 );
```

## **RETURNS:**

Returns nothing.

#### **DESCRIPTION:**

This routine prepends a node to the front of the chain.

#### **NOTES:**

The function does nothing to ensure the atomicity of the operation.

36.4. Directives 949

CHAPTER

# **THIRTYSEVEN**

# <span id="page-978-0"></span>RED-BLACK TREES

# <span id="page-979-0"></span>37.1 Introduction

The Red-Black Tree API is an interface to the SuperCore (score) rbtree implementation. Within RTEMS, red-black trees are used when a binary search tree is needed, including dynamic priority thread queues and non-contiguous heap memory. The Red-Black Tree API provided by RTEMS is:

- rtems\_rtems\_rbtree\_node Red-Black Tree node embedded in another struct
- rtems\_rtems\_rbtree\_control Red-Black Tree control node for an entire tree
- rtems\_rtems\_rbtree\_initialize initialize the red-black tree with nodes
- rtems\_rtems\_rbtree\_initialize\_empty initialize the red-black tree as empty
- rtems\_rtems\_rbtree\_set\_off\_tree Clear a node's links
- rtems\_rtems\_rbtree\_root Return the red-black tree's root node
- rtems\_rtems\_rbtree\_min Return the red-black tree's minimum node
- rtems\_rtems\_rbtree\_max Return the red-black tree's maximum node
- rtems\_rtems\_rbtree\_left Return a node's left child node
- rtems\_rtems\_rbtree\_right Return a node's right child node
- rtems\_rtems\_rbtree\_parent Return a node's parent node
- rtems\_rtems\_rbtree\_are\_nodes\_equal Are the node's equal ?
- rtems\_rtems\_rbtree\_is\_empty Is the red-black tree empty ?
- rtems\_rtems\_rbtree\_is\_min Is the Node the minimum in the red-black tree ?
- rtems\_rtems\_rbtree\_is\_max Is the Node the maximum in the red-black tree ?
- rtems\_rtems\_rbtree\_is\_root Is the Node the root of the red-black tree ?
- rtems\_rtems\_rbtree\_find Find the node with a matching key in the red-black tree
- rtems\_rtems\_rbtree\_predecessor Return the in-order predecessor of a node.
- rtems\_rtems\_rbtree\_successor Return the in-order successor of a node.
- rtems\_rtems\_rbtree\_extract Remove the node from the red-black tree
- rtems\_rtems\_rbtree\_get\_min Remove the minimum node from the red-black tree
- rtems\_rtems\_rbtree\_get\_max Remove the maximum node from the red-black tree
- rtems\_rtems\_rbtree\_peek\_min Returns the minimum node from the red-black tree
- rtems\_rtems\_rbtree\_peek\_max Returns the maximum node from the red-black tree
- rtems\_rtems\_rbtree\_insert Add the node to the red-black tree

# <span id="page-980-0"></span>37.2 Background

The Red-Black Trees API is a thin layer above the SuperCore Red-Black Trees implementation. A Red-Black Tree is defined by a control node with pointers to the root, minimum, and maximum nodes in the tree. Each node in the tree consists of a parent pointer, two children pointers, and a color attribute. A tree is parameterized as either unique, meaning identical keys are rejected, or not, in which case duplicate keys are allowed.

Users must provide a comparison functor that gets passed to functions that need to compare nodes. In addition, no internal synchronization is offered within the red-black tree implementation, thus users must ensure at most one thread accesses a red-black tree instance at a time.

## <span id="page-980-1"></span>37.2.1 Nodes

A red-black tree is made up from nodes that orginate from a red-black tree control object. A node is of type rtems\_rtems\_rbtree\_node. The node is designed to be part of a user data structure. To obtain the encapsulating structure users can use the RTEMS\_CONTAINER\_OF macro. The node can be placed anywhere within the user's structure and the macro will calculate the structure's address from the node's address.

## <span id="page-980-2"></span>37.2.2 Controls

A red-black tree is rooted with a control object. Red-Black Tree control provide the user with access to the nodes on the red-black tree. The implementation does not require special checks for manipulating the root of the red-black tree. To accomplish this the rtems\_rtems\_rbtree\_control structure is treated as a rtems\_rtems\_rbtree\_node structure with a NULL parent and left child pointing to the root.

37.2. Background 953

# <span id="page-981-0"></span>37.3 Operations

Examples for using the red-black trees can be found in the testsuites/sptests/sprbtree01/ init.c file.

# <span id="page-982-2"></span><span id="page-982-0"></span>37.4 Directives

## <span id="page-982-1"></span>37.4.1 Documentation for the Red-Black Tree Directives

Source documentation for the Red-Black Tree API can be found in the generated Doxygen output for cpukit/sapi.

37.4. Directives 955

CHAPTER

# **THIRTYEIGHT**

# <span id="page-984-0"></span>TIMESPEC HELPERS

# <span id="page-985-0"></span>38.1 Introduction

The Timespec helpers manager provides directives to assist in manipulating instances of the POSIX struct timespec structure.

The directives provided by the timespec helpers manager are:

- [rtems\_timespec\_set] Set timespec's value
- [rtems\_timespec\_zero] Zero timespec's value
- [rtems\_timespec\_is\_valid] Check if timespec is valid
- [rtems\_timespec\_add\_to] Add two timespecs
- [rtems\_timespec\_subtract] Subtract two timespecs
- [rtems\_timespec\_divide] Divide two timespecs
- [rtems\_timespec\_divide\_by\_integer] Divide timespec by integer
- [rtems\_timespec\_less\_than] Less than operator
- [rtems\_timespec\_greater\_than] Greater than operator
- [rtems\_timespec\_equal\_to] Check if two timespecs are equal
- [rtems\_timespec\_get\_seconds] Obtain seconds portion of timespec
- [rtems\_timespec\_get\_nanoseconds] Obtain nanoseconds portion of timespec
- [rtems\_timespec\_to\_ticks] Convert timespec to number of ticks
- [rtems\_timespec\_from\_ticks] Convert ticks to timespec

# <span id="page-986-0"></span>38.2 Background

## <span id="page-986-1"></span>38.2.1 Time Storage Conventions

Time can be stored in many ways. One of them is the struct timespec format which is a structure that consists of the fields tv\_sec to represent seconds and tv\_nsec to represent nanoseconds. The``struct timeval`` structure is simular and consists of seconds (stored in tv\_sec) and microseconds (stored in tv\_usec). Either``struct timespec`` or struct timeval can be used to represent elapsed time, time of executing some operations, or time of day.

38.2. Background 959

# <span id="page-987-0"></span>38.3 Operations

## <span id="page-987-1"></span>38.3.1 Set and Obtain Timespec Value

A user may write a specific time by passing the desired seconds and nanoseconds values and the destination struct timespec using the rtems\_timespec\_set directive.

The rtems\_timespec\_zero directive is used to zero the seconds and nanoseconds portions of a struct timespec instance.

Users may obtain the seconds or nanoseconds portions of a struct timespec instance with the rtems\_timespec\_get\_seconds or rtems\_timespec\_get\_nanoseconds methods, respectively.

## <span id="page-987-2"></span>38.3.2 Timespec Math

A user can perform multiple operations on struct timespec instances. The helpers in this manager assist in adding, subtracting, and performing divison on struct timespec instances.

- Adding two struct timespec can be done using the rtems\_timespec\_add\_to directive. This directive is used mainly to calculate total amount of time consumed by multiple operations.
- The rtems\_timespec\_subtract is used to subtract two struct timespecs instances and determine the elapsed time between those two points in time.
- The rtems\_timespec\_divide is used to use to divide one struct timespec instance by another. This calculates the percentage with a precision to three decimal points.
- The rtems\_timespec\_divide\_by\_integer is used to divide a struct timespec instance by an integer. It is commonly used in benchmark calculations to dividing duration by the number of iterations performed.

## <span id="page-987-3"></span>38.3.3 Comparing struct timespec Instances

A user can compare two struct timespec instances using the rtems\_timespec\_less\_than, rtems\_timespec\_greater\_than or rtems\_timespec\_equal\_to routines.

## <span id="page-987-4"></span>38.3.4 Conversions and Validity Check

Conversion to and from clock ticks may be performed by using the rtems\_timespec\_to\_ticks and rtems\_timespec\_from\_ticks directives.

User can also check validity of timespec with rtems\_timespec\_is\_valid routine.

# <span id="page-988-0"></span>38.4 Directives

This section details the Timespec Helpers manager's directives. A subsection is dedicated to each of this manager's directives and describes the calling sequence, related constants, usage, and status codes.

38.4. Directives 961

## <span id="page-989-1"></span><span id="page-989-0"></span>38.4.1 TIMESPEC\_SET - Set struct timespec Instance

#### **CALLING SEQUENCE:**

```
1 void rtems_timespec_set(
2 struct timespec *time,
3 time_t seconds,
4 uint32_t nanoseconds
5 );
```

## **DIRECTIVE STATUS CODES:**

NONE

#### **DESCRIPTION:**

This directive sets the struct timespec *time* to the desired seconds and nanoseconds values.

#### **NOTES:**

This method does NOT check if nanoseconds is less than the maximum number of nanoseconds in a second.

## <span id="page-990-1"></span><span id="page-990-0"></span>38.4.2 TIMESPEC\_ZERO - Zero struct timespec Instance

#### **CALLING SEQUENCE:**

```
1 void rtems_timespec_zero(
2 struct timespec *time
3 );
```

## **DIRECTIVE STATUS CODES:**

NONE

#### **DESCRIPTION:**

This routine sets the contents of the struct timespec instance time to zero.

#### **NOTES:**

NONE

38.4. Directives 963

## <span id="page-991-1"></span><span id="page-991-0"></span>38.4.3 TIMESPEC\_IS\_VALID - Check validity of a struct timespec instance

#### **CALLING SEQUENCE:**

```
1 bool rtems_timespec_is_valid(
2 const struct timespec *time
3 );
```

#### **DIRECTIVE STATUS CODES:**

This method returns true if the instance is valid, and false otherwise.

#### **DESCRIPTION:**

This routine check validity of a struct timespec instance. It checks if the nanoseconds portion of the struct timespec instanceis in allowed range (less than the maximum number of nanoseconds per second).

#### **NOTES:**

NONE

## <span id="page-992-1"></span><span id="page-992-0"></span>38.4.4 TIMESPEC\_ADD\_TO - Add Two struct timespec Instances

#### **CALLING SEQUENCE:**

```
1 uint32_t rtems_timespec_add_to(
2 struct timespec *time,
3 const struct timespec *add
4 );
```

#### **DIRECTIVE STATUS CODES:**

The method returns the number of seconds time increased by.

## **DESCRIPTION:**

This routine adds two struct timespec instances. The second argument is added to the first. The parameter time is the base time to which the add parameter is added.

#### **NOTES:**

NONE

38.4. Directives 965

## <span id="page-993-1"></span><span id="page-993-0"></span>38.4.5 TIMESPEC\_SUBTRACT - Subtract Two struct timespec Instances

#### **CALLING SEQUENCE:**

```
1 void rtems_timespec_subtract(
2 const struct timespec *start,
3 const struct timespec *end,
4 struct timespec *result
5 );
```

## **DIRECTIVE STATUS CODES:**

NONE

#### **DESCRIPTION:**

This routine subtracts start from end saves the difference in result. The primary use of this directive is to calculate elapsed time.

#### **NOTES:**

It is possible to subtract when end is less than start and it produce negative result. When doing this you should be careful and remember that only the seconds portion of a struct timespec instance is signed, which means that nanoseconds portion is always increasing. Due to that when your timespec has seconds = -1 and nanoseconds = 500,000,000 it means that result is -0.5 second, NOT the expected -1.5!

## <span id="page-994-1"></span><span id="page-994-0"></span>38.4.6 TIMESPEC\_DIVIDE - Divide Two struct timespec Instances

#### **CALLING SEQUENCE:**

```
1 void rtems_timespec_divide(
2 const struct timespec *lhs,
3 const struct timespec *rhs,
4 uint32_t *ival_percentage,
5 uint32_t *fval_percentage
6 );
```

#### **DIRECTIVE STATUS CODES:**

NONE

#### **DESCRIPTION:**

This routine divides the struct timespec instance lhs by the struct timespec instance rhs. The result is returned in the ival\_percentage and fval\_percentage, representing the integer and fractional results of the division respectively.

The ival\_percentage is integer value of calculated percentage and fval\_percentage is fractional part of calculated percentage.

#### **NOTES:**

The intended use is calculating percentges to three decimal points.

When dividing by zero, this routine return both ival\_percentage and fval\_percentage equal zero.

The division is performed using exclusively integer operations.

38.4. Directives 967

<span id="page-995-1"></span><span id="page-995-0"></span>38.4.7 TIMESPEC\_DIVIDE\_BY\_INTEGER - Divide a struct timespec Instance by an Integer

#### **CALLING SEQUENCE:**

```
1 int rtems_timespec_divide_by_integer(
2 const struct timespec *time,
3 uint32_t iterations,
4 struct timespec *result
5 );
```

#### **DIRECTIVE STATUS CODES:**

NONE

#### **DESCRIPTION:**

This routine divides the struct timespec instance time by the integer value iterations. The result is saved in result.

#### **NOTES:**

The expected use is to assist in benchmark calculations where you typically divide a duration (time) by a number of iterations what gives average time.

## <span id="page-996-1"></span><span id="page-996-0"></span>38.4.8 TIMESPEC\_LESS\_THAN - Less than operator

#### **CALLING SEQUENCE:**

```
1 bool rtems_timespec_less_than(
2 const struct timespec *lhs,
3 const struct timespec *rhs
4 );
```

## **DIRECTIVE STATUS CODES:**

This method returns struct true if lhs is less than rhs and struct false otherwise.

## **DESCRIPTION:**

This method is the less than operator for struct timespec instances. The first parameter is the left hand side and the second is the right hand side of the comparison.

#### **NOTES:**

NONE

38.4. Directives 969

## <span id="page-997-1"></span><span id="page-997-0"></span>38.4.9 TIMESPEC\_GREATER\_THAN - Greater than operator

#### **CALLING SEQUENCE:**

```
1 bool rtems_timespec_greater_than(
2 const struct timespec *_lhs,
3 const struct timespec *_rhs
4 );
```

## **DIRECTIVE STATUS CODES:**

This method returns struct true if lhs is greater than rhs and struct false otherwise.

## **DESCRIPTION:**

This method is greater than operator for struct timespec instances.

#### **NOTES:**

NONE

## <span id="page-998-1"></span><span id="page-998-0"></span>38.4.10 TIMESPEC\_EQUAL\_TO - Check equality of timespecs

#### **CALLING SEQUENCE:**

```
1 bool rtems_timespec_equal_to(
2 const struct timespec *lhs,
3 const struct timespec *rhs
4 );
```

## **DIRECTIVE STATUS CODES:**

This method returns struct true if lhs is equal to rhs and struct false otherwise.

#### **DESCRIPTION:**

This method is equality operator for struct timespec instances.

#### **NOTES:**

NONE

38.4. Directives 971

# <span id="page-999-1"></span><span id="page-999-0"></span>38.4.11 TIMESPEC\_GET\_SECONDS - Get Seconds Portion of struct timespec Instance **CALLING SEQUENCE:**

```
1 time_t rtems_timespec_get_seconds(
2 struct timespec *time
3 );
```

#### **DIRECTIVE STATUS CODES:**

This method returns the seconds portion of the specified struct timespec instance.

## **DESCRIPTION:**

This method returns the seconds portion of the specified struct timespec instance time.

#### **NOTES:**

NONE

<span id="page-1000-1"></span><span id="page-1000-0"></span>38.4.12 TIMESPEC\_GET\_NANOSECONDS - Get Nanoseconds Portion of the struct timespec Instance

## **CALLING SEQUENCE:**

```
1 uint32_t rtems_timespec_get_nanoseconds(
2 struct timespec *_time
3 );
```

## **DIRECTIVE STATUS CODES:**

This method returns the nanoseconds portion of the specified struct timespec instance.

#### **DESCRIPTION:**

This method returns the nanoseconds portion of the specified timespec which is pointed by \_time.

#### **NOTES:**

NONE

38.4. Directives 973

## <span id="page-1001-1"></span><span id="page-1001-0"></span>38.4.13 TIMESPEC\_TO\_TICKS - Convert struct timespec Instance to Ticks

#### **CALLING SEQUENCE:**

```
1 uint32_t rtems_timespec_to_ticks(
2 const struct timespec *time
3 );
```

#### **DIRECTIVE STATUS CODES:**

This directive returns the number of ticks computed.

## **DESCRIPTION:**

This directive converts the time timespec to the corresponding number of clock ticks.

#### **NOTES:**

NONE

# <span id="page-1002-1"></span><span id="page-1002-0"></span>38.4.14 TIMESPEC\_FROM\_TICKS - Convert Ticks to struct timespec Representation **CALLING SEQUENCE:**

```
1 void rtems_timespec_from_ticks(
2 uint32_t ticks,
3 struct timespec *time
4 );
```

## **DIRECTIVE STATUS CODES:**

NONE

#### **DESCRIPTION:**

This routine converts the ticks to the corresponding struct timespec representation and stores it in time.

#### **NOTES:**

NONE

38.4. Directives 975

CHAPTER

# **THIRTYNINE**

# <span id="page-1004-0"></span>CONSTANT BANDWIDTH SERVER SCHEDULER API

# <span id="page-1005-1"></span><span id="page-1005-0"></span>39.1 Introduction

Unlike simple schedulers, the Constant Bandwidth Server (CBS) requires a special API for tasks to indicate their scheduling parameters. The directives provided by the CBS API are:

- [rtems\_cbs\_initialize] Initialize the CBS library
- [rtems\_cbs\_cleanup] Cleanup the CBS library
- [rtems\_cbs\_create\_server] Create a new bandwidth server
- [rtems\_cbs\_attach\_thread] Attach a thread to server
- [rtems\_cbs\_detach\_thread] Detach a thread from server
- [rtems\_cbs\_destroy\_server] Destroy a bandwidth server
- [rtems\_cbs\_get\_server\_id] Get an ID of a server
- [rtems\_cbs\_get\_parameters] Get scheduling parameters of a server
- [rtems\_cbs\_set\_parameters] Set scheduling parameters of a server
- [rtems\_cbs\_get\_execution\_time] Get elapsed execution time
- [rtems\_cbs\_get\_remaining\_budget] Get remainig execution time
- [rtems\_cbs\_get\_approved\_budget] Get scheduler approved execution time

# <span id="page-1006-4"></span><span id="page-1006-0"></span>39.2 Background

## <span id="page-1006-1"></span>39.2.1 Constant Bandwidth Server Definitions

The Constant Bandwidth Server API enables tasks to communicate with the scheduler and indicate its scheduling parameters. The scheduler has to be set up first (by defining CONFIGURE\_SCHEDULER\_CBS macro).

The difference to a plain EDF is the presence of servers. It is a budget aware extention of the EDF scheduler, therefore, tasks attached to servers behave in a similar way as with EDF unless they exceed their budget.

The intention of servers is reservation of a certain computation time (budget) of the processor for all subsequent periods. The structure rtems\_cbs\_parameters determines the behavior of a server. It contains deadline which is equal to period, and budget which is the time the server is allowed to spend on CPU per each period. The ratio between those two parameters yields the maximum percentage of the CPU the server can use (bandwidth). Moreover, thanks to this limitation the overall utilization of CPU is under control, and the sum of bandwidths of all servers in the system yields the overall reserved portion of processor. The rest is still available for ordinary tasks that are not attached to any server.

In order to make the server effective to the executing tasks, tasks have to be attached to the servers. The rtems\_cbs\_server\_id is a type denoting an id of a server and rtems\_id a type for id of tasks. . . . index:: CBS periodic tasks

## <span id="page-1006-2"></span>39.2.2 Handling Periodic Tasks

Each task's execution begins with a default background priority (see the chapter Scheduling Concepts to understand the concept of priorities in EDF). Once you decide the tasks should start periodic execution, you have two possibilities. Either you use only the Rate Monotonic manager which takes care of periodic behavior, or you declare deadline and budget using the CBS API in which case these properties are constant for all subsequent periods, unless you change them using the CBS API again. Task now only has to indicate and end of each period using rtems\_rate\_monotonic\_period. . . . index:: CBS overrun handler

## <span id="page-1006-3"></span>39.2.3 Registering a Callback Function

In case tasks attached to servers are not aware of their execution time and happen to exceed it, the scheduler does not guarantee execution any more and pulls the priority of the task to background, which would possibly lead to immediate preemption (if there is at least one ready task with a higher pirority). However, the task is not blocked but a callback function is invoked. The callback function (rtems\_cbs\_budget\_overrun) might be optionally registered upon a server creation (rtems\_cbs\_create\_server).

This enables the user to define what should happen in case of budget overrun. There is obviously no space for huge operations because the priority is down and not real time any more, however, you still can at least in release resources for other tasks, restart the task or log an error information. Since the routine is called directly from kernel, use printk() instead of printf().

The calling convention of the callback function is:

```
1 void overrun_handler(
2 rtems_cbs_server_id server_id
3 );
```

39.2. Background 979

## <span id="page-1007-0"></span>39.2.4 Limitations

When using this scheduler you have to keep in mind several things:

- it\_limitations
- In the current implementation it is possible to attach only a single task to each server.
- If you have a task attached to a server and you voluntatily block it in the beginning of its execution, its priority will be probably pulled to background upon unblock, thus not guaranteed deadline any more. This is because you are effectively raising computation time of the task. When unbocking, you should be always sure that the ratio between remaining computation time and remaining deadline is not higher that the utilization you have agreed with the scheduler.

# <span id="page-1008-0"></span>39.3 Operations

## <span id="page-1008-1"></span>39.3.1 Setting up a server

The directive rtems\_cbs\_create\_server is used to create a new server that is characterized by rtems\_cbs\_parameters. You also might want to register the rtems\_cbs\_budget\_overrun callback routine. After this step tasks can be attached to the server. The directive rtems\_cbs\_set\_parameters can change the scheduling parameters to avoid destroying and creating a new server again.

# <span id="page-1008-2"></span>39.3.2 Attaching Task to a Server

If a task is attached to a server using rtems\_cbs\_attach\_thread, the task's computation time per period is limited by the server and the deadline (period) of task is equal to deadline of the server which means if you conclude a period using rate\_monotonic\_period, the length of next period is always determined by the server's property.

The task has a guaranteed bandwidth given by the server but should not exceed it, otherwise the priority is pulled to background until the start of next period and the rtems\_cbs\_budget\_overrun callback function is invoked.

When attaching a task to server, the preemptability flag of the task is raised, otherwise it would not be possible to control the execution of the task.

## <span id="page-1008-3"></span>39.3.3 Detaching Task from a Server

The directive rtems\_cbs\_detach\_thread is just an inverse operation to the previous one, the task continues its execution with the initial priority.

Preemptability of the task is restored to the initial value.

## <span id="page-1008-4"></span>39.3.4 Examples

The following example presents a simple common use of the API.

You can see the initialization and cleanup call here, if there are multiple tasks in the system, it is obvious that the initialization should be called before creating the task.

Notice also that in this case we decided to register an overrun handler, instead of which there could be NULL. This handler just prints a message to terminal, what else may be done here depends on a specific application.

During the periodic execution, remaining budget should be watched to avoid overrun.

```
1 void overrun_handler (
2 rtems_cbs_server_id server_id
3 )
4 {
5 printk( "Budget overrun, fixing the task\n" );
6 return;
7 }
8
9 rtems_task Tasks_Periodic(
10 rtems_task_argument argument
11 )
```

(continues on next page)

39.3. Operations 981

(continued from previous page)

```
12 {
13 rtems_id rmid;
14 rtems_cbs_server_id server_id;
15 rtems_cbs_parameters params;
16
17 params.deadline = 10;
18 params.budget = 4;
19
20 rtems_cbs_initialize();
21 rtems_cbs_create_server( &params, &overrun_handler, &server_id );
22 rtems_cbs_attach_thread( server_id, RTEMS_SELF );
23 rtems_rate_monotonic_create( argument, &rmid );
24
25 while ( 1 ) {
26 if (rtems_rate_monotonic_period(rmid, params.deadline) == RTEMS_TIMEOUT)
27 break;
28 /* Perform some periodic action */
29 }
30
31 rtems_rate_monotonic_delete( rmid );
32 rtems_cbs_cleanup();
33 exit( 1 );
34 }
```

# <span id="page-1010-0"></span>39.4 Directives

This section details the Constant Bandwidth Server's directives. A subsection is dedicated to each of this manager's directives and describes the calling sequence, related constants, usage, and status codes.

39.4. Directives 983

## <span id="page-1011-1"></span><span id="page-1011-0"></span>39.4.1 CBS\_INITIALIZE - Initialize the CBS library

#### **CALLING SEQUENCE:**

```
1 int rtems_cbs_initialize( void );
```

## **DIRECTIVE STATUS CODES:**

| RTEMS_CBS_OK              | successful initialization  |
|---------------------------|----------------------------|
| RTEMS_CBS_ERROR_NO_MEMORY | not enough memory for data |

#### **DESCRIPTION:**

This routine initializes the library in terms of allocating necessary memory for the servers. In case not enough memory is available in the system, RTEMS\_CBS\_ERROR\_NO\_MEMORY is returned, otherwise RTEMS\_CBS\_OK.

## **NOTES:**

Additional memory per each server is allocated upon invocation of rtems\_cbs\_create\_server.

Tasks in the system are not influenced, they still keep executing with their initial parameters.

#### <span id="page-1012-1"></span><span id="page-1012-0"></span>**CALLING SEQUENCE:**

```
1 int rtems_cbs_cleanup( void );
```

## **DIRECTIVE STATUS CODES:**

RTEMS\_CBS\_OK always successful

#### **DESCRIPTION:**

This routine detaches all tasks from their servers, destroys all servers and returns memory back to the system.

#### **NOTES:**

All tasks continue executing with their initial priorities.

39.4. Directives 985

## <span id="page-1013-1"></span><span id="page-1013-0"></span>39.4.3 CBS\_CREATE\_SERVER - Create a new bandwidth server

#### **CALLING SEQUENCE:**

```
1 int rtems_cbs_create_server (
2 rtems_cbs_parameters *params,
3 rtems_cbs_budget_overrun budget_overrun_callback,
4 rtems_cbs_server_id *server_id
5 );
```

## **DIRECTIVE STATUS CODES:**

| RTEMS_CBS_OK                      | successfully created       |
|-----------------------------------|----------------------------|
| RTEMS_CBS_ERROR_NO_MEMORY         | not enough memory for data |
| RTEMS_CBS_ERROR_FULL              | maximum servers exceeded   |
| RTEMS_CBS_ERROR_INVALID_PARAMETER | invalid input argument     |

#### **DESCRIPTION:**

This routine prepares an instance of a constant bandwidth server. The input parameter rtems\_cbs\_parameters specifies scheduling parameters of the server (period and budget). If these are not valid, RTEMS\_CBS\_ERROR\_INVALID\_PARAMETER is returned. The budget\_overrun\_callback is an optional callback function, which is invoked in case the server's budget within one period is exceeded. Output parameter server\_id becomes an id of the newly created server. If there is not enough memory, the RTEMS\_CBS\_ERROR\_NO\_MEMORY is returned. If the maximum server count in the system is exceeded, RTEMS\_CBS\_ERROR\_FULL is returned.

## **NOTES:**

No task execution is being influenced so far.

## <span id="page-1014-1"></span><span id="page-1014-0"></span>39.4.4 CBS\_ATTACH\_THREAD - Attach a thread to server

#### **CALLING SEQUENCE:**

```
1 int rtems_cbs_attach_thread (
2 rtems_cbs_server_id server_id,
3 rtems_id task_id
4 );
```

## **DIRECTIVE STATUS CODES:**

| RTEMS_CBS_OK                      | successfully attached         |
|-----------------------------------|-------------------------------|
| RTEMS_CBS_ERROR_FULL              | server maximum tasks exceeded |
| RTEMS_CBS_ERROR_INVALID_PARAMETER | invalid input argument        |
| RTEMS_CBS_ERROR_NOSERVER          | server is not valid           |

#### **DESCRIPTION:**

Attaches a task (task\_id) to a server (server\_id). The server has to be previously created. Now, the task starts to be scheduled according to the server parameters and not using initial priority. This implementation allows only one task per server, if the user tries to bind another task to the same server, RTEMS\_CBS\_ERROR\_FULL is returned.

#### **NOTES:**

Tasks attached to servers become preemptible.

39.4. Directives 987

## <span id="page-1015-1"></span><span id="page-1015-0"></span>39.4.5 CBS\_DETACH\_THREAD - Detach a thread from server

#### **CALLING SEQUENCE:**

```
1 int rtems_cbs_detach_thread (
2 rtems_cbs_server_id server_id,
3 rtems_id task_id
4 );
```

## **DIRECTIVE STATUS CODES:**

| RTEMS_CBS_OK                      | successfully detached  |
|-----------------------------------|------------------------|
| RTEMS_CBS_ERROR_INVALID_PARAMETER | invalid input argument |
| RTEMS_CBS_ERROR_NOSERVER          | server is not valid    |

## **DESCRIPTION:**

This directive detaches a thread from server. The task continues its execution with initial priority.

#### **NOTES:**

The server can be reused for any other task.

## <span id="page-1016-1"></span><span id="page-1016-0"></span>39.4.6 CBS\_DESTROY\_SERVER - Destroy a bandwidth server

#### **CALLING SEQUENCE:**

```
1 int rtems_cbs_destroy_server (
2 rtems_cbs_server_id server_id
3 );
```

#### **DIRECTIVE STATUS CODES:**

| RTEMS_CBS_OK                      | successfully destroyed |
|-----------------------------------|------------------------|
| RTEMS_CBS_ERROR_INVALID_PARAMETER | invalid input argument |
| RTEMS_CBS_ERROR_NOSERVER          | server is not valid    |

#### **DESCRIPTION:**

This directive destroys a server. If any task was attached to the server, the task is detached and continues its execution according to EDF rules with initial properties.

#### **NOTES:**

This again enables one more task to be created.

39.4. Directives 989

## <span id="page-1017-1"></span><span id="page-1017-0"></span>39.4.7 CBS\_GET\_SERVER\_ID - Get an ID of a server

#### **CALLING SEQUENCE:**

```
1 int rtems_cbs_get_server_id (
2 rtems_id task_id,
3 rtems_cbs_server_id *server_id
4 );
```

## **DIRECTIVE STATUS CODES:**

```
RTEMS_CBS_OK successful
RTEMS_CBS_ERROR_NOSERVER server is not valid
```

#### **DESCRIPTION:**

This directive returns an id of server belonging to a given task.

## <span id="page-1018-1"></span><span id="page-1018-0"></span>39.4.8 CBS\_GET\_PARAMETERS - Get scheduling parameters of a server

#### **CALLING SEQUENCE:**

```
1 rtems_cbs_get_parameters (
2 rtems_cbs_server_id server_id,
3 rtems_cbs_parameters *params
4 );
```

## **DIRECTIVE STATUS CODES:**

| RTEMS_CBS_OK                      | successful             |
|-----------------------------------|------------------------|
| RTEMS_CBS_ERROR_INVALID_PARAMETER | invalid input argument |
| RTEMS_CBS_ERROR_NOSERVER          | server is not valid    |

#### **DESCRIPTION:**

This directive returns a structure with current scheduling parameters of a given server (period and execution time).

#### **NOTES:**

It makes no difference if any task is assigned or not.

39.4. Directives 991

## <span id="page-1019-1"></span><span id="page-1019-0"></span>39.4.9 CBS\_SET\_PARAMETERS - Set scheduling parameters

#### **CALLING SEQUENCE:**

```
1 int rtems_cbs_set_parameters (
2 rtems_cbs_server_id server_id,
3 rtems_cbs_parameters *params
4 );
```

## **DIRECTIVE STATUS CODES:**

| RTEMS_CBS_OK                      | successful             |
|-----------------------------------|------------------------|
| RTEMS_CBS_ERROR_INVALID_PARAMETER | invalid input argument |
| RTEMS_CBS_ERROR_NOSERVER          | server is not valid    |

## **DESCRIPTION:**

This directive sets new scheduling parameters to the server. This operation can be performed regardless of whether a task is assigned or not. If a task is assigned, the parameters become effective imediately, therefore it is recommended to apply the change between two subsequent periods.

#### **NOTES:**

There is an upper limit on both period and budget equal to (2^31)-1 ticks.

## <span id="page-1020-1"></span><span id="page-1020-0"></span>39.4.10 CBS\_GET\_EXECUTION\_TIME - Get elapsed execution time

#### **CALLING SEQUENCE:**

```
1 int rtems_cbs_get_execution_time (
2 rtems_cbs_server_id server_id,
3 time_t *exec_time,
4 time_t *abs_time
5 );
```

#### **DIRECTIVE STATUS CODES:**

| RTEMS_CBS_OK                      | successful             |
|-----------------------------------|------------------------|
| RTEMS_CBS_ERROR_INVALID_PARAMETER | invalid input argument |
| RTEMS_CBS_ERROR_NOSERVER          | server is not valid    |

#### **DESCRIPTION:**

This routine returns consumed execution time (exec\_time) of a server during the current period.

## **NOTES:**

Absolute time (abs\_time) not supported now.

39.4. Directives 993

# <span id="page-1021-1"></span><span id="page-1021-0"></span>39.4.11 CBS\_GET\_REMAINING\_BUDGET - Get remaining execution time

```
1 int rtems_cbs_get_remaining_budget (
2 rtems_cbs_server_id server_id,
3 time_t *remaining_budget
4 );
```

## **DIRECTIVE STATUS CODES:**

**CALLING SEQUENCE:**

| RTEMS_CBS_OK                      | successful             |
|-----------------------------------|------------------------|
| RTEMS_CBS_ERROR_INVALID_PARAMETER | invalid input argument |
| RTEMS_CBS_ERROR_NOSERVER          | server is not valid    |

## **DESCRIPTION:**

This directive returns remaining execution time of a given server for current period.

#### **NOTES:**

If the execution time approaches zero, the assigned task should finish computations of the current period.

# <span id="page-1022-1"></span><span id="page-1022-0"></span>39.4.12 CBS\_GET\_APPROVED\_BUDGET - Get scheduler approved execution time **CALLING SEQUENCE:**

```
1 int rtems_cbs_get_approved_budget (
2 rtems_cbs_server_id server_id,
3 time_t *appr_budget
4 );
```

## **DIRECTIVE STATUS CODES:**

| RTEMS_CBS_OK                      | successful             |
|-----------------------------------|------------------------|
| RTEMS_CBS_ERROR_INVALID_PARAMETER | invalid input argument |
| RTEMS_CBS_ERROR_NOSERVER          | server is not valid    |

#### **DESCRIPTION:**

This directive returns server's approved budget for subsequent periods.

39.4. Directives 995

CHAPTER

**FORTY**

# <span id="page-1024-0"></span>ADA SUPPORT

# <span id="page-1025-0"></span>40.1 Introduction

RTEMS has long had support for the Ada programming language by supporting the GNU Ada Compiler (GNAT). There are two primary components to this support:

- Ada Programming Language Support
- Classic API Ada Bindings

# <span id="page-1026-0"></span>40.2 Ada Programming Language Support

The Ada programming natively supports multi-threaded programming with its own tasking and concurrency model. Native Ada multi-threaded applications should work using GNAT/RTEMS with no changes.

The application developer will have to account for the specific requirements of the GNAT Run-Time when configuring RTEMS. There are example Ada programs with RTEMS configuration and startup sequences.

# <span id="page-1027-1"></span><span id="page-1027-0"></span>40.3 Classic API Ada Bindings

An Ada language binding exists for a subset of the RTEMS Classic API. In the early 1990's, there were C and Ada implementations of RTEMS which were functionally equivalent. The source structure was as similar as possible. In fact, the top level c/ directory at one point had a sibling ada/. The current Ada language bindings and test code was derived from that Ada implementation.

The Ada binding specifically excludes some methods which are either not safe or not intended for use from Ada programs. However, methods are generally only added to this binding when a user makes a requests. Thus some methods that could be supported are not. If in doubt, ask about a methods and contribute bindings.

The bindings are located in the c/src/ada directory of the RTEMS source tree. The tests are in c/src/ada-tests. The bindings following a simple pattern to map the C Classic API calls into Ada subprograms. The following rules are used:

- All RTEMS interfaces are in the RTEMS Ada package. The rtems\_ and RTEMS\_ prefixes in the C version of the Classic API thus correspond to "RTEMS." in Ada symbol nomenclature. For example, rtems\_task\_create() in C is RTEMS.Task\_Create() in Ada.
- Classic API directives tend to return an rtems\_status\_code. Some directives also have an output parameter such as an object id on a create operation. Ada subprograms are either pure functions with only a single return value or subprograms. For consistency, the returned status code is always the last parameter of the Ada calling sequence.

Caution should be exercised when writing programs which mix Ada tasks, Classic API tasks, and POSIX API threads. Ada tasks use a priority numbering scheme defined by the Ada programming language. Each Ada task is implemented in GNAT/RTEMS as a single POSIX thread. Thus Ada task priorities must be mapped onto POSIX thread priorities. Complicating matters, Classic API tasks and POSIX API threads use different numbering schemes for priority. Low numbers are high priority in the Classic API while indicating low priority in the POSIX threads API. Experience writing mixed threading model programs teaches that creating a table of the priorities used in the application with the value in all tasking models used is helpful.

The GNAT run-time uses a priority ceiling mutex to protect its data structures. The priority ceiling value is one priority more important than the most important Ada task priority (in POSIX API terms). Do not invoke any services implemented in Ada from a thread or task which is of greater priority. This will result in a priority ceiling violation error and lead to a failure in the Ada run-time.

Exercise extreme caution when considering writing code in Ada which will execute in the context of an interrupt handler. Hardware interrupts are processed outside the context of any thread in RTEMS and this can lead to violating assumptions in the GNAT run-time. Specifically a priority ceiling mutex should never be used from an ISR and it is difficult to predict when the Ada compiler or run-time will use a mutex.

RTEMS has two capabilities which can assist in avoiding this problem. The Classic API Timer Manager allows the creation of Timer Service Routines which execute in the context of a task rather than the clock tick Interrupt Service Routine. Similarly, there is support for Interrupt Tasks which is a mechanism to defer the processing of the event from the hardware interrupt level to a thread.

CHAPTER

# **FORTYONE**

# <span id="page-1028-0"></span>LINKER SETS

# <span id="page-1029-0"></span>41.1 Introduction

Linker sets are a flexible means to create arrays of items out of a set of object files at link-time. For example it is possible to define an item *I* of type *T* in object file *A* and an item *J* of type *T* in object file *B* to be a member of a linker set *S*. The linker will then collect these two items *I* and *J* and place them in consecutive memory locations, so that they can be accessed like a normal array defined in one object file. The size of a linker set is defined by its begin and end markers. A linker set may be empty. It should only contain items of the same type.

The following macros are provided to create, populate and use linker sets.

- [RTEMS\_LINKER\_SET\_BEGIN] Designator of the linker set begin marker
- [RTEMS\_LINKER\_SET\_END] Designator of the linker set end marker
- [RTEMS\_LINKER\_SET\_SIZE] The linker set size in characters
- [RTEMS\_LINKER\_SET\_ITEM\_COUNT] The linker set item count
- [RTEMS\_LINKER\_SET\_IS\_EMPTY] Is the linker set empty?
- [RTEMS\_LINKER\_SET\_FOREACH] Iterate through the linker set items
- [RTEMS\_LINKER\_ROSET\_DECLARE] Declares a read-only linker set
- [RTEMS\_LINKER\_ROSET] Defines a read-only linker set
- [RTEMS\_LINKER\_ROSET\_ITEM\_DECLARE] Declares a read-only linker set item
- [RTEMS\_LINKER\_ROSET\_ITEM\_ORDERED\_DECLARE] Declares an ordered read-only linker set item
- [RTEMS\_LINKER\_ROSET\_ITEM\_REFERENCE] References a read-only linker set item
- [RTEMS\_LINKER\_ROSET\_ITEM] Defines a read-only linker set item
- [RTEMS\_LINKER\_ROSET\_ITEM\_ORDERED] Defines an ordered read-only linker set item
- [RTEMS\_LINKER\_ROSET\_CONTENT] Marks a declaration as a read-only linker set content
- [RTEMS\_LINKER\_RWSET\_DECLARE] Declares a read-write linker set
- [RTEMS\_LINKER\_RWSET] Defines a read-write linker set
- [RTEMS\_LINKER\_RWSET\_ITEM\_DECLARE] Declares a read-write linker set item
- [RTEMS\_LINKER\_RWSET\_ITEM\_ORDERED\_DECLARE] Declares an ordered read-write linker set item
- [RTEMS\_LINKER\_RWSET\_ITEM\_REFERENCE] References a read-write linker set item
- [RTEMS\_LINKER\_RWSET\_ITEM] Defines a read-write linker set item
- [RTEMS\_LINKER\_RWSET\_ITEM\_ORDERED] Defines an ordered read-write linker set item
- [RTEMS\_LINKER\_RWSET\_CONTENT] Marks a declaration as a read-write linker set content

# <span id="page-1030-0"></span>41.2 Background

Linker sets are used not only in RTEMS, but also for example in Linux, in FreeBSD, for the GNU C constructor extension and for global C++ constructors. They provide a space efficient and flexible means to initialize modules. A linker set consists of

- dedicated input sections for the linker (e.g. .ctors and .ctors.\* in the case of global constructors),
- a begin marker (e.g. provided by crtbegin.o, and
- an end marker (e.g. provided by crtend.o).

A module may place a certain data item into the dedicated input section. The linker will collect all such data items in this section and create a begin and end marker. The initialization code can then use the begin and end markers to find all the collected data items (e.g. pointers to initialization functions).

In the linker command file of the GNU linker we need the following output section descriptions.

```
1 /* To be placed in a read-only memory region */
2 .rtemsroset : {
3 KEEP (*(SORT(.rtemsroset.*)))
4 }
5 /* To be placed in a read-write memory region */
6 .rtemsrwset : {
7 KEEP (*(SORT(.rtemsrwset.*)))
8 }
```

The KEEP() ensures that a garbage collection by the linker will not discard the content of this section. This would normally be the case since the linker set items are not referenced directly. The SORT() directive sorts the input sections lexicographically. Please note the lexicographical order of the .begin, .content and .end section name parts in the RTEMS linker sets macros which ensures that the position of the begin and end markers are right.

So, what is the benefit of using linker sets to initialize modules? They can be used to initialize and include only those RTEMS managers and other components which are used by the application. For example, in case an application uses message queues, it must call rtems\_message\_queue\_create(). In the module implementing this function, we can place a linker set item and register the message queue handler constructor. Otherwise, in case the application does not use message queues, there will be no reference to the rtems\_message\_queue\_create() function and the constructor is not registered, thus nothing of the message queue handler will be in the final executable.

For an example see test program sptests/splinkersets01.

41.2. Background 1003

# <span id="page-1031-0"></span>41.3 Directives

# <span id="page-1032-1"></span><span id="page-1032-0"></span>41.3.1 RTEMS\_LINKER\_SET\_BEGIN - Designator of the linker set begin marker **CALLING SEQUENCE:**

```
1 type *begin = RTEMS_LINKER_SET_BEGIN( set );
```

#### **DESCRIPTION:**

This macro generates the designator of the begin marker of the linker set identified by set. The item at the begin marker address is the first member of the linker set if it exists, e.g. the linker set is not empty. A linker set is empty, if and only if the begin and end markers have the same address.

The set parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies the linker set.

#### **NOTE:**

The compiler may try to be smart. In general it will not work to assign linker set begin and end addresses to pointer variables and treat them like ordinary pointers. The compiler may exploit the fact that actually two distinct objects are involved and use this to optimize. To avoid trouble use *[RTEMS\\_LINKER\\_SET\\_SIZE - The linker set size](#page-1034-0) [in characters](#page-1034-0)* (page 1007), *[RTEMS\\_LINKER\\_SET\\_ITEM\\_COUNT - The linker set item count](#page-1035-0)* (page 1008), *[RTEMS\\_LINKER\\_SET\\_IS\\_EMPTY - Is the linker set empty?](#page-1036-0)* (page 1009) and *[RTEMS\\_LINKER\\_SET\\_FOREACH - Iterate through the linker set items](#page-1037-0)* (page 1010).

41.3. Directives 1005

# <span id="page-1033-1"></span><span id="page-1033-0"></span>41.3.2 RTEMS\_LINKER\_SET\_END - Designator of the linker set end marker **CALLING SEQUENCE:**

```
1 type *end = RTEMS_LINKER_SET_END( set );
```

#### **DESCRIPTION:**

This macro generates the designator of the end marker of the linker set identified by set. The item at the end marker address is not a member of the linker set. The set parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies the linker set.

#### <span id="page-1034-1"></span><span id="page-1034-0"></span>**CALLING SEQUENCE:**

```
1 size_t size = RTEMS_LINKER_SET_SIZE( set );
```

#### **DESCRIPTION:**

This macro returns the size of the linker set identified by set in characters. The set parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies the linker set.

41.3. Directives 1007

# <span id="page-1035-1"></span><span id="page-1035-0"></span>41.3.4 RTEMS\_LINKER\_SET\_ITEM\_COUNT - The linker set item count

#### **CALLING SEQUENCE:**

```
1 size_t item_count = RTEMS_LINKER_SET_ITEM_COUNT( set );
```

#### **DESCRIPTION:**

This macro returns the item count of the linker set identified by set. The set parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies the linker set.

## <span id="page-1036-1"></span><span id="page-1036-0"></span>41.3.5 RTEMS\_LINKER\_SET\_IS\_EMPTY - Is the linker set empty?

#### **CALLING SEQUENCE:**

```
1 bool is_empty = RTEMS_LINKER_SET_IS_EMPTY( set );
```

#### **DESCRIPTION:**

This macro returns true if the linker set identified by set is empty, otherwise returns false. The set parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies the linker set.

41.3. Directives 1009

# <span id="page-1037-1"></span><span id="page-1037-0"></span>41.3.6 RTEMS\_LINKER\_SET\_FOREACH - Iterate through the linker set items **CALLING SEQUENCE:**

```
1 RTEMS_LINKER_RWSET( myset, int );
3 int count( void )
4 {
5 int *item;
6 int n;
7
8 n = 0;
9 RTEMS_LINKER_SET_FOREACH( myset, item ) {
10 n += *item;
11 }
12
13 return n;
14 }
```

#### **DESCRIPTION:**

This macro generates a for loop statement which iterates through each item of a linker set identified by set. The set parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies the linker set. The item parameter must be a pointer to an item of the linker set. It iterates through all items of the linker set from begin to end.

# <span id="page-1038-1"></span><span id="page-1038-0"></span>41.3.7 RTEMS\_LINKER\_ROSET\_DECLARE - Declares a read-only linker set **CALLING SEQUENCE:**

```
1 RTEMS_LINKER_ROSET_DECLARE( set, type );
```

## **DESCRIPTION:**

This macro generates declarations for the begin and end markers of a read-only linker set identified by set. The set parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies the linker set. The type parameter defines the type of the linker set items. The type must be the same for all macro invocations of a particular linker set.

41.3. Directives 1011

## <span id="page-1039-1"></span><span id="page-1039-0"></span>41.3.8 RTEMS\_LINKER\_ROSET - Defines a read-only linker set

#### **CALLING SEQUENCE:**

```
1 RTEMS_LINKER_ROSET( set, type );
```

#### **DESCRIPTION:**

This macro generates definitions for the begin and end markers of a read-only linker set identified by set. The set parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies the linker set. The type parameter defines the type of the linker set items. The type must be the same for all macro invocations of a particular linker set.

```
1 RTEMS_LINKER_ROSET_ITEM_DECLARE( set, type, item );
```

#### **DESCRIPTION:**

This macro generates a declaration of an item contained in the read-only linker set identified by set. For a description of the set, type, and item parameters see *[RTEMS\\_LINKER\\_ROSET\\_ITEM - Defines a read-only linker set item](#page-1043-0)* (page 1016).

41.3. Directives 1013

<span id="page-1041-1"></span><span id="page-1041-0"></span>41.3.10 RTEMS\_LINKER\_ROSET\_ITEM\_ORDERED\_DECLARE - Declares an ordered read-only linker set item

## **CALLING SEQUENCE:**

```
1 RTEMS_LINKER_ROSET_ITEM_ORDERED_DECLARE( set, type, item, order );
```

#### **DESCRIPTION:**

This macro generates a declaration of an ordered item contained in the read-only linker set identified by set. For a description of the set, type, item, and order parameters see *[RTEMS\\_LINKER\\_ROSET\\_ITEM\\_ORDERED - Defines an ordered read-only linker set item](#page-1044-0)* (page 1017).

## <span id="page-1042-1"></span><span id="page-1042-0"></span>**CALLING SEQUENCE:**

```
1 RTEMS_LINKER_ROSET_ITEM_REFERENCE( set, type, item );
```

#### **DESCRIPTION:**

This macro generates a reference to an item contained in the read-only linker set identified by set. The set parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies the linker set. The type parameter defines the type of the linker set items. The type must be the same for all macro invocations of a particular linker set. The item parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies an item in the linker set.

41.3. Directives 1015

# <span id="page-1043-1"></span><span id="page-1043-0"></span>41.3.12 RTEMS\_LINKER\_ROSET\_ITEM - Defines a read-only linker set item **CALLING SEQUENCE:**

```
1 RTEMS_LINKER_ROSET_ITEM( set, type, item );
```

#### **DESCRIPTION:**

This macro generates a definition of an item contained in the read-only linker set identified by set. The set parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies the linker set. The type parameter defines the type of the linker set items. The type must be the same for all macro invocations of a particular linker set. The item parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies an item in the linker set.

<span id="page-1044-1"></span><span id="page-1044-0"></span>41.3.13 RTEMS\_LINKER\_ROSET\_ITEM\_ORDERED - Defines an ordered read-only linker set item

#### **CALLING SEQUENCE:**

```
1 RTEMS_LINKER_ROSET_ITEM_ORDERED( set, type, item, order );
```

## **DESCRIPTION:**

This macro generates a definition of an ordered item contained in the read-only linker set identified by set. The set parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies the linker set. The type parameter defines the type of the linker set items. The type must be the same for all macro invocations of a particular linker set. The item parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies an item in the linker set. The order parameter must be a valid linker input section name part on which macro expansion is performed. The items are lexicographically ordered according to the order parameter within a linker set. Ordered items are placed before unordered items in the linker set.

## **NOTES:**

To be resilient to typos in the order parameter, it is recommended to use the following construct in macros defining items for a particular linker set (see enum in XYZ\_ITEM()).

```
1 #include <rtems/linkersets.h>
3 typedef struct {
4 int foo;
5 } xyz_item;
6
7 /* The XYZ-order defines */
8 #define XYZ_ORDER_FIRST 0x00001000
9 #define XYZ_ORDER_AND_SO_ON 0x00002000
10
11 /* Defines an ordered XYZ-item */
12 #define XYZ_ITEM( item, order ) \
13 enum { xyz_##item = order }; \
14 RTEMS_LINKER_ROSET_ITEM_ORDERED( \
15 xyz, const xyz_item *, item, order \
16 ) = { &item }
17
18 /* Example item */
19 static const xyz_item some_item = { 123 };
20 XYZ_ITEM( some_item, XYZ_ORDER_FIRST );
```

41.3. Directives 1017

<span id="page-1045-1"></span><span id="page-1045-0"></span>41.3.14 RTEMS\_LINKER\_ROSET\_CONTENT - Marks a declaration as a read-only linker set content

## **CALLING SEQUENCE:**

```
1 RTEMS_LINKER_ROSET_CONTENT( set, decl );
```

#### **DESCRIPTION:**

This macro marks a declaration as a read-only linker set content. The linker set is identified by set. The set parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies the linker set. The decl parameter must be an arbitrary variable declaration.

# <span id="page-1046-1"></span><span id="page-1046-0"></span>41.3.15 RTEMS\_LINKER\_RWSET\_DECLARE - Declares a read-write linker set **CALLING SEQUENCE:**

```
1 RTEMS_LINKER_RWSET_DECLARE( set, type );
```

## **DESCRIPTION:**

This macro generates declarations for the begin and end markers of a read-write linker set identified by set. The set parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies the linker set. The type parameter defines the type of the linker set items. The type must be the same for all macro invocations of a particular linker set.

41.3. Directives 1019

## <span id="page-1047-1"></span><span id="page-1047-0"></span>41.3.16 RTEMS\_LINKER\_RWSET - Defines a read-write linker set

#### **CALLING SEQUENCE:**

```
1 RTEMS_LINKER_RWSET( set, type );
```

#### **DESCRIPTION:**

This macro generates definitions for the begin and end markers of a read-write linker set identified by set. The set parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies the linker set. The type parameter defines the type of the linker set items. The type must be the same for all macro invocations of a particular linker set.

<span id="page-1048-1"></span><span id="page-1048-0"></span>41.3.17 RTEMS\_LINKER\_RWSET\_ITEM\_DECLARE - Declares a read-write linker set item

## **CALLING SEQUENCE:**

```
1 RTEMS_LINKER_RWSET_ITEM_DECLARE( set, type, item );
```

#### **DESCRIPTION:**

This macro generates a declaration of an item contained in the read-write linker set identified by set. For a description of the set, type, and item parameters see *[RTEMS\\_LINKER\\_RWSET\\_ITEM - Defines a read-write linker set item](#page-1051-0)* (page 1024).

41.3. Directives 1021

<span id="page-1049-1"></span><span id="page-1049-0"></span>41.3.18 RTEMS\_LINKER\_RWSET\_ITEM\_ORDERED\_DECLARE - Declares an ordered read-write linker set item

## **CALLING SEQUENCE:**

```
1 RTEMS_LINKER_RWSET_ITEM_ORDERED_DECLARE( set, type, item, order );
```

## **DESCRIPTION:**

This macro generates a declaration of an ordered item contained in the read-write linker set identified by set. For a description of the set, type, item, and order parameters see *[RTEMS\\_LINKER\\_RWSET\\_ITEM\\_ORDERED - Defines an ordered read-write linker set item](#page-1052-0)* (page 1025).

#### <span id="page-1050-1"></span><span id="page-1050-0"></span>**CALLING SEQUENCE:**

```
1 RTEMS_LINKER_RWSET_ITEM_REFERENCE( set, type, item );
```

#### **DESCRIPTION:**

This macro generates a reference to an item contained in the read-write linker set identified by set. The set parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies the linker set. The type parameter defines the type of the linker set items. The type must be the same for all macro invocations of a particular linker set. The item parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies an item in the linker set.

41.3. Directives 1023

<span id="page-1051-1"></span><span id="page-1051-0"></span>41.3.20 RTEMS\_LINKER\_RWSET\_ITEM - Defines a read-write linker set item **CALLING SEQUENCE:**

```
1 RTEMS_LINKER_RWSET_ITEM( set, type, item );
```

#### **DESCRIPTION:**

This macro generates a definition of an item contained in the read-write linker set identified by set. The set parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies the linker set. The type parameter defines the type of the linker set items. The type must be the same for all macro invocations of a particular linker set. The item parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies an item in the linker set.

<span id="page-1052-1"></span><span id="page-1052-0"></span>41.3.21 RTEMS\_LINKER\_RWSET\_ITEM\_ORDERED - Defines an ordered read-write linker set item

## **CALLING SEQUENCE:**

```
1 RTEMS_LINKER_RWSET_ITEM_ORDERED( set, type, item, order );
```

## **DESCRIPTION:**

This macro generates a definition of an ordered item contained in the read-write linker set identified by set. The set parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies the linker set. The type parameter defines the type of the linker set items. The type must be the same for all macro invocations of a particular linker set. The item parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies an item in the linker set. The order parameter must be a valid linker input section name part on which macro expansion is performed. The items are lexicographically ordered according to the order parameter within a linker set. Ordered items are placed before unordered items in the linker set.

## **NOTES:**

To be resilient to typos in the order parameter, it is recommended to use the following construct in macros defining items for a particular linker set (see enum in XYZ\_ITEM()).

```
1 #include <rtems/linkersets.h>
3 typedef struct {
4 int foo;
5 } xyz_item;
6
7 /* The XYZ-order defines */
8 #define XYZ_ORDER_FIRST 0x00001000
9 #define XYZ_ORDER_AND_SO_ON 0x00002000
10
11 /* Defines an ordered XYZ-item */
12 #define XYZ_ITEM( item, order ) \
13 enum { xyz_##item = order }; \
14 RTEMS_LINKER_RWSET_ITEM_ORDERED( \
15 xyz, const xyz_item *, item, order \
16 ) = { &item }
17
18 /* Example item */
19 static const xyz_item some_item = { 123 };
20 XYZ_ITEM( some_item, XYZ_ORDER_FIRST );
```

41.3. Directives 1025

<span id="page-1053-1"></span><span id="page-1053-0"></span>41.3.22 RTEMS\_LINKER\_RWSET\_CONTENT - Marks a declaration as a read-write linker set content

## **CALLING SEQUENCE:**

```
1 RTEMS_LINKER_RWSET_CONTENT( set, decl );
```

## **DESCRIPTION:**

This macro marks a declaration as a read-write linker set content. The linker set is identified by set. The set parameter itself must be a valid C designator on which no macro expansion is performed. It uniquely identifies the linker set. The decl parameter must be an arbitrary variable declaration.

CHAPTER

# **FORTYTWO**

# <span id="page-1054-0"></span>DIRECTIVE STATUS CODES

# <span id="page-1055-0"></span>42.1 Introduction

The directive status code directives are:

â€¢ [rtems\_status\_text] - Return the name for the status code

# <span id="page-1056-1"></span><span id="page-1056-0"></span>42.2 Directives

The directives are:

| RTEMS_SUCCESSFUL         | successful completion                                     |
|--------------------------|-----------------------------------------------------------|
| RTEMS_TASK_EXITTED       | returned from a task                                      |
| RTEMS_MP_NOT_CONFIGURED  | multiprocessing not configured                            |
| RTEMS_INVALID_NAME       | invalid object name                                       |
| RTEMS_INVALID_ID         | invalid object id                                         |
| RTEMS_TOO_MANY           | too many                                                  |
| RTEMS_TIMEOUT            | timed out waiting                                         |
| RTEMS_OBJECT_WAS_DELETED | object was deleted while waiting                          |
| RTEMS_INVALID_SIZE       | invalid specified size                                    |
| RTEMS_INVALID_ADDRESS    | invalid address specified                                 |
| RTEMS_INVALID_NUMBER     | number was invalid                                        |
| RTEMS_NOT_DEFINED        | item not initialized                                      |
| RTEMS_RESOURCE_IN_USE    | resources outstanding                                     |
| RTEMS_UNSATISFIED        | request not satisfied                                     |
| RTEMS_INCORRECT_STATE    | task is in wrong state                                    |
| RTEMS_ALREADY_SUSPENDED  | task already in state                                     |
| RTEMS_ILLEGAL_ON_SELF    | illegal for calling task                                  |
| RTEMS_ILLEGAL_ON_REMOTE_ | illegal for remote object                                 |
| OBJECT                   |                                                           |
| RTEMS_CALLED_FROM_ISR    | invalid environment                                       |
| RTEMS_INVALID_PRIORITY   | invalid task priority                                     |
| RTEMS_INVALID_CLOCK      | invalid time buffer                                       |
| RTEMS_INVALID_NODE       | invalid node id                                           |
| RTEMS_NOT_CONFIGURED     | directive not configured                                  |
| RTEMS_NOT_OWNER_OF_      | not owner of resource                                     |
| RESOURCE                 |                                                           |
| RTEMS_NOT_IMPLEMENTED    | directive not implemented or feature not available in con |
|                          | figuration                                                |
| RTEMS_INTERNAL_ERROR     | RTEMS inconsistency detected                              |
| RTEMS_NO_MEMORY          | could not get enough memory                               |
| RTEMS_IO_ERROR           | driver I/O error                                          |
| RTEMS_INTERRUPTED        | returned by driver to indicate interrupted operation      |
|                          |                                                           |

42.2. Directives 1029

## <span id="page-1057-1"></span><span id="page-1057-0"></span>42.2.1 STATUS\_TEXT - Returns the enumeration name for a status code

#### **CALLING SEQUENCE:**

```
1 const char *rtems_status_text(
2 rtems_status_code code
3 );
```

#### **DIRECTIVE STATUS CODES**

The status code enumeration name or "?" in case the status code is invalid.

## **DESCRIPTION:**

Returns the enumeration name for the specified status code.

# EXAMPLE APPLICATION

```
1 /*
2 * This file contains an example of a simple RTEMS
3 * application. It instantiates the RTEMS Configuration
4 * Information using confdef.h and contains two tasks:
5 * a user initialization task and a simple task.
6 */
7
8 #include <rtems.h>
9
10 rtems_task user_application(rtems_task_argument argument);
11
12 rtems_task init_task(
13 rtems_task_argument ignored
14 )
15 {
16 rtems_id tid;
17 rtems_status_code status;
18 rtems_name name;
19
20 name = rtems_build_name( 'A', 'P', 'P', '1' )
21
22 status = rtems_task_create(
23 name, 1, RTEMS_MINIMUM_STACK_SIZE,
24 RTEMS_NO_PREEMPT, RTEMS_FLOATING_POINT, &tid
25 );
26 if ( status != RTEMS_SUCCESSFUL ) {
27 printf( "rtems_task_create failed with status of %d.\n", status );
28 exit( 1 );
29 }
30
31 status = rtems_task_start( tid, user_application, 0 );
32 if ( status != RTEMS_SUCCESSFUL ) {
33 printf( "rtems_task_start failed with status of %d.\n", status );
34 exit( 1 );
35 }
36
37 status = rtems_task_delete( SELF ); /* should not return */
```

(continues on next page)

(continued from previous page)

```
38
39 printf( "rtems_task_delete returned with status of %d.\n", status );
40 exit( 1 );
41 }
42
43 rtems_task user_application(rtems_task_argument argument)
44 {
45 /* application specific initialization goes here */
46 while ( 1 ) { /* infinite loop */
47 /* APPLICATION CODE GOES HERE
48 *
49 * This code will typically include at least one
50 * directive which causes the calling task to
51 * give up the processor.
52 */
53 }
54 }
55
56 /* The Console Driver supplies Standard I/O. */
57 #define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
58 /* The Clock Driver supplies the clock tick. */
59 #define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
60 #define CONFIGURE_MAXIMUM_TASKS 2
61 #define CONFIGURE_INIT_TASK_NAME rtems_build_name( 'E', 'X', 'A', 'M' )
62 #define CONFIGURE_RTEMS_INIT_TASKS_TABLE
63 #define CONFIGURE_INIT
64 #include <rtems/confdefs.h>
```

# **FORTYFOUR**

# GLOSSARY

#### <span id="page-1060-7"></span><span id="page-1060-0"></span>**ABI**

This term is an acronym for Application Binary Interface.

#### **active**

A term used to describe an object which has been created by an application.

## **AMP**

<span id="page-1060-6"></span>This term is an acronym for Asymmetric Multiprocessing.

#### **APA**

This term is an acronym for Arbitrary Processor Affinity. APA schedulers allow a thread to have an arbitrary affinity to a processor set, rather than a restricted mapping to only one processor of the set or the ability to run on all processors of the set.

It has two variants, *[Weak APA](#page-1078-4)* and *[Strong APA](#page-1075-0)*.

#### **aperiodic task**

<span id="page-1060-1"></span>A task which must execute only at irregular intervals and has only a soft deadline.

## **API**

This term is an acronym for Application Programming Interface.

#### **application**

<span id="page-1060-2"></span>In this document, software which makes use of RTEMS.

## **ASR**

<span id="page-1060-5"></span>This term is an acronym for *[Asynchronous Signal Routine](#page-1060-4)*.

#### **assembler language**

The assembler language is a programming language which can be translated very easily into machine code and data. For this project assembler languages are restricted to languages accepted by the *[GNU](#page-1065-4)* assembler program for the target architectures.

#### **asynchronous**

<span id="page-1060-4"></span>Not related in order or timing to other occurrences in the system.

## **Asynchronous Signal Routine**

Similar to a hardware interrupt except that it is associated with a task and is run in the context of a task. The directives provided by the signal manager are used to service signals.

#### **atomic operations**

<span id="page-1060-3"></span>Atomic operations are defined in terms of *[C11](#page-1061-2)*.

### **awakened**

A term used to describe a task that has been unblocked and may be scheduled to the CPU.

#### <span id="page-1061-6"></span>**BCB**

<span id="page-1061-1"></span>This term is an acronym for Barrier Control Block.

#### **big endian**

A data representation scheme in which the bytes composing a numeric value are arranged such that the most significant byte is at the lowest address.

## **bit-mapped**

A data encoding scheme in which each bit in a variable is used to represent something different. This makes for compact data representation.

## **block**

A physically contiguous area of memory.

#### **blocked task**

The task state entered by a task which has been previously started and cannot continue execution until the reason for waiting has been satisfied. Blocked tasks are not an element of the set of ready tasks of a scheduler instance.

#### **Board Support Package**

<span id="page-1061-3"></span>A collection of device initialization and control routines specific to a particular type of board or collection of boards.

#### **broadcast**

<span id="page-1061-0"></span>To simultaneously send a message to a logical set of destinations.

## **BSP**

This term is an acronym for *[Board Support Package](#page-1061-3)*.

#### **buffer**

<span id="page-1061-4"></span>A fixed length block of memory allocated from a partition.

## **C language**

<span id="page-1061-5"></span>The C language for this project is defined in terms of *[C11](#page-1061-2)*.

## **C++11**

The standard ISO/IEC 14882:2011.

#### **C++14**

The standard ISO/IEC 14882:2014.

## **C++17**

The standard ISO/IEC 14882:2017.

## **C++20**

<span id="page-1061-2"></span>The standard ISO/IEC 14882:2020.

#### **C11**

The standard ISO/IEC 9899:2011.

#### **C17**

The standard ISO/IEC 9899:2018.

#### **calling convention**

The processor and compiler dependent rules which define the mechanism used to invoke subroutines in a high-level language. These rules define the passing of arguments, the call and return mechanism, and the register set which must be preserved.

#### **CCB**

This term is an acronym for Change Control Board.

## <span id="page-1062-6"></span>**Central Processing Unit**

<span id="page-1062-4"></span>This term is equivalent to the terms processor and microprocessor.

#### **chain**

A data structure which allows for efficient dynamic addition and removal of elements. It differs from an array in that it is not limited to a predefined size.

## **Clock Driver**

<span id="page-1062-3"></span>The Clock Driver is a driver which provides the *[clock tick](#page-1062-1)* and a time counter. The time counter is used to drive the *[CLOCK\\_REALTIME](#page-1062-2)* and *[CLOCK\\_MONOTONIC](#page-1062-0)*. The Clock Driver can be initialized by the application with the *[CONFIGURE\\_APPLICATION\\_NEEDS\\_CLOCK\\_DRIVER](#page-625-0)* (page 598) and *[CONFIGURE\\_MICROSECONDS\\_PER\\_TICK](#page-612-0)* (page 585) application configuration options.

#### **clock tick**

<span id="page-1062-1"></span>The clock tick is a coarse time measure provided by RTEMS. The *[Clock Driver](#page-1062-3)* emits clock ticks at rate specified by the *[CONFIGURE\\_MICROSECONDS\\_PER\\_TICK](#page-612-0)* (page 585) application configuration option. In contrast to *[CLOCK\\_REALTIME](#page-1062-2)* and *[CLOCK\\_MONOTONIC](#page-1062-0)*, the clock tick rate is not affected by incremental adjustments.

## **CLOCK\_MONOTONIC**

<span id="page-1062-0"></span>The CLOCK\_MONOTONIC is a clock provided by RTEMS which measures the time since an unspecified starting point. In contrast to *[CLOCK\\_REALTIME](#page-1062-2)*, this clock cannot be set. It may be affected by incremental adjustments for example carried out by the *[NTP](#page-1069-2)* or the use of a *[PPS](#page-1071-4)* signal. See also *[CLOCK\\_REALTIME](#page-1062-2)*, *[clock tick](#page-1062-1)*, and *[Clock Driver](#page-1062-3)*.

## **CLOCK\_REALTIME**

<span id="page-1062-2"></span>The CLOCK\_REALTIME is a clock provided by RTEMS which measures the real time (also known as wall-clock time). It is defined by *[POSIX](#page-1071-2)*. In particular, every day is treated as if it contains exactly 86400 seconds and leap seconds are ignored. This clock can be set by the application which may result in time jumps. It may be affected by incremental adjustments for example carried out by the *[NTP](#page-1069-2)* or the use of a *[PPS](#page-1071-4)* signal. RTEMS can represent time points of this clock in nanoseconds ranging from 1988-01-01T00:00:00.000000000Z to 2514-05- 31T01:53:03.999999999Z. See also *[CLOCK\\_MONOTONIC](#page-1062-0)*, *[clock tick](#page-1062-1)*, and *[Clock Driver](#page-1062-3)*.

#### **cluster**

<span id="page-1062-5"></span>We have clustered scheduling in case the set of processors of a system is partitioned into nonempty pairwise disjoint subsets. These subsets are called clusters. Clusters with a cardinality of one are partitions. Each cluster is owned by exactly one scheduler instance.

## **coalesce**

The process of merging adjacent holes into a single larger hole. Sometimes this process is referred to as garbage collection.

#### **Configuration Table**

A table which contains information used to tailor RTEMS for a particular application.

#### **context**

All of the processor registers and operating system data structures associated with a task.

## **context switch**

Alternate term for task switch. Taking control of the processor from one task and transferring it to another task.

#### **control block**

A data structure used by the executive to define and control an object.

#### <span id="page-1063-3"></span>**core**

When used in this manual, this term refers to the internal executive utility functions. In the interest of application portability, the core of the executive should not be used directly by applications.

## **CPU**

This term is an acronym for *[Central Processing Unit](#page-1062-4)*.

## **critical section**

A section of code which must be executed indivisibly.

## **CRT**

This term is an acronym for Cathode Ray Tube. Normally used in reference to the manmachine interface.

#### **current priority**

<span id="page-1063-0"></span>The current priority of a *[task](#page-1076-3)* is the *[task priority](#page-1077-3)* with respect to the *[home scheduler](#page-1066-0)* of the task. It is an aggregation of the *[real priority](#page-1072-0)* and temporary priority adjustments due to locking protocols, the rate-monotonic period objects on some schedulers such as EDF, and the *[POSIX](#page-1071-2)* sporadic server. The current priority is an *[eligible priority](#page-1064-0)*.

#### **deadline**

A fixed time limit by which a task must have completed a set of actions. Beyond this point, the results are of reduced value and may even be considered useless or harmful.

## **device**

A peripheral used by the application that requires special operation software. See also device driver.

#### **device driver**

Control software for special peripheral devices used by the application.

## **Device Driver Table**

A table which contains the entry points for each of the configured device drivers.

#### **directives**

RTEMS' provided routines that provide support mechanisms for real-time applications.

#### **dispatch**

The act of loading a task's context onto the CPU and transferring control of the CPU to that task.

#### **Doorstop**

[Doorstop](https://github.com/doorstop-dev/doorstop) is a requirements management tool.

#### **dormant**

<span id="page-1063-1"></span>The state entered by a task after it is created and before it has been started.

#### **DPCB**

This term is an acronym for Dual-Ported Memory Control Block.

## **dual-ported**

A term used to describe memory which can be accessed at two different addresses.

#### **dynamic extension sets**

<span id="page-1063-2"></span>The dynamic extension sets are a list of *[user extensions](#page-1078-2)*. The list is defined by the system services used by the application and directive calls such as *[rtems\\_extension\\_create\(\)](#page-579-0)* (page 552). See also *[initial extension sets](#page-1067-1)*.

#### <span id="page-1064-4"></span>**EARS**

This term is an acronym for Easy Approach to Requirements Syntax.

## **EDF**

<span id="page-1064-3"></span>This term is an acronym for Earliest Deadline First.

## **ELF**

<span id="page-1064-0"></span>This term is an acronym for [Executable and Linkable Format.](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)

## **eligible priority**

An eligible priority of a *[task](#page-1076-3)* is the *[task priority](#page-1077-3)* with respect to the corresponding *[eligible](#page-1064-2) [scheduler](#page-1064-2)* of the task. An eligible priority is either the *[current priority](#page-1063-0)* or a *[helping priority](#page-1066-2)* of a task.

#### **eligible scheduler**

<span id="page-1064-2"></span>An eligible scheduler of a *[task](#page-1076-3)* is a *[scheduler](#page-1073-0)* which can be used by the task to allocate a processor for the task.

#### **embedded**

An application that is delivered as a hidden part of a larger system. For example, the software in a fuel-injection control system is an embedded application found in many late-model automobiles.

### **entry point**

The address at which a function or task begins to execute. In C, the entry point of a function is the function's name.

#### **envelope**

A buffer provided by the MPCI layer to RTEMS which is used to pass messages between nodes in a multiprocessor system. It typically contains routing information needed by the MPCI. The contents of an envelope are referred to as a packet.

## **error code**

<span id="page-1064-1"></span>This term has the same meaning as *[status code](#page-1075-1)*.

#### **ESCB**

This term is an acronym for Extension Set Control Block.

#### **events**

A method for task communication and synchronization. The directives provided by the event manager are used to service events.

## **exception**

A synonym for interrupt.

#### **executing task**

The task state entered by a task after it has been given control of the processor. In SMP configurations, a task may be registered as executing on more than one processor for short time frames during task migration. Blocked tasks can be executing until they issue a thread dispatch.

## **executive**

In this document, this term is used to referred to RTEMS. Commonly, an executive is a small real-time operating system used in embedded systems.

#### **exported**

An object known by all nodes in a multiprocessor system. An object created with the GLOBAL attribute will be exported.

### <span id="page-1065-7"></span>**extension forward order**

<span id="page-1065-0"></span>The *[user extensions](#page-1078-2)* may be invoked in extension forward order. In forward order, all user extensions of the *[initial extension sets](#page-1067-1)* are invoked before all user extensions of the *[dynamic](#page-1063-2) [extension sets](#page-1063-2)*. In the initial extension sets the order is defined by the table index. The user extension with the lowest table index is invoked first. In the dynamic extension sets the order is defined by the registration order. The first registered user extension is invoked first. See also *[extension reverse order](#page-1065-1)*.

## **extension reverse order**

<span id="page-1065-1"></span>The *[user extensions](#page-1078-2)* may be invoked in extension reverse order. In reverse order, all user extensions of the *[dynamic extension sets](#page-1063-2)* are invoked before all user extensions of the *[initial](#page-1067-1) [extension sets](#page-1067-1)*. In the dynamic extension sets the order is defined by the registration order. The last registered user extension is invoked first. In the initial extension sets the order is defined by the table index. The user extension with the highest table index is invoked first. See also *[extension forward order](#page-1065-0)*.

## **external address**

The address used to access dual-ported memory by all the nodes in a system which do not own the memory.

#### **FIFO**

<span id="page-1065-3"></span>This term is an acronym for *[First In First Out](#page-1065-5)*.

## **First In First Out**

<span id="page-1065-5"></span>A discipline for manipulating entries in a data structure. See also *[Last In First Out](#page-1067-3)*.

#### **floating point coprocessor**

A component used in computer systems to enhance performance in mathematically intensive situations. It is typically viewed as a logical extension of the primary processor.

## **formal model**

A model of a computing component (hardware or software) that has a mathematically based *[semantics](#page-1074-1)*.

## **freed**

A resource that has been released by the application to RTEMS.

#### **Futex**

This term is an abbreviation for [Fast User-Space Locking.](https://man7.org/linux/man-pages/man2/futex.2.html) The futex support in RTEMS is provided for the barriers of the *[OpenMP](#page-1070-1)* library provided by *[GCC](#page-1065-6)*. It could be used to implement high performance *[SMP](#page-1074-2)* synchronization primitives which offer random-fairness.

## **GCC**

<span id="page-1065-6"></span>This term is an acronym for [GNU Compiler Collection.](https://gcc.gnu.org/)

#### **global**

An object that has been created with the GLOBAL attribute and exported to all nodes in a multiprocessor system.

## **global construction**

<span id="page-1065-2"></span>In the global construction, the C++ global constructors and constructor functions are invoked. See *[Global Construction](#page-119-0)* (page 92).

## **GNAT**

<span id="page-1065-4"></span>*GNAT* is the *[GNU](#page-1065-4)* compiler for Ada, integrated into the *[GCC](#page-1065-6)*.

#### **GNU**

This term is an acronym for [GNU's Not Unix.](https://www.gnu.org/)

#### <span id="page-1066-4"></span>**GPL**

This term is an acronym for [GNU General Public License.](https://www.gnu.org/licenses)

## **GPLv2**

This term is an acronym for [GNU General Public License Version 2.](https://www.gnu.org/licenses/old-licenses/gpl-2.0.html)

## **GPLv3**

This term is an acronym for [GNU General Public License Version 3.](https://www.gnu.org/licenses/gpl-3.0.html)

## **GR712RC**

The [GR712RC](https://www.gaisler.com/index.php/products/components/gr712rc) is a *[system-on-chip](#page-1076-4)* containing two processors of the *[SPARC](#page-1075-2) [target architecture](#page-1076-2)*.

## **GR740**

The [GR740](https://www.gaisler.com/index.php/products/components/gr740) is a *[system-on-chip](#page-1076-4)* containing four processors of the *[SPARC](#page-1075-2) [target architecture](#page-1076-2)*.

#### **handler**

The equivalent of a manager, except that it is internal to RTEMS and forms part of the core. A handler is a collection of routines which provide a related set of functions. For example, there is a handler used by RTEMS to manage all objects.

#### **hard real-time system**

A real-time system in which a missed deadline causes the worked performed to have no value or to result in a catastrophic effect on the integrity of the system.

#### **heap**

A data structure used to dynamically allocate and deallocate variable sized blocks of memory.

## **heir task**

A task is an heir if it is registered as an heir in a processor of the system. A task can be the heir on at most one processor in the system. In case the executing and heir tasks differ on a processor and a thread dispatch is marked as necessary, then the next thread dispatch will make the heir task the executing task.

#### **helping priority**

<span id="page-1066-2"></span>A helping priority of a *[task](#page-1076-3)* is the *[task priority](#page-1077-3)* with respect to the corresponding *[helping](#page-1066-1) [scheduler](#page-1066-1)* of the task. A helping priority is an *[eligible priority](#page-1064-0)*.

#### **helping scheduler**

<span id="page-1066-1"></span>A helping scheduler of a *[task](#page-1076-3)* is a *[scheduler](#page-1073-0)* which is a *[eligible scheduler](#page-1064-2)* and which is not the *[home scheduler](#page-1066-0)* of the task.

## **heterogeneous**

<span id="page-1066-3"></span>A multiprocessor computer system composed of dissimilar processors.

#### **higher priority**

<span id="page-1066-0"></span>A *[task](#page-1076-3)* H has a higher *[priority](#page-1071-1)* than a task L, if task H is more important than task L.

#### **home scheduler**

The home scheduler of a *[task](#page-1076-3)* is a *[scheduler](#page-1073-0)* which is an *[eligible scheduler](#page-1064-2)* and which is assigned to the task during its initialization or explicitly via a directive call such as *[rtems\\_task\\_set\\_scheduler\(\)](#page-164-0)* (page 137).

## **homogeneous**

A multiprocessor computer system composed of a single type of processor.

#### **I/O**

This term is an acronym for Input/Output.

#### <span id="page-1067-8"></span>**ID**

<span id="page-1067-2"></span>An RTEMS assigned identification tag used to access an active object.

#### **IDLE task**

A special low priority task which assumes control of the CPU when no other task is able to execute.

## **ineligible scheduler**

<span id="page-1067-6"></span><span id="page-1067-1"></span>An ineligible scheduler of a *[task](#page-1076-3)* is a *[scheduler](#page-1073-0)* which is not an *[eligible scheduler](#page-1064-2)*.

## **initial extension sets**

The initial extension sets are a table of *[user extensions](#page-1078-2)*. The table is defined by the application configuration for example through the *[CONFIGURE\\_INITIAL\\_EXTENSIONS](#page-602-0)* (page 575) application configuration option. The initial extension sets cannot be altered during runtime through directive calls. See also *[dynamic extension sets](#page-1063-2)*.

#### **interface**

A specification of the methodology used to connect multiple independent subsystems.

#### **internal address**

The address used to access dual-ported memory by the node which owns the memory.

## **interrupt**

A hardware facility that causes the CPU to suspend execution, save its status, and transfer control to a specific location.

## **interrupt level**

A mask used to by the CPU to determine which pending interrupts should be serviced. If a pending interrupt is below the current interrupt level, then the CPU does not recognize that interrupt.

## **interrupt service**

<span id="page-1067-7"></span>An *interrupt service* consists of an *[Interrupt Service Routine](#page-1067-4)* which is called with a user provided argument upon reception of an interrupt service request. The routine is invoked in interrupt context. Interrupt service requests may have a priority and an affinity to a set of processors. An *interrupt service* is a *[software component](#page-1074-3)*.

#### **Interrupt Service Routine**

<span id="page-1067-4"></span><span id="page-1067-0"></span>An ISR is invoked by the CPU to process a pending interrupt.

## **ISR**

This term is an acronym for *[Interrupt Service Routine](#page-1067-4)*.

## **ISVV**

This term is an acronym for Independent Software Verification and Validation.

#### **kernel**

<span id="page-1067-3"></span>In this document, this term is used as a synonym for executive.

#### **Last In First Out**

A discipline for manipulating entries in a data structure. See also *[First In First Out](#page-1065-5)*.

## **LIFO**

This term is an acronym for *[Last In First Out](#page-1067-3)*.

#### **Linear Temporal Logic**

<span id="page-1067-5"></span>This is a logic that states properties about (possibly infinite) sequences of states.

### <span id="page-1068-3"></span>**list**

A data structure which allows for dynamic addition and removal of entries. It is not statically limited to a particular size.

#### **little endian**

A data representation scheme in which the bytes composing a numeric value are arranged such that the least significant byte is at the lowest address.

## **LLVM**

This term is an acronym for [Low Level Virtual Machine.](https://www.llvm.org) The LLVM Project is a collection of modular and reusable compiler and toolchain technologies.

### **local**

An object which was created with the LOCAL attribute and is accessible only on the node it was created and resides upon. In a single processor configuration, all objects are local.

#### **local operation**

The manipulation of an object which resides on the same node as the calling task.

## **logical address**

An address used by an application. In a system without memory management, logical addresses will equal physical addresses.

### **loosely-coupled**

<span id="page-1068-1"></span>A multiprocessor configuration where shared memory is not used for communication.

## **lower priority**

A *[task](#page-1076-3)* L has a lower *[priority](#page-1071-1)* than a task H, if task L is less important than task H.

## **LTL**

This term is an acronym for *[Linear Temporal Logic](#page-1067-5)*.

#### **major number**

The index of a device driver in the Device Driver Table.

#### **manager**

<span id="page-1068-0"></span>A group of related RTEMS' directives which provide access and control over resources.

#### **MCS**

This term is an acronym for Mellor-Crummey Scott.

## **memory pool**

Used interchangeably with heap.

#### **message**

A sixteen byte entity used to communicate between tasks. Messages are sent to message queues and stored in message buffers.

#### **message buffer**

A block of memory used to store messages.

#### **message queue**

An RTEMS object used to synchronize and communicate between tasks by transporting messages between sending and receiving tasks.

## **Message Queue Control Block**

<span id="page-1068-2"></span>A data structure associated with each message queue used by RTEMS to manage that message queue.

#### <span id="page-1069-4"></span>**minor number**

A numeric value passed to a device driver, the exact usage of which is driver dependent.

#### **mode**

An entry in a task's control block that is used to determine if the task allows preemption, timeslicing, processing of signals, and the interrupt disable level used by the task.

#### **MPCI**

<span id="page-1069-0"></span>This term is an acronym for *[Multiprocessor Communications Interface Layer](#page-1069-3)*.

## **MrsP**

This term is an acronym for Multiprocessor Resource-Sharing Protocol.

#### **multiprocessing**

The simultaneous execution of two or more processes by a multiple processor computer system.

#### **multiprocessor**

<span id="page-1069-3"></span>A computer with multiple CPUs available for executing applications.

#### **Multiprocessor Communications Interface Layer**

A set of user-provided routines which enable the nodes in a multiprocessor system to communicate with one another.

## **Multiprocessor Configuration Table**

The data structure defining the characteristics of the multiprocessor target system with which RTEMS will communicate.

#### **multitasking**

The alternation of execution amongst a group of processes on a single CPU. A scheduling algorithm is used to determine which process executes at which time.

## **mutual exclusion**

A term used to describe the act of preventing other tasks from accessing a resource simultaneously.

#### **nested**

A term used to describe an ASR that occurs during another ASR or an ISR that occurs during another ISR.

#### **node**

A term used to reference a processor running RTEMS in a multiprocessor system.

## **non-existent**

<span id="page-1069-2"></span>The state occupied by an uncreated or deleted task.

#### **NTP**

<span id="page-1069-1"></span>This term is an acronym for [Network Time Protocol.](https://en.wikipedia.org/wiki/Network_Time_Protocol)

#### **NUMA**

This term is an acronym for Non-Uniform Memory Access.

## **numeric coprocessor**

A component used in computer systems to enhance performance in mathematically intensive situations. It is typically viewed as a logical extension of the primary processor.

## **OBC**

This term is an acronym for On-Board Computer.

### <span id="page-1070-4"></span>**object**

In this document, this term is used to refer collectively to tasks, timers, message queues, partitions, regions, semaphores, ports, and rate monotonic periods. All RTEMS objects have IDs and user-assigned names.

#### **object-oriented**

A term used to describe systems with common mechanisms for utilizing a variety of entities. Object-oriented systems shield the application from implementation details.

#### **OMIP**

<span id="page-1070-2"></span>This term is an acronym for O(m) Independence-Preserving Protocol. OMIP is a generalization of the *[priority inheritance](#page-1071-5)* locking protocol to clustered scheduling. The m denotes the number of processors in the system.

## **OpenMP**

<span id="page-1070-1"></span>This term is an acronym for [Open Multi-Processing.](https://www.openmp.org/)

#### **operating system**

The software which controls all the computer's resources and provides the base upon which application programs can be written.

#### **overhead**

The portion of the CPUs processing power consumed by the operating system.

## **packet**

A buffer which contains the messages passed between nodes in a multiprocessor system. A packet is the contents of an envelope.

## **partition**

This term has two definitions:

- 1. A partition is an RTEMS object which is used to allocate and deallocate fixed size blocks of memory from an dynamically specified area of memory.
- <span id="page-1070-3"></span>2. A *[cluster](#page-1062-5)* with a cardinality of one is a partition.

## **Partition Control Block**

<span id="page-1070-0"></span>A data structure associated with each partition used by RTEMS to manage that partition.

#### **PCB**

This term is an acronym for Period Control Block.

#### **pending**

A term used to describe a task blocked waiting for an event, message, semaphore, or signal.

#### **periodic task**

A task which must execute at regular intervals and comply with a hard deadline.

#### **physical address**

The actual hardware address of a resource.

## **poll**

A mechanism used to determine if an event has occurred by periodically checking for a particular status. Typical events include arrival of data, completion of an action, and errors.

#### **pool**

A collection from which resources are allocated.

#### **portability**

A term used to describe the ease with which software can be rehosted on another computer.

#### <span id="page-1071-7"></span>**POSIX**

<span id="page-1071-2"></span>This term is an acronym for [Portable Operating System Interface.](https://en.wikipedia.org/wiki/POSIX)

#### **posting**

<span id="page-1071-4"></span>The act of sending an event, message, semaphore, or signal to a task.

## **PPS**

This term is an acronym for [Pulse-Per-Second.](https://en.wikipedia.org/wiki/Pulse-per-second_signal)

#### **preempt**

<span id="page-1071-1"></span>The act of forcing a task to relinquish the processor and dispatching to another task.

## **priority**

The priority is a mechanism used to represent the relative importance of an element in a set of items.

For example, *[RTEMS](#page-1073-3)* uses *[task priorities](#page-1077-3)* to determine which *[task](#page-1076-3)* should execute on a processor. In RTEMS, priorities are represented by non-negative integers.

For the Classic *[API](#page-1060-1)*, if a numerical priority value A is greater than a numerical priority value B, then A expresses a *[lower priority](#page-1068-1)* than B. If a numerical priority value C is less than a numerical priority value D, then C expresses a *[higher priority](#page-1066-3)* than D.

For the *[POSIX](#page-1071-2)* API, if a numerical priority value R is less than a numerical priority value S, then R expresses a lower priority than S. If a numerical priority value T is greater than a numerical priority value U, then T expresses a higher priority than U.

#### **priority boosting**

<span id="page-1071-0"></span>A simple approach to extend the priority inheritance protocol for clustered scheduling is priority boosting. In case a mutex is owned by a task of another cluster, then the priority of the owner task is raised to an artificially high priority. This approach is not used in RTEMS, see also *[OMIP](#page-1070-2)*.

## **priority inheritance**

<span id="page-1071-5"></span>An algorithm that calls for the lower priority task holding a resource to have its priority increased to that of the highest priority task blocked waiting for that resource. This avoids the problem of priority inversion.

#### **priority inversion**

A form of indefinite postponement which occurs when a high priority tasks requests access to shared resource currently allocated to low priority task. The high priority task must block until the low priority task releases the resource.

#### **processor utilization**

The percentage of processor time used by a task or a set of tasks.

#### **proxy**

An RTEMS control structure used to represent, on a remote node, a task which must block as part of a remote operation.

## **Proxy Control Block**

<span id="page-1071-6"></span><span id="page-1071-3"></span>A data structure associated with each proxy used by RTEMS to manage that proxy.

## **PTCB**

This term is an acronym for *[Partition Control Block](#page-1070-3)*.

# **PXCB**

This term is an acronym for *[Proxy Control Block](#page-1071-6)*.

### <span id="page-1072-5"></span>**QCB**

<span id="page-1072-1"></span>This term is an acronym for *[Message Queue Control Block](#page-1068-2)*.

#### **quantum**

The application defined unit of time in which the processor is allocated.

#### **queue**

<span id="page-1072-4"></span>Alternate term for message queue.

#### **ready task**

A task occupies this state when it is available to be given control of a processor. A ready task has no processor assigned. The scheduler decided that other tasks are currently more important. A task that is ready to execute and has a processor assigned is called scheduled.

## **real priority**

<span id="page-1072-0"></span>Each *[task](#page-1076-3)* has exactly one real priority. The real priority is always with respect to the *[home](#page-1066-0) [scheduler](#page-1066-0)* of a task. It is defined during task initialization. It may be changed by directives such as *[rtems\\_task\\_set\\_priority\(\)](#page-155-0)* (page 128) and *[rtems\\_task\\_set\\_scheduler\(\)](#page-164-0)* (page 137). The real priority is the foundation of the *[current priority](#page-1063-0)*.

#### **real-time**

A term used to describe systems which are characterized by requiring deterministic response times to external stimuli. The external stimuli require that the response occur at a precise time or the response is incorrect.

#### **reentrant**

<span id="page-1072-2"></span>A term used to describe routines which do not modify themselves or global variables.

#### **refinement**

A *refinement* is a relationship between a specification and its implementation as code.

#### **region**

An RTEMS object which is used to allocate and deallocate variable size blocks of memory from a dynamically specified area of memory.

#### **Region Control Block**

<span id="page-1072-3"></span>A data structure associated with each region used by RTEMS to manage that region.

#### **registers**

Registers are locations physically located within a component, typically used for device control or general purpose storage.

## **reification**

Another term used to denote *[refinement](#page-1072-2)*.

#### **remote**

Any object that does not reside on the local node.

#### **remote operation**

The manipulation of an object which does not reside on the same node as the calling task.

#### **ReqIF**

This term is an acronym for [Requirements Interchange Format.](https://www.omg.org/spec/ReqIF/About-ReqIF/)

#### **resource**

A hardware or software entity to which access must be controlled.

#### **resume**

Removing a task from the suspend state. If the task's state is ready following a call to the

<span id="page-1073-6"></span>rtems\_task\_resume directive, then the task is available for scheduling.

#### **return code**

<span id="page-1073-4"></span>This term has the same meaning as *[status code](#page-1075-1)*.

#### **return value**

<span id="page-1073-2"></span>The value returned by a function. A return value may be a *[status code](#page-1075-1)*.

## **RNCB**

This term is an acronym for *[Region Control Block](#page-1072-3)*.

#### **round-robin**

A task scheduling discipline in which tasks of equal priority are executed in the order in which they are made ready.

#### **RS-232**

<span id="page-1073-3"></span>A standard for serial communications.

#### **RTEMS**

This term is an acronym for Real-Time Executive for Multiprocessor Systems.

## **RTEMS epoch**

<span id="page-1073-1"></span>The RTEMS epoch is a point in time. It is 1988-01-01T00:00:00Z in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) time format.

### **running**

The state of a rate monotonic timer while it is being used to delineate a period. The timer exits this state by either expiring or being canceled.

## **scenario**

In the context of formal verification, in a setting that involves many concurrent tasks that interleave in arbitrary ways, a scenario describes a single specific possible interleaving. One interpretation of the behaviour of a concurrent system is the set of all its scenarios.

## **schedulable**

A set of tasks which can be guaranteed to meet their deadlines based upon a specific scheduling algorithm.

# **schedule**

The process of choosing which task should next enter the executing state.

#### **scheduled task**

<span id="page-1073-5"></span>A task is scheduled if it is allowed to execute and has a processor assigned. Such a task executes currently on a processor or is about to start execution. A task about to start execution it is an heir task on exactly one processor in the system.

## **scheduler**

<span id="page-1073-0"></span>A scheduler or scheduling algorithm allocates processors to a subset of its set of ready tasks. So it manages access to the processor resource. Various algorithms exist to choose the tasks allowed to use a processor out of the set of ready tasks. One method is to assign each task a priority number and assign the tasks with the lowest priority number to one processor of the set of processors owned by a scheduler instance.

A scheduler is either an *[eligible scheduler](#page-1064-2)* or a *[ineligible scheduler](#page-1067-6)* for a task. An *[eligible sched](#page-1064-2)[uler](#page-1064-2)* is either the *[home scheduler](#page-1066-0)* or a *[helping scheduler](#page-1066-1)* for a task.

## **scheduler instance**

A scheduler instance is a scheduling algorithm with a corresponding context to store its internal state. Each processor in the system is owned by at most one scheduler instance. The <span id="page-1074-5"></span>processor to scheduler instance assignment is determined at application configuration time. See *[Clustered Scheduler Configuration](#page-756-0)* (page 729)

#### **segments**

<span id="page-1074-1"></span>Variable sized memory blocks allocated from a region.

## **semantics**

This term refers to the meaning of text or utterances in some language. In a software engineering context these will be programming, modelling or specification languages.

## **semaphore**

An RTEMS object which is used to synchronize tasks and provide mutually exclusive access to resources.

## **Semaphore Control Block**

<span id="page-1074-4"></span>A data structure associated with each semaphore used by RTEMS to manage that semaphore.

## **shared memory**

Memory which is accessible by multiple nodes in a multiprocessor system.

## **signal**

An RTEMS provided mechanism to communicate asynchronously with a task. Upon reception of a signal, the ASR of the receiving task will be invoked.

#### **signal set**

A thirty-two bit entity which is used to represent a task's collection of pending signals and the signals sent to a task.

#### **SIS**

This term is an acronym for Simple Instruction Simulator. The SIS is a *[SPARC](#page-1075-2)* V7/V8 and RISC-V RV32IMACFD *[target architecture](#page-1076-2)* simulator.

## **SMCB**

<span id="page-1074-2"></span><span id="page-1074-0"></span>This term is an acronym for *[Semaphore Control Block](#page-1074-4)*.

## **SMP**

This term is an acronym for Symmetric Multiprocessing.

#### **SMP barriers**

The SMP barriers ensure that a defined set of independent threads of execution on a set of processors reaches a common synchronization point in time. They are implemented using atomic operations. Currently a sense barrier is used in RTEMS.

## **SMP locks**

The SMP locks ensure mutual exclusion on the lowest level and are a replacement for the sections of disabled interrupts. Interrupts are usually disabled while holding an SMP lock. They are implemented using atomic operations. Currently a ticket lock is used in RTEMS.

#### **soft real-time system**

A real-time system in which a missed deadline does not compromise the integrity of the system.

## **software component**

<span id="page-1074-3"></span>This term is defined by ECSS-E-ST-40C 3.2.28 as a "part of a software system". For this project a *software component* shall be any of the following items and nothing else:

- *[software unit](#page-1075-3)*
- explicitly defined *[ELF](#page-1064-3)* symbol in a *[source code](#page-1075-4)* file

- <span id="page-1075-6"></span>â€¢ *[assembler language](#page-1060-5)* data in a source code file
- *[C language](#page-1061-4)* object with static storage duration
- C language object with thread-local storage duration
- *[thread](#page-1077-0)*
- *[interrupt service](#page-1067-7)*
- collection of *software components* (this is a software architecture element)

Please note that explicitly defined ELF symbols and assembler language data are considered a software component only if they are defined in a *[source code](#page-1075-4)* file. For example, this rules out symbols and data generated as side-effects by the toolchain (compiler, assembler, linker) such as jump tables, linker trampolines, exception frame information, etc.

#### **software item**

<span id="page-1075-5"></span>This term has the same meaning as *[software product](#page-1075-5)*.

### **software product**

<span id="page-1075-3"></span>The *software product* is the *[RTEMS](#page-1073-3)* real-time operating system.

## **software unit**

This term is defined by ECSS-E-ST-40C 3.2.24 as a "separately compilable piece of source code". For this project a *software unit* shall be any of the following items and nothing else:

- *[assembler language](#page-1060-5)* function in a *[source code](#page-1075-4)* file
- *[C language](#page-1061-4)* function (external and internal linkage)

<span id="page-1075-4"></span>A *software unit* is a *[software component](#page-1074-3)*.

## **source code**

This project uses the *source code* definition of the [Linux Information Project:](http://www.linfo.org/source_code.html) "Source code (also referred to as source or code) is the version of software as it is originally written (i.e., typed into a computer) by a human in plain text (i.e., human readable alphanumeric characters)."

#### **SPARC**

<span id="page-1075-2"></span>This term is an acronym for [Scalable Processor ARChitecture.](https://en.wikipedia.org/wiki/SPARC) See also *[target architecture](#page-1076-2)*.

## **sporadic task**

A task which executes at irregular intervals and must comply with a hard deadline. A minimum period of time between successive iterations of the task can be guaranteed.

#### **stack**

A data structure that is managed using a Last In First Out (LIFO) discipline. Each task has a stack associated with it which is used to store return information and local variables.

#### **status code**

<span id="page-1075-1"></span>A status code indicates the completion status of an operation. For example most RTEMS directives return a status code through the *[return value](#page-1073-4)* to indicate a successful operation or error conditions.

#### **Strong APA**

<span id="page-1075-0"></span>Strong APA is a specialization of *[APA](#page-1060-6)*. Schedulers which implement strong APA recursively searches for a processor in the *[thread](#page-1077-0)*'s affinity set, whenever a thread becomes ready for execution, followed by the processors in the affinity set of threads that are assigned the processor present in the ready thread's affinity set. This is done to find a thread to processor mapping <span id="page-1076-6"></span>that does not violate the priority ordering and to provide a thread to processor mapping with a higher total priority of the threads allocated a processor. Similar analysis is done when a thread blocks. See also [\[CGB14\]](#page-1082-9).

#### **suspend**

A term used to describe a task that is not competing for the CPU because it has had a rtems\_task\_suspend directive.

#### **synchronous**

Related in order or timing to other occurrences in the system.

## **system call**

<span id="page-1076-4"></span>In this document, this is used as an alternate term for directive.

## **system-on-chip**

This project uses the [system on a chip definition of Wikipedia:](https://en.wikipedia.org/wiki/System_on_a_chip%3E) "A system on a chip or systemon-chip is an integrated circuit that integrates most or all components of a computer or other electronic system."

<span id="page-1076-0"></span>Systems on a chip are *[target](#page-1076-0)* systems for applications using *[RTEMS](#page-1073-3)*.

#### **target**

The system on which the application will ultimately execute.

## **target architecture**

<span id="page-1076-2"></span>The target architecture is the instruction set architecture (ISA) of the *[target](#page-1076-0)*. Some RTEMS features depend on the target architecture. For the details consult the *RTEMS CPU Architecture Supplement*.

## **TAS**

<span id="page-1076-3"></span>This term is an acronym for Test-And-Set.

## **task**

This project uses the [thread definition of Wikipedia:](https://en.wikipedia.org/wiki/Thread_(computing)) "a thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler, which is typically a part of the operating system."

It consists normally of a set of registers and a stack. The scheduler assigns processors to a subset of the ready tasks. The terms task and *[thread](#page-1077-0)* are synonym in RTEMS. The term task is used throughout the Classic API, however, internally in the operating system implementation and the POSIX API the term thread is used.

<span id="page-1076-5"></span>A *task* is a *[software component](#page-1074-3)*.

## **Task Control Block**

<span id="page-1076-1"></span>A data structure associated with each task used by RTEMS to manage that task.

#### **task entry**

The task entry is invoked to execute the task's job. Before the task entry is invoked, the thread begin *[user extensions](#page-1078-2)* run in the context of the task. After the return of the task entry, the thread exitted user extensions run in the context of the task. The first user initialization task performs the *[global construction](#page-1065-2)* after running the thread begin extensions and before the task entry is invoked. See also *[rtems\\_task\\_start\(\)](#page-145-0)* (page 118).

#### **task migration**

Task migration happens in case a task stops execution on one processor and resumes execution on another processor.

### <span id="page-1077-6"></span>**task priority**

<span id="page-1077-3"></span>A task *[priority](#page-1071-1)* of a *[task](#page-1076-3)* determines its importance relative to other tasks.

The scheduler use task priorities to determine which *[ready task](#page-1072-4)* gets a processor allocated, see *[scheduled task](#page-1073-5)*. The *[eligible priorities](#page-1064-0)* of a task define the position of the task in a *[wait queue](#page-1078-0)* which uses the priority discipline. Each task has at least the *[real priority](#page-1072-0)*.

Task priorities are used in *[wait queues](#page-1078-0)* which use the priority discipline to determine the dequeueing order of tasks.

## **task processor affinity**

The set of processors on which a task is allowed to execute.

## **task switch**

Alternate terminology for context switch. Taking control of the processor from one task and given to another.

#### **TCB**

<span id="page-1077-1"></span><span id="page-1077-0"></span>This term is an acronym for *[Task Control Block](#page-1076-5)*.

#### **thread**

This term has the same meaning as *[task](#page-1076-3)*.

#### **thread dispatch**

The thread dispatch transfers control of the processor from the currently executing thread to the heir thread of the processor.

#### **tick**

The basic unit of time used by RTEMS. It is a user-configurable number of microseconds. The current tick expires when a clock tick directive is invoked.

## **tightly-coupled**

A multiprocessor configuration system which communicates via shared memory.

## **timeout**

An argument provided to a number of directives which determines the maximum length of time an application task is willing to wait to acquire the resource if it is not immediately available.

#### **timer**

An RTEMS object used to invoke subprograms at a later time.

## **Timer Control Block**

<span id="page-1077-5"></span>A data structure associated with each timer used by RTEMS to manage that timer.

## **timeslice**

The application defined unit of time in which the processor is allocated.

#### **timeslicing**

A task scheduling discipline in which tasks of equal priority are executed for a specific period of time before being preempted by another task.

## <span id="page-1077-2"></span>**TLS**

This term is an acronym for Thread-Local Storage [\[Dre13\]](#page-1083-13). TLS is available in *[C11](#page-1061-2)* and *[C++11](#page-1061-5)*. The support for TLS depends on the CPU port [\[RTE\]](#page-1082-10).

## **TMCB**

<span id="page-1077-4"></span>This term is an acronym for *[Timer Control Block](#page-1077-5)*.

### <span id="page-1078-6"></span>**transient overload**

A temporary rise in system activity which may cause deadlines to be missed. Rate Monotonic Scheduling can be used to determine if all deadlines will be met under transient overload.

## **TTAS**

<span id="page-1078-3"></span>This term is an acronym for Test and Test-And-Set.

## **Unix epoch**

<span id="page-1078-1"></span>The Unix epoch is a point in time. It is 1970-01-01T00:00:00Z in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) time format.

## **User Extension Table**

<span id="page-1078-2"></span>A table which contains the entry points for each user extensions.

## **user extensions**

User extensions are software routines provided by the application to enhance the functionality of RTEMS. An active user extension is either in the *[initial extension sets](#page-1067-1)* or the *[dynamic](#page-1063-2) [extension sets](#page-1063-2)*. User extensions are invoked in *[extension forward order](#page-1065-0)* or *[extension reverse](#page-1065-1) [order](#page-1065-1)*.

#### **User Initialization Tasks Table**

A table which contains the information needed to create and start each of the user initialization tasks.

### **user-provided**

<span id="page-1078-5"></span>These terms are used to designate any software routines which must be written by the application designer.

#### **user-supplied**

This term has the same meaning as *[user-provided](#page-1078-5)*.

#### **vector**

Memory pointers used by the processor to fetch the address of routines which will handle various exceptions and interrupts.

#### **wait queue**

<span id="page-1078-0"></span>The list of tasks blocked pending the release of a particular resource. Message queues, regions, and semaphores have a wait queue associated with them.

#### **Weak APA**

<span id="page-1078-4"></span>Weak APA is a specialization of *[APA](#page-1060-6)*. This refers to Linux's push and pull implementation of APA model. When a *[thread](#page-1077-0)* becomes ready for execution, it is allocated a processor if there is an idle processor, or a processor executing a lower priority thread in its affinity set. Unlike *[Strong APA](#page-1075-0)*, no thread is migrated from its processor to find a thread to processor mapping. See also [\[CGB14\]](#page-1082-9).

#### **YAML**

This term is an acronym for [YAML Ain't Markup Language.](https://yaml.org/)

#### **yield**

When a task voluntarily releases control of the processor.

CHAPTER

# **FORTYFIVE**

# <span id="page-1080-0"></span>REFERENCES

# BIBLIOGRAPHY

- <span id="page-1082-10"></span><span id="page-1082-0"></span>[RTE] RTEMS CPU Architecture Supplement. URL: [https://docs.rtems.org/docs/main/](https://docs.rtems.org/docs/main/cpu-supplement.pdf) [cpu-supplement.pdf.](https://docs.rtems.org/docs/main/cpu-supplement.pdf)
- <span id="page-1082-6"></span>[BBB+13] Dave Banham, Andrew Banks, Mark Bradbury, Paul Burden, Mark Dawson-Butterworth, Mike Hennell, Chris Hills, Steve Montgomery, Chris Tapp, and Liz Whiting. *MISRA C:2012 Guidelines for the Use of the C Language in Critical Systems*. MISRA Limited, March 2013. ISBN 978-1906400101.
- <span id="page-1082-8"></span>[Boe12] Hans-J. Boehm. Can Seqlocks Get Along With Programming Language Memory Models? Technical Report, HP Laboratories, June 2012. HPL-2012-68. URL: [http:](http://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf) [//www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf.](http://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf)
- <span id="page-1082-7"></span>[Bra11] BjÃ¶rn B. Brandenburg. *Scheduling and Locking in Multiprocessor Real-Time Operating Systems*. PhD thesis, The University of North Carolina at Chapel Hill, 2011. URL: [http://www.cs.unc.edu/~bbb/diss/brandenburg-diss.pdf.](http://www.cs.unc.edu/~bbb/diss/brandenburg-diss.pdf)
- <span id="page-1082-4"></span>[Bra13] BjÃ¶rn B. Brandenburg. A Fully Preemptive Multiprocessor Semaphore Protocol for Latency-Sensitive Real-Time Applications. In *Proceedings of the 25th Euromicro Conference on Real-Time Systems (ECRTS 2013)*, 292â€“302. 2013. URL: [http:](http://www.mpi-sws.org/~bbb/papers/pdf/ecrts13b.pdf) [//www.mpi-sws.org/~bbb/papers/pdf/ecrts13b.pdf.](http://www.mpi-sws.org/~bbb/papers/pdf/ecrts13b.pdf)
- <span id="page-1082-5"></span>[Bur91] A. Burns. Scheduling hard real-time systems: a review. *Software Engineering Journal*, 6:116â€“128, 1991.
- <span id="page-1082-1"></span>[BW01] A. Burns and A. J. Wellings. *Real-Time Systems and Programming Languages: Ada, Real-Time Java and C/Real-Time POSIX*. Addison-Wesley, November 2001. ISBN 978-0321417459.
- <span id="page-1082-2"></span>[BW13] A. Burns and A. J. Wellings. A Schedulability Compatible Multiprocessor Resource Sharing Protocol - MrsP. In *Proceedings of the 25th Euromicro Conference on Real-Time Systems (ECRTS 2013)*. 2013. URL: [http://www-users.cs.york.ac.uk/~burns/](http://www-users.cs.york.ac.uk/~burns/MRSPpaper.pdf) [MRSPpaper.pdf.](http://www-users.cs.york.ac.uk/~burns/MRSPpaper.pdf)
- <span id="page-1082-3"></span>[CBHM15] Sebastiano Catellani, Luca Bonato, Sebastian Huber, and Enrico Mezzetti. Challenges in the Implementation of MrsP. In *Reliable Software Technologies - Ada-Europe 2015*, 179â€“195. 2015.
- <span id="page-1082-9"></span>[CGB14] Felipe Cerqueira, Arpan Gujarati, and BjÃ¶rn B. Brandenburg. Linux's Processor Affinity API, Refined: Shifting Real-Time Tasks towards Higher Schedulability. In *Proceedings of the 35th IEEE Real-Time Systems Symposium (RTSS 2014)*. 2014. URL: [http://www.mpi-sws.org/~bbb/papers/pdf/rtss14f.pdf.](http://www.mpi-sws.org/~bbb/papers/pdf/rtss14f.pdf)

- <span id="page-1083-7"></span>[CvdBruggenC16] Kuan-Hsun Chen, Georg von der BrÃ¼ggen, and Jian-Jia Chen. Overrun Handling for Mixed-Criticality Support in RTEMS. In *Mixed Criticality Systems - WMC 2016*, 13â€“14. 2016. URL: [http://ls12-www.cs.tu-dortmund.de/daes/media/](http://ls12-www.cs.tu-dortmund.de/daes/media/documents/publications/downloads/2016-wmc.pdf) [documents/publications/downloads/2016-wmc.pdf.](http://ls12-www.cs.tu-dortmund.de/daes/media/documents/publications/downloads/2016-wmc.pdf)
- <span id="page-1083-10"></span>[CMV14] Davide Compagnin, Enrico Mezzetti, and Tullio Vardanega. Putting RUN into practice: implementation and evaluation. In *Proceedings of the 26th Euromicro Conference on Real-Time Systems (ECRTS 2014)*. 2014.
- <span id="page-1083-8"></span>[Dre07] Ulrich Drepper. *What Every Programmer Should Know About Memory*. 2007. URL: [http://www.akkadia.org/drepper/cpumemory.pdf.](http://www.akkadia.org/drepper/cpumemory.pdf)
- <span id="page-1083-13"></span>[Dre13] Ulrich Drepper. *ELF Handling For Thread-Local Storage*. 2013. URL: [http://www.](http://www.akkadia.org/drepper/tls.pdf) [akkadia.org/drepper/tls.pdf.](http://www.akkadia.org/drepper/tls.pdf)
- <span id="page-1083-9"></span>[FRK02] Hubertus Franke, Rusty Russel, and Matthew Kirkwood. Fuss, Futexes and Furwocks: Fast Userlevel Locking in Linux. In *Proceedings of the Ottawa Linux Symposium 2002*, 479â€“495. 2002. URL: [https://www.kernel.org/doc/ols/2002/](https://www.kernel.org/doc/ols/2002/ols2002-pages-479-495.pdf) [ols2002-pages-479-495.pdf.](https://www.kernel.org/doc/ols/2002/ols2002-pages-479-495.pdf)
- <span id="page-1083-3"></span>[GN06] Thomas Gleixner and Douglas Niehaus. Hrtimers and Beyond: Transforming the Linux Time Subsystems. In *Proceedings of the Linux Symposium*, 333â€“346. 2006. URL: [https://www.kernel.org/doc/ols/2006/ols2006v1-pages-333-346.pdf.](https://www.kernel.org/doc/ols/2006/ols2006v1-pages-333-346.pdf)
- <span id="page-1083-11"></span>[GCB13] Arpan Gujarati, Felipe Cerqueira, and BjÃ¶rn B. Brandenburg. Schedulability Analysis of the Linux Push and Pull Scheduler with Arbitrary Processor Affinities. In *Proceedings of the 25th Euromicro Conference on Real-Time Systems (ECRTS 2013)*. 2013. URL: [https://people.mpi-sws.org/~bbb/papers/pdf/ecrts13a-rev1.pdf.](https://people.mpi-sws.org/~bbb/papers/pdf/ecrts13a-rev1.pdf)
- <span id="page-1083-5"></span>[LSD89] J. Lehoczky, L. Sha, and Y. Ding. The rate monotonic scheduling algorithm: exact characterization and average case behavior. In *Real-Time Systems Symposium*, 166â€“171. 1989.
- <span id="page-1083-4"></span>[LL73] C. L. Liu and James W. Layland. Scheduling Algorithms for Multiprogramming in a Hard-Real-Time Environment. *Journal of the ACM*, 20:46â€“61, 1973.
- <span id="page-1083-12"></span>[LLF+16] Jean-Pierre Lozi, Baptiste Lepers, Justin Funston, Fabien Gaud, Vivien QuÃ©ma, and Alexandra Fedorova. The Linux Scheduler: a Decade of Wasted Cores. In *Proceedings of the Eleventh European Conference on Computer Systems (EuroSys '16)*. 2016. URL: [https://hal.archives-ouvertes.fr/hal-01295194/document.](https://hal.archives-ouvertes.fr/hal-01295194/document)
- <span id="page-1083-0"></span>[Mot88] Motorola. *Real Time Executive Interface Definition*. Motorola Inc., Microcomputer Division and Software Components Group, Inc., January 1988. DRAFT 2.1. URL: [https://ftp.rtems.org/pub/rtems/publications/RTEID-ORKID/RTEID-2.](https://ftp.rtems.org/pub/rtems/publications/RTEID-ORKID/RTEID-2.1/RTEID-2_1.pdf) [1/RTEID-2\\_1.pdf.](https://ftp.rtems.org/pub/rtems/publications/RTEID-ORKID/RTEID-2.1/RTEID-2_1.pdf)
- <span id="page-1083-6"></span>[SG90] Lui Sha and J. B. Goodenough. Real-time scheduling theory and Ada. *Computer*, 23:53â€“62, 1990.
- <span id="page-1083-1"></span>[SRL90] Lui Sha, Ragunathan Rajkumar, and John P. Lehoczky. Priority Inheritance Protocols: An Approach to Real-Time Synchronization. *IEEE Transactions on Computers*, 39:1175â€“1185, 1990.
- <span id="page-1083-2"></span>[VC95] G. Varghese and A. Costello. Redesigning the BSD callout and timer facilities. Technical Report, Washington University in St. Louis, November 1995. WUCS-95-23. URL: [http://web.mit.edu/afs.new/sipb/user/daveg/ATHENA/Info/](http://web.mit.edu/afs.new/sipb/user/daveg/ATHENA/Info/wucs-95-23.ps) [wucs-95-23.ps.](http://web.mit.edu/afs.new/sipb/user/daveg/ATHENA/Info/wucs-95-23.ps)

1056 Bibliography

- <span id="page-1084-1"></span>[VL87] G. Varghese and T. Lauck. Hashed and Hierarchical Timing Wheels: Data Structures for the Efficient Implementation of a Timer Facility. In *Proceedings of the 11th ACM Symposium on Operating Systems Principles*. 1987. URL: [http://www.cs.](http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf) [columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf.](http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf)
- <span id="page-1084-0"></span>[VIT90] VITA. *Open Real-Time Kernel Interface Definition*. VITA, the VMEbus International Trade Association, August 1990. Draft 2.1. URL: [https://ftp.rtems.org/pub/rtems/](https://ftp.rtems.org/pub/rtems/publications/RTEID-ORKID/ORKID-2.1/ORKID-2_1.pdf) [publications/RTEID-ORKID/ORKID-2.1/ORKID-2\\_1.pdf.](https://ftp.rtems.org/pub/rtems/publications/RTEID-ORKID/ORKID-2.1/ORKID-2_1.pdf)
- <span id="page-1084-2"></span>[Wil12] Anthony Williams. *C++ Concurrency in Action - Practical Multithreading*. Manning Publications Co, 2012. ISBN 978-1933988771.

Bibliography 1057

1058 Bibliography
